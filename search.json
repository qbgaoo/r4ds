[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R数据科学 (第二版)",
    "section": "",
    "text": "欢迎语\n这是 “R数据科学”第二版的中文版。 这本书将告诉你如何用R从事数据科学：你将学到如何把数据导入R，并将其变换为最有用的结构，还有数据转换和可视化。\n在这本书中你将找到数据科学的一系列实践技能。正 如化学家学习如何清洗试管和配置实验室一样，你将学习如何清洗数据和绘制图表以及其他许多事情，这些技能使数据科学得以进行。在 这里你将会找到利用R进行这些操作的最佳方法。你 将学会如何利用图形的语法、编程文档和可复现研究来节省时间，还将学习如何管理认知资源，以便在清洗、可视化和探索数据时更容易发现新知识。\n根据CC BY-NC-ND 3.0授权，该网站是且将永远是免费的。如 果你想要这本书的纸质版，你可以通过Amazon订购。如 果你因为能免费阅读这本书而心存感激，并希望有所回馈，请向Kākāpō Recovery捐款。 kākāpō（出现在封面的这种鸟）是新西兰特有的一种濒危鹦鹉，目前仅剩248只。\n如果你喜欢阅读英文原版，可通过以下链接访问：\n你可以在https://mine-cetinkaya-rundel.github.io/r4ds-solutions找到书中习题的参考答案。\n请注意，本书采用了贡献者行为准则（Contributor Code of Conduct）。如 果您愿意为这本书做出贡献，表示您同意遵守其条款。",
    "crumbs": [
      "欢迎语"
    ]
  },
  {
    "objectID": "index.html#致谢",
    "href": "index.html#致谢",
    "title": "R数据科学 (第二版)",
    "section": "致谢",
    "text": "致谢\n本书由 https://github.com 托管，感谢他们对开源软件和社区的支持。",
    "crumbs": [
      "欢迎语"
    ]
  },
  {
    "objectID": "preface-2e.html",
    "href": "preface-2e.html",
    "title": "序言",
    "section": "",
    "text": "欢迎来到 “R 数据科学（第二版）”！ 该版在第一版的基础上做了一些重要修订，删除了我们认为不再有用的内容，增加了原本打算写进第一版的内容，并对文本和代码进行了整体更新，以反映最佳实践中的变化。同 时，我们也很高兴迎来一位新的合著者Mine Çetinkaya-Rundel，他是一位著名的数据科学教育工作者，也是我们在Posit(前身为RStudio)公司的一位同事。\n以下是这些重要变化的概述：\n\n本书第一部分已更名为“全局游戏” （Whole game）。这 部分的目的是在深入细节之前先为读者提供数据科学“全局游戏” 的大致情况。\n本书第二部分称为“可视化”（Visualize）。和 第一版相比，这部分对数据可视化工具和最佳实践进行了更为全面的介绍。虽 然要获取所有详细信息仍需参考名为 ggplot2的书, 但第二版已涵盖了很多最重要的可视化技术。\n本书第三部分称为“转换”（Transform）。这 部分增加了关于数字、逻辑向量和缺失值的新章节，这些之前都是数据转换章节的一部分，但现在需要更多的篇幅来覆盖所有细节。\n本书第四部分称为“导入”（Import）。这 是一组新章节，包括读取纯文本文件和电子表格，从数据库中获取数据、处理大数据、将层次结构数据转换为矩形数据，以及从网站抓取数据。\n“编程”（Program）部分保持不变，但已被从头至尾重写，聚焦于函数编写和迭代的最重要部分。函 数编写现在包含了如何封装tidyverse函数（处理tidy评估的挑战）的详细信息，因为这在过去几年中变得更容易、更重要。我 们还增加了一个base 包重要函数的新章节，这些函数你可能在实际遇到的R代码中看到。\n“建模”（Modeling）部分已被删除。我 们之前没有足够的篇幅来全面深入地讲解建模，但现在已经有更好的资源可供选择。我 们一般推荐使用tidymodels 包，并推荐阅读由Max Kuhn和Julia Silge撰写的Tidy Modeling with R一书。\n“交流”（Communicate）部分依然保留，但已全面更新。本 书第二版利用Quarto编写，而不是R Markdown，Quarto被看作是更具应用前景的工具。",
    "crumbs": [
      "序言"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "引言",
    "section": "",
    "text": "你将学到什么\n数据科学范围广阔，不可能通过读一本书就完全掌握。本 书的目的旨在为你学习R这个重要工具提供坚实和足够的基础知识，以便在必要时可以找到进一步学习的资源。典 型的数据科学项目包含的步骤大致如 图 1 所示。\n图 1: 在数据科学过程模型中，首先进行数据导入和整理。接下来，通过迭代循环的转换、 可视化和建模来理解数据。最后，通过与他人交流结果来完成整个过程。\n首先，必须将数据导入 (import ) R中。 这通常意味着你需要从文件、数据库或Web应用程序接口 (API) 中获取数据，并将其加载到R的一个数据框中。如 果无法将数据导入R，就无法在其上开展数据科学工作！\n一旦导入了数据，还需对其进行整齐 (tidy)。整 齐数据意味着以统一的形式存储数据，使数据集的语义与其存储方式相匹配。简 而言之，当数据整齐时，每一列都是一个变量，每一行都是一个观测值。整 齐的数据很重要，因为结构一致使你可以将精力集中在回答有关数据的问题上，而不是努力将数据转换成适合不同功能的正确形式。\n当数据整齐完成后，通常下一步是数据转换 (transform)。转 换包括缩小感兴趣的观察值的范围(如一个城市的所有人或去年的所有数据)、根据现有变量创建新变量(如根据距离和时间计算速度)，以及计算一组数据的统计量(如计数或平均值)。整 齐和转换统称为数据清洗 (wrangling) 因为将数据以自然的形式处理通常感觉像是一场战斗!\n当有了由所需变量组成的整齐数据后，就可利用两个主要的知识生成引擎:可视化和建模。它 们的优缺点互补，因此任何数据分析都可反复利用它们。\n可视化 (Visualization) 是一项基本的人类活动。一 个好的可视化会显示你没有预料到的东西，或者提出关于数据的新问题。一 个好的可视化还可能暗示你问错了问题，或者你需要收集不同的数据。可 视化可能会让你感到惊讶，但它们的扩展性并不强，因为它们需要人来解释。\n建模 (Models) 是对可视化的补充。一 旦你的问题足够精准，你就可以用一个模型来回答。模 型基本上是数学或计算工具，因此它们通常具有良好的可扩展性。即 使模型扩展性不佳，买更多的电脑通常比买更多的大脑要便宜！但 每个模型都需要做假设，而且就其本质而言，模型不能质疑自己的假设。这 意味着一个模型不能从根本上给你带来惊喜。\n数据科学的最后一步是交流 (communication)，这是每个数据分析项目中绝对重要的步骤。除 非你能够与他人交流你的结果，否则无论模型和可视化如何帮助你很好地理解数据都无足轻重。\n围绕所有这些工具的是编程 (programming)。编 程是一种综合工具，在数据科学项目的几乎每个部分都要用到。要 成为一名成功的数据科学家，你不需要成为一名专业的程序员，但是学习更多的编程知识是值得的，因为成为一名好的程序员可以让你解决常规问题自动化，并使解决新问题变得更轻松。\n你将在每个数据科学项目中用到这些工具，但对大多数项目来说这些工具还不够。这 里有一个大致的80/20规则：你可以使用你在本书中学到的工具来解决项目中大约80%的问题，但剩下的20%需要其他工具来处理。在 本书中我们将为你提供了解更多信息的资源。",
    "crumbs": [
      "引言"
    ]
  },
  {
    "objectID": "intro.html#本书的组织结构",
    "href": "intro.html#本书的组织结构",
    "title": "引言",
    "section": "本书的组织结构",
    "text": "本书的组织结构\n前面关于数据科学工具的描述大致上是按照数据分析中使用的顺序组织的 (当然，你会多次重复这个过程)。然 而，根据我们的经验，首先学习数据导入和整理是次优的，因为80%的时间是常规的且无聊的，而另外20%的时间是不寻常且令人沮丧的。这 不是学习新学科的好起点！相 反，我们将从已经导入和整理的数据的可视化和转换开始。这 样，当你处理和整理自己的数据时，你的动力就会保持高涨，因为你知道痛苦是值得的。\n在每一章中，我们尽量遵循一个一致的模式：从一些鼓舞人心的例子开始，让你可以看到更大的图景，然后再深入到细节中。书 中的每一部分都配有练习来帮助你练习所学的知识。虽 然跳过练习很有诱惑力，但没有比在实际问题上练习更好的学习方法了。",
    "crumbs": [
      "引言"
    ]
  },
  {
    "objectID": "intro.html#学不到的内容",
    "href": "intro.html#学不到的内容",
    "title": "引言",
    "section": "学不到的内容",
    "text": "学不到的内容\n有几个重要的主题这本书没有涉及。我 们认为坚持不懈地专注于最基本的东西是很重要的，这样你就能尽快开始行动。这 也表明这本书不可能涵盖每一个重要主题。\n\n建模\n对于数据科学来说建模是非常重要的，但这是一个很大的主题。而 不幸的是，我们没有足够的空间在这里给予它应有的篇幅。要 了解更多关于建模的知识，我们强烈推荐由我们的同事Max Kuhn和Julia Silge的编写的Tidy Modeling with R 。本 书将向你介绍tidymodels包家族，正如你从名称中猜到的那样，它与我们在本书中使用的tidyverse包共享许多约定。\n\n\n大数据\n本书主要关注小型内存数据集。这 是一个正确的起点，因为只有在你具备处理小数据的经验后，才能处理大数据。本 书大部分内容所提供的工具都可以用来轻松处理数百兆字节的数据，稍加注意它们甚至可以处理几GB的数据。我 们还将向你展示如何从数据库和Parquet文件中获取数据，这两种文件通常用于存储大数据。你 不一定能够处理整个数据集，但这不是问题，因为你只需要一个子集或者子样本来回答你感兴趣的问题。\n如果你经常需要处理更大的数据 (比如说10-100GB)，我们建议你进一步了解 data.table。我 们在这里不做讲解，因为它使用的接口与tidyverse不同，需要学习一些不同的约定。然 而它的速度非常快，如果你正在处理大数据，那么它的优异性能表现值得你投入一些时间来学习它。\n\n\nPython、Julia和其他编程语言\n在这本书中，你不会学到任何关于Python、Julia或其他对数据科学有用的编程语言的知识。这 并不是因为我们认为这些工具不好，它们很优秀！在 实践中，大多数数据科学团队使用混合语言，通常至少是R和Python。但 我们坚信，最好一次只掌握一种工具，R就是一个很好的起点。",
    "crumbs": [
      "引言"
    ]
  },
  {
    "objectID": "intro.html#预备知识",
    "href": "intro.html#预备知识",
    "title": "引言",
    "section": "预备知识",
    "text": "预备知识\n为了让你从这本书中获得最大的收益，我们对你已经知道的内容做了一些假设。你 应该对数字有一定的了解，如果你已经有一些基本的编程经验，那将会很有帮助。如 果你以前从未编过程，你会发现Garrett编写的Hands on Programming with R 是这本书的一个有益补充。\n运行这本书中的代码，你需要四样东西：R、RStudio，一个名为tidyverse的R包集合以及其他几个包。包 是可重现R代码的基本单元。它 们包括可重用的函数、描述如何使用它们的文档以及样本数据。\n\nR\n要下载R，请访问CRAN (the comprehensive R archive network) https://cloud.r-project.org。R 新的主要版本每年发布一次，也会发布2-3个次要版本，建议定期更新。升 级可能会有点麻烦，特别是主要版本，需要你重新安装所有的包，但是拖延只会让情况变得更糟。我 们建议本书使用R4.2.0或更高版本。\n\n\nRStudio\nRStudio 是一个用于编程的集成开发环境，你可以从 https://posit.co/download/rstudio-desktop/下载。\nRStudio每年更新几次，当新版本发布时，它会自动通知你，所以不需要定期查看，但最好定期升级，以利用最新和最强大的功能。对 于这本书，请确保你至少有RStudio 2022.02.0版本。\n当你启动RStudio后，如 图 2 ，在界面中你会看到两个关键区域：控制台面板和输出面板。现 在你需要知道的是，你在控制台面板中输入R代码，然后按回车键来运行它。随 着我们的逐步深入，你会学到更多1。\n\n\n\n\n\n\n\n\n图 2: RStudio IDE 有两个关键区域：在左侧的控制台面板中输入R代码， 在右侧的输出面板中查看图形。\n\n\n\n\n\n\n\nTidyverse\n你还需要安装一些R包。R 包是函数、数据和文档的集合，它扩展了基础R的功能。使 用包是成功使用R的关键。你 在本书中学习的大多数包都是所谓tidyverse的一部分。t idyverse中的所有包都共享数据和R编程的共同理念，并被精心安排在一起协同工作。\n你可以使用一行代码安装完整的tidyverse包：\n\ninstall.packages(\"tidyverse\")\n\n在你的计算机上，在控制台中键入这行代码，然后按enter键运行它，R将从CRAN下载软件包并安装到你的计算机上。\n在使用library()加载包之前，你无法使用包中的函数、对象或帮助文件。一 旦安装了一个包，你可以使用library() 来加载它：\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.4     ✔ readr     2.1.5\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.1\n#&gt; ✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n#&gt; ✔ purrr     1.0.2     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n这告诉你，tidyverse加载了9个包: dplyr、forcats、ggplot2、lubrid、purrr、reader、stringr、tibble和tidyr。它 们被认为是tidyverse的核心，因为几乎在所有数据分析中都会用到它们。\ntidyverse中的包变化相当频繁。可 以通过运行tidyverse_update()查看是否有可用的更新。\n\n\n其他包\n还有许多其他优秀的软件包，它们不是tidyverse的一部分，因为它们解决了不同领域的问题，或者是用不同的基本原则设计的。这 不会让它们变得更好或更糟，这只会让它们与众不同。换 句话说，对 tidyverse的补充不是messyverse，而是由相互关联的包组成的许多其他universes。随 着你使用R处理更多的数据科学项目，你将学习新的包和新的数据思考方式。\n在本书中，我们将使用许多来自tidyverse之外的包。例 如以下的包为我们在学习R的过程中提供了有趣的数据集：\n\ninstall.packages(\n  c(\"arrow\", \"babynames\", \"curl\", \"duckdb\", \"gapminder\", \n    \"ggrepel\", \"ggridges\", \"ggthemes\", \"hexbin\", \"janitor\", \"Lahman\", \n    \"leaflet\", \"maps\", \"nycflights13\", \"openxlsx\", \"palmerpenguins\", \n    \"repurrrsive\", \"tidymodels\", \"writexl\")\n  )\n\n我们还将使用一些其他包作为单独的示例。你 现在不需要安装它们，只要记住每当你看到这样的错误时：\n\nlibrary(ggrepel)\n#&gt; Error in library(ggrepel) : there is no package called ‘ggrepel’\n\n你需要运行 install.packages(\"ggrepel\") 来安装这个包。",
    "crumbs": [
      "引言"
    ]
  },
  {
    "objectID": "intro.html#运行r代码",
    "href": "intro.html#运行r代码",
    "title": "引言",
    "section": "运行R代码",
    "text": "运行R代码\n前一节向你展示了几个运行R代码的示例，书中的代码看起来是这样的：\n\n1 + 2\n#&gt; [1] 3\n\n如果你在本地控制台中运行相同的代码，它看起来像这样:\n&gt; 1 + 2\n[1] 3\n有两个主要区别：在控制台中，你在&gt;之后键入，&gt;称为提示符。我 们在书中没有显示提示符。在 本书中，输出用#&gt;注释掉。在 控制台中，它直接出现在代码之后。这 两个区别意味着，如果你使用的是电子书，你可以轻松地从书中复制代码并将其粘贴到控制台。\n在本书中，我们使用一致的约定来引用代码：\n\n函数用代码字体显示，后面跟着圆括号，如 sum() 或 mean()；\n其他R对象 (例如数据或函数参数) 用代码字体，没有圆括号, 如 flights 或 x.\n有时，为了明确对象来自哪个包，to make it clear which package an object comes from, 我们使用包名后面加两个冒号，如 dplyr::mutate() 或 nycflights13::flights。这 也是有效的R代码。",
    "crumbs": [
      "引言"
    ]
  },
  {
    "objectID": "intro.html#致谢",
    "href": "intro.html#致谢",
    "title": "引言",
    "section": "致谢",
    "text": "致谢\n这本书不仅仅是Hadley、我和Garrett的作品，也是我们与R社区许多人(面对面和在线)多次交谈的结果。非 常感谢与你们所有人的交流，非常感谢!\n这本书是公开编写的，许多人通过拉取请求（pull requests）做出了贡献。特别感谢通过GitHub拉取请求的259 位贡献者 (按用户名字母顺序): @a-rosenberg, Tim Becker (@a2800276), Abinash Satapathy (@Abinashbunty), Adam Gruer (@adam-gruer), adi pradhan (@adidoit), A. s. (@Adrianzo), Aep Hidyatuloh (@aephidayatuloh), Andrea Gilardi (@agila5), Ajay Deonarine (@ajay-d), @AlanFeder, Daihe Sui (@alansuidaihe), @alberto-agudo, @AlbertRapp, @aleloi, pete (@alonzi), Alex (@ALShum), Andrew M. (@amacfarland), Andrew Landgraf (@andland), @andyhuynh92, Angela Li (@angela-li), Antti Rask (@AnttiRask), LOU Xun (@aquarhead), @ariespirgel, @august-18, Michael Henry (@aviast), Azza Ahmed (@azzaea), Steven Moran (@bambooforest), Brian G. Barkley (@BarkleyBG), Mara Averick (@batpigandme), Oluwafemi OYEDELE (@BB1464), Brent Brewington (@bbrewington), Bill Behrman (@behrman), Ben Herbertson (@benherbertson), Ben Marwick (@benmarwick), Ben Steinberg (@bensteinberg), Benjamin Yeh (@bentyeh), Betul Turkoglu (@betulturkoglu), Brandon Greenwell (@bgreenwell), Bianca Peterson (@BinxiePeterson), Birger Niklas (@BirgerNi), Brett Klamer (@bklamer), @boardtc, Christian (@c-hoh), Caddy (@caddycarine), Camille V Leonard (@camillevleonard), @canovasjm, Cedric Batailler (@cedricbatailler), Christina Wei (@christina-wei), Christian Mongeau (@chrMongeau), Cooper Morris (@coopermor), Colin Gillespie (@csgillespie), Rademeyer Vermaak (@csrvermaak), Chloe Thierstein (@cthierst), Chris Saunders (@ctsa), Abhinav Singh (@curious-abhinav), Curtis Alexander (@curtisalexander), Christian G. Warden (@cwarden), Charlotte Wickham (@cwickham), Kenny Darrell (@darrkj), David Kane (@davidkane9), David (@davidrsch), David Rubinger (@davidrubinger), David Clark (@DDClark), Derwin McGeary (@derwinmcgeary), Daniel Gromer (@dgromer), @Divider85, @djbirke, Danielle Navarro (@djnavarro), Russell Shean (@DOH-RPS1303), Zhuoer Dong (@dongzhuoer), Devin Pastoor (@dpastoor), @DSGeoff, Devarshi Thakkar (@dthakkar09), Julian During (@duju211), Dylan Cashman (@dylancashman), Dirk Eddelbuettel (@eddelbuettel), Edwin Thoen (@EdwinTh), Ahmed El-Gabbas (@elgabbas), Henry Webel (@enryH), Ercan Karadas (@ercan7), Eric Kitaif (@EricKit), Eric Watt (@ericwatt), Erik Erhardt (@erikerhardt), Etienne B. Racine (@etiennebr), Everett Robinson (@evjrob), @fellennert, Flemming Miguel (@flemmingmiguel), Floris Vanderhaeghe (@florisvdh), @funkybluehen, @gabrivera, Garrick Aden-Buie (@gadenbuie), Peter Ganong (@ganong123), Gerome Meyer (@GeroVanMi), Gleb Ebert (@gl-eb), Josh Goldberg (@GoldbergData), bahadir cankardes (@gridgrad), Gustav W Delius (@gustavdelius), Hao Chen (@hao-trivago), Harris McGehee (@harrismcgehee), @hendrikweisser, Hengni Cai (@hengnicai), Iain (@Iain-S), Ian Sealy (@iansealy), Ian Lyttle (@ijlyttle), Ivan Krukov (@ivan-krukov), Jacob Kaplan (@jacobkap), Jazz Weisman (@jazzlw), John Blischak (@jdblischak), John D. Storey (@jdstorey), Gregory Jefferis (@jefferis), Jeffrey Stevens (@JeffreyRStevens), 蒋雨蒙 (@JeldorPKU), Jennifer (Jenny) Bryan (@jennybc), Jen Ren (@jenren), Jeroen Janssens (@jeroenjanssens), @jeromecholewa, Janet Wesner (@jilmun), Jim Hester (@jimhester), JJ Chen (@jjchern), Jacek Kolacz (@jkolacz), Joanne Jang (@joannejang), @johannes4998, John Sears (@johnsears), @jonathanflint, Jon Calder (@jonmcalder), Jonathan Page (@jonpage), Jon Harmon (@jonthegeek), JooYoung Seo (@jooyoungseo), Justinas Petuchovas (@jpetuchovas), Jordan (@jrdnbradford), Jeffrey Arnold (@jrnold), Jose Roberto Ayala Solares (@jroberayalas), Joyce Robbins (@jtr13), @juandering, Julia Stewart Lowndes (@jules32), Sonja (@kaetschap), Kara Woo (@karawoo), Katrin Leinweber (@katrinleinweber), Karandeep Singh (@kdpsingh), Kevin Perese (@kevinxperese), Kevin Ferris (@kferris10), Kirill Sevastyanenko (@kirillseva), Jonathan Kitt (@KittJonathan), @koalabearski, Kirill Müller (@krlmlr), Rafał Kucharski (@kucharsky), Kevin Wright (@kwstat), Noah Landesberg (@landesbergn), Lawrence Wu (@lawwu), @lindbrook, Luke W Johnston (@lwjohnst86), Kara de la Marck (@MarckK), Kunal Marwaha (@marwahaha), Matan Hakim (@matanhakim), Matthias Liew (@MatthiasLiew), Matt Wittbrodt (@MattWittbrodt), Mauro Lepore (@maurolepore), Mark Beveridge (@mbeveridge), @mcewenkhundi, mcsnowface, PhD (@mcsnowface), Matt Herman (@mfherman), Michael Boerman (@michaelboerman), Mitsuo Shiota (@mitsuoxv), Matthew Hendrickson (@mjhendrickson), @MJMarshall, Misty Knight-Finley (@mkfin7), Mohammed Hamdy (@mmhamdy), Maxim Nazarov (@mnazarov), Maria Paula Caldas (@mpaulacaldas), Mustafa Ascha (@mustafaascha), Nelson Areal (@nareal), Nate Olson (@nate-d-olson), Nathanael (@nateaff), @nattalides, Ned Western (@NedJWestern), Nick Clark (@nickclark1000), @nickelas, Nirmal Patel (@nirmalpatel), Nischal Shrestha (@nischalshrestha), Nicholas Tierney (@njtierney), Jakub Nowosad (@Nowosad), Nick Pullen (@nstjhp), @olivier6088, Olivier Cailloux (@oliviercailloux), Robin Penfold (@p0bs), Pablo E. Garcia (@pabloedug), Paul Adamson (@padamson), Penelope Y (@penelopeysm), Peter Hurford (@peterhurford), Peter Baumgartner (@petzi53), Patrick Kennedy (@pkq), Pooya Taherkhani (@pooyataher), Y. Yu (@PursuitOfDataScience), Radu Grosu (@radugrosu), Ranae Dietzel (@Ranae), Ralph Straumann (@rastrau), Rayna M Harris (@raynamharris), @ReeceGoding, Robin Gertenbach (@rgertenbach), Jajo (@RIngyao), Riva Quiroga (@rivaquiroga), Richard Knight (@RJHKnight), Richard Zijdeman (@rlzijdeman), @robertchu03, Robin Kohrs (@RobinKohrs), Robin (@Robinlovelace), Emily Robinson (@robinsones), Rob Tenorio (@robtenorio), Rod Mazloomi (@RodAli), Rohan Alexander (@RohanAlexander), Romero Morais (@RomeroBarata), Albert Y. Kim (@rudeboybert), Saghir (@saghirb), Hojjat Salmasian (@salmasian), Jonas (@sauercrowd), Vebash Naidoo (@sciencificity), Seamus McKinsey (@seamus-mckinsey), @seanpwilliams, Luke Smith (@seasmith), Matthew Sedaghatfar (@sedaghatfar), Sebastian Kraus (@sekR4), Sam Firke (@sfirke), Shannon Ellis (@ShanEllis), @shoili, Christian Heinrich (@Shurakai), S’busiso Mkhondwane (@sibusiso16), SM Raiyyan (@sm-raiyyan), Jakob Krigovsky (@sonicdoe), Stephan Koenig (@stephan-koenig), Stephen Balogun (@stephenbalogun), Steven M. Mortimer (@StevenMMortimer), Stéphane Guillou (@stragu), Sulgi Kim (@sulgik), Sergiusz Bleja (@svenski), Tal Galili (@talgalili), Alec Fisher (@Taurenamo), Todd Gerarden (@tgerarden), Tom Godfrey (@thomasggodfrey), Tim Broderick (@timbroderick), Tim Waterhouse (@timwaterhouse), TJ Mahr (@tjmahr), Thomas Klebel (@tklebel), Tom Prior (@tomjamesprior), Terence Teo (@tteo), @twgardner2, Ulrik Lyngs (@ulyngs), Shinya Uryu (@uribo), Martin Van der Linden (@vanderlindenma), Walter Somerville (@waltersom), @werkstattcodes, Will Beasley (@wibeasley), Yihui Xie (@yihui), Yiming (Paul) Li (@yimingli), @yingxingwu, Hiroaki Yutani (@yutannihilation), Yu Yu Aung (@yuyu-aung), Zach Bogart (@zachbogart), @zeal626, Zeki Akyol (@zekiakyol).",
    "crumbs": [
      "引言"
    ]
  },
  {
    "objectID": "intro.html#版权",
    "href": "intro.html#版权",
    "title": "引言",
    "section": "版权",
    "text": "版权\n本书的在线版本访问 https://r4ds.hadley.nz，在纸质书印刷期间本书将继续发展。本 书的源代码可在 https://github.com/hadley/r4ds获取。 本书由 Quarto提供支持，这使得编写结合了文本和可执行代码的书变得很容易。",
    "crumbs": [
      "引言"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "引言",
    "section": "",
    "text": "If you’d like a comprehensive overview of all of RStudio’s features, see the RStudio User Guide at https://docs.posit.co/ide/user.↩︎",
    "crumbs": [
      "引言"
    ]
  },
  {
    "objectID": "data-visualize.html",
    "href": "data-visualize.html",
    "title": "1  数据可视化",
    "section": "",
    "text": "1.1 引言\nR虽然有几个制图系统，但ggplot2是最优雅、功能最多的一个系统， ggplot2实现了描述和构建图形的连贯系统，即图形的语法。基 于ggplot2，通过学习一个系统并将其应用于许多地方，你可以做更多的事情而且速度更快。\n本章将告诉你如何利用ggplot2可视化数据。我 们将首先创建一个简单的散点图，并用它引入ggplot2的基本构建模块，美学映射和几何对象。然 后将引导你可视化单个变量的分布以及可视化两个或多个变量之间的关系。最 后，保存所做的图和一些故障排除提示。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#引言",
    "href": "data-visualize.html#引言",
    "title": "1  数据可视化",
    "section": "",
    "text": "“简单的图表比任何其他工具都能给数据分析师带来更多的信息.”\n— John Tukey\n\n\n\n\n1.1.1 必要条件\n本章重点介绍ggplot2， 它是tidyverse的核心包之一。要 访问本章中使用的数据集、帮助页和函数，请运行以下命令加载tidyverse：\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.4     ✔ readr     2.1.5\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.1\n#&gt; ✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n#&gt; ✔ purrr     1.0.2     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n这一行代码将加载 tidyverse，这是在几乎所有数据分析中都会用到的包。它 还告诉您tidyverse中的哪些函数与base R中的函数冲突（或者与您可能加载的其他包冲突）1。\n如果运行这段代码得到了错误信息，there is no package called 'tidyverse'，你需要先安装它，然后再次运行library()。\n\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n\n每个包只需要安装一次，但每次启动新会话时都需要加载它。\n除了tidyverse, 我们还会用到palmerpenguins包，其中包含penguins数据集，记录了Palmer群岛三个岛屿上企鹅的身体测量数据，以及ggthemes包，它提供了一个色盲安全调色板。\n\nlibrary(palmerpenguins)\nlibrary(ggthemes)",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#第一步",
    "href": "data-visualize.html#第一步",
    "title": "1  数据可视化",
    "section": "1.2 第一步",
    "text": "1.2 第一步\n长鳍企鹅的体重是比短鳍企鹅的体重大还是小？你 可能已经有了答案，但试着让你的答案更精确。鳍 长和体重之间的关系是什么样的？正 相关还是负相关？线 性的还是非线性的？这 种关系会因企鹅的种类而异吗？企 鹅生活的岛屿不同会有影响吗？让 我们创建可视化图形来回答这些问题。\n\n1.2.1 penguins 数据框\n您可以使用包palmerpenguins（palmerpenguins::penguins）中的penguins数据框架来测试你对这些问题的答案。数 据框架是变量(列)和观测(行)的矩形集合。p enguins 收录了344 条观测，由Kristen Gorman博士和南极科考站帕尔默站收集并提供2。\n为了使讨论更容易，让我们定义一些术语：\n\n变量：变量是可以测量的数量、质量或属性。\n值：值是你测量一个变量时的状态，一个变量的值可能会随着测量的不同而变化。\n观测：观测是在相似条件下进行的一组测量（通常在相同的时间和相同的对象上进行）。一 个观测会包含几个值，每个值与不同的变量相关联。我 们有时将一个观测称为一个数据点。\n表格数据：表格数据是一组值，每个值与一个变量和一个观测相关。如 果将每个值放在自己的“单元格”中，将每个变量放在自己的列中，将每个观测放在自己的行中，则表格数据是整洁的。\n\n在这种情况下，变量指的是所有企鹅的一个属性，而观测值指的是单个企鹅的所有属性。\n在控制台中键入数据框的名称，R会输出其内容的预览。需 要注意的是这个预览的顶部显示有tibble 。在 tidyverse中，我们使用称为tibbles的特殊数据框，随后你将了解到更多。\n\npenguins\n#&gt; # A tibble: 344 × 8\n#&gt;   species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;\n#&gt; 1 Adelie  Torgersen           39.1          18.7               181\n#&gt; 2 Adelie  Torgersen           39.5          17.4               186\n#&gt; 3 Adelie  Torgersen           40.3          18                 195\n#&gt; 4 Adelie  Torgersen           NA            NA                  NA\n#&gt; 5 Adelie  Torgersen           36.7          19.3               193\n#&gt; 6 Adelie  Torgersen           39.3          20.6               190\n#&gt; # ℹ 338 more rows\n#&gt; # ℹ 3 more variables: body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt;\n\n这个数据框包含 8 列。如 果使用glimpse()，你可以看到所有变量和每个变量的前几个观察值。如 果你在使用RStudio，运行View(penguins)会打开一个交互式数据预览器。\n\nglimpse(penguins)\n#&gt; Rows: 344\n#&gt; Columns: 8\n#&gt; $ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, A…\n#&gt; $ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torge…\n#&gt; $ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.…\n#&gt; $ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.…\n#&gt; $ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, …\n#&gt; $ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 347…\n#&gt; $ sex               &lt;fct&gt; male, female, female, NA, female, male, female, m…\n#&gt; $ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2…\n\npenguins 中的变量包括：\n\nspecies：企鹅的种类（Adelie, Chinstrap, or Gentoo）\nflipper_length_mm: 企鹅鳍的长度，以毫米为单位\nbody_mass_g: 企鹅的体重，以克为单位。\n\n要了解更多关于penguins的信息，可以运行?penguins打开帮助页面。\n\n\n1.2.2 最终目标\n本章的最终目标是在考虑企鹅种类的情况下重建展示企鹅鳍长和体重之间关系的视图。\n\n\n\n\n\n\n\n\n\n\n\n1.2.3 构建ggplot\n我们一步一步重建这个图。\n利用ggplot2包的函数ggplot()绘图。首 先定义一个绘图对象，然后向其添加图层。 ggplot()的第一个参数是在图中使用的数据集，因此ggplot(data = penguins)创建了一个空图，用于显示penguins数据，但由于我们还没有告诉它如何可视化它，所以现在它是空的。这 不是一个可以让人动心的图，但你可以把它想象成一块空白画布，你可以在上面画出剩下的图层。\n\nggplot(data = penguins)\n\n\n\n\n\n\n\n\n接下来，需要告诉ggplot()如何将数据中的信息以视觉方式呈现。 ggplot()函数的mapping 参数定义了数据集中的变量如何映射到图表的视觉属性（aesthetics）。 mapping参数总是在aes()函数中定义，而aes()的x和y参数则指定了哪些变量映射到x轴和y轴上。现 在，我们只将鳍长映射到x轴的美学属性上，将体重映射到y轴的美学属性上。g gplot2会在数据参数中查找映射的变量，在这个例子中就是penguins。\n下图显示了添加这些映射的结果。\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n)\n\n\n\n\n\n\n\n\n空画布现在有了更多构造，我们已清楚知道鳍的长度在哪里显示（x轴），身体质量在哪里显示（y轴）。但 penguins本身还没有出现在图中。这 是因为在代码中，我们还没有明确说明如何在图上表示来自数据框架的观测。\n为此我们需要定义一个geom（几何对象），geom是一个用来表示数据的图形。这 些geom在ggplot2中使用以geom_开头的函数。我 们通常利用图使用的geom类型来描绘图形。例 如，条形图使用geom_bar()，折线图使用geom_line()，箱形图使用geom_boxplot()，散点图使用geom_point()，等等。\n函数geom_point()为图添加了一个点图层，从而创建了散点图。g gplot2附带了许多geom函数，每个函数都为绘图添加不同类型的层。 你将在书中学到很多geom，特别是在 章节 9 中。\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n#&gt; Warning: Removed 2 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n\n\n\n\n\n\n\n现在我们得到了一些我们可能认为是“散点图”的东西，但这还不是我们的“最终目标”。但 利用这个图可以开始回答当初激发我们探索兴趣的问题：“鳍长和体重之间的关系是什么?” 这种关系似乎是正的（随着鳍的长度增加体重也会增加），呈线性（这些点聚集在一条直线上，而不是一条曲线），且线性关系比较强（在这样一条直线周围没有太多的发散点)。就体重而言，脚蹼较长的企鹅通常体型较大。\n在添加更多图层到这个图之前，让我们暂停一下，回顾一下我们得到的警告信息：\n\nRemoved 2 rows containing missing values (geom_point()).\n\n我们看到这条信息是因为我们的数据集中有两只企鹅缺少体重和（或）鳍长值，如果没有这两个值，ggplot2无法在图上表示它们。像 R一样，ggplot2也秉承这样一种理念：缺失值永远不应该无声地消失。这 种类型的警告可能是你在处理实际数据时最常见的警告类型之一。缺 失值是一个非常常见的问题，你将在本书中了解更多关于它们的信息，特别是在 章节 18 中。对 于本章剩下的部分，我们将忽略这个警告，这样它就不会出现在我们制作的每个图的旁边。\n\n\n1.2.4 添加美学和图层\n散点图对于展示两个数值变量之间的关系非常有用，但是对于两个变量之间任何明显的关系都应持怀疑态度，并询问是否有其他变量可以解释或改变这种明显关系的性质，这总是一个好的思路。例 如，不同物种的鳍长和体重的关系是否有所不同？让 我们将物种纳入图中，看看这是否能揭示出这些变量之间明显关系的任何额外见解。我 们通过使用不同颜色的点代表不同物种来实现这一点。\n为了实现这一点，我们需要修改美学还是geom？如 果你猜测是函数aes() 内的美学映射，那么表明你已经掌握了使用ggplot2进行数据可视化的方法！ 如果不是这样也不用担心， 在本书中你将制作更多的ggplot图，在制图的过程中有很多机会验证你的直觉。\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n当分类变量被映射到美学上时，ggplot2将自动为变量的每个水平（三个物种中的一个）分配一个唯一的美学值（这里是某种颜色），这个过程被称为scaling。g gplot2还将添加一个图例，解释哪些值对应于哪些水平。\n现在让我们再添加一层：一条显示体重和鳍长之间关系的平滑曲线。在 继续之前请参考上面的代码，并考虑如何将其添加到现有的图中。\n由于这是一个代表数据的新geom，我们将在我们的点几何上添加一个新的geom作为图层：geom_smooth()。我 们将指定基于method = \"lm\"的线性模型（linear model）绘制最佳拟合直线。\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\n我们已经成功地添加了直线，但是这个图和第 小节 1.2.2 节中的图看起来并不像，那里的图形整个数据集只有一条直线，而这里每个物种都有单独的一条直线。\n在ggplot()中定义的美学映射（aesthetic mappings）在全局级别时，会被传递到图的每一个后续的几何层（geom layers）。然 而，ggplot2 中的每个geom函数也可以接受一个映射参数（mapping argument），这允许在局部级别定义美学映射，这些映射会添加到从全局级别继承的映射中。由 于我们希望点（points）的颜色基于物种（species）来设置，但不想为它们将线（lines）分开，我们应该只在geom_point()中指定color = species。\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\n瞧!我 们有了一些看起来很像我们最终目标的东西，尽管它还不完美。我 们仍然需要为每种企鹅使用不同的形状，并改进标签。\n在图表上仅使用颜色来表示信息通常不是一个好主意，因为由于色盲或其他色觉差异，人们对颜色的感知会有所不同。因 此，除了颜色之外，我们还可以将物种映射到形状美学上。\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\n注意，图例也会自动更新以反映点的不同形状。\n最后，我们使用labs()函数在一个新的层中改进图的标签。l abs()函数的一些参数含义是不言自明的：title用于添加标题，subtitle用于添加副标题。其 他参数与美学映射相对应，x是x轴的标签，y是y轴的标签，而color和shape则定义了图例中的标签。此 外，我们可以使用来自ggthemes包的scale_color_colorblind()函数来改进颜色调色板，以确保它对色盲用户也是安全的。\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Body mass and flipper length\",\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\",\n    color = \"Species\", shape = \"Species\"\n  ) +\n  scale_color_colorblind()\n\n\n\n\n\n\n\n\n我们终于有了一个完全符合我们“最终目标”的图形!\n\n\n1.2.5 练习\n\npenguins有多少行？多 少列？\n数据框 penguins 中的 bill_depth_mm变量是什么？阅 读 ?penguins 的帮助文件后找到答案；\n制作 bill_depth_mm 和 bill_length_mm 的散点图；也就是说，创建一个散点图，y轴为bill_depth_mm, x轴为bill_length_mm。描 述这两个变量之间的关系；\n如果你做一个species与bill_depth_mm的散点图会发生什么？什 么几何对象是更好的选择？\n为什么下面的代码会给出一个错误，如何修复它?\n\nggplot(data = penguins) + \n  geom_point()\n\nna.rm参数在geom_point()中起什么作用？这 个参数的默认值是什么？创 建一个散点图，并在其中将这个参数设置为TRUE。\n在你之前练习的图中添加以下标题：“数据来自 palmerpenguins 包。” 提示：查看labs()函数的文档。\n重新创建以下可视化。b ill_depth_mm应该映射到哪个美学属性上？它 应该在全局级别映射还是在几何对象级别映射？\n\n\n\n\n\n\n\n\n\n在头脑中运行这段代码，预测输出将是什么样子；然后在R中运行代码并检查你的预测。\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = island)\n) +\n  geom_point() +\n  geom_smooth(se = FALSE)\n\n这两张图看起来会不同吗？为 什么相同/为什么不同？\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point() +\n  geom_smooth()\n\nggplot() +\n  geom_point(\n    data = penguins,\n    mapping = aes(x = flipper_length_mm, y = body_mass_g)\n  ) +\n  geom_smooth(\n    data = penguins,\n    mapping = aes(x = flipper_length_mm, y = body_mass_g)\n  )",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#sec-ggplot2-calls",
    "href": "data-visualize.html#sec-ggplot2-calls",
    "title": "1  数据可视化",
    "section": "1.3 ggplot2 调用",
    "text": "1.3 ggplot2 调用\n随着从入门部分学习的深入，我们将过渡到更简洁的 ggplot2 代码表达式。到 目前为止，我们已经非常明确了，简化代码对你的学习是非常有帮助的：\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n\n通常，函数的前一两个参数非常重要，你应该牢记它们。在 ggplot()中，前两个参数是data和mapping，在本书的剩余部分，我们将不再提供这些参数的名称。这 样既节省打字时间，又可通过减少额外文字，更容易地看出不同图之间的差异。这 是一个非常重要的编程关注点，我们将在 章节 25 中再次讨论。\n将前面的图更简洁地重写为：\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()\n\n在将来，您还将了解管道|&gt;，它将允许你使用以下命令创建该图形:\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#可视化分布",
    "href": "data-visualize.html#可视化分布",
    "title": "1  数据可视化",
    "section": "1.4 可视化分布",
    "text": "1.4 可视化分布\n如何可视化变量的分布取决于变量的类型：分类还是数值。\n\n1.4.1 分类变量\n如果一个变量只能取一小组值中的一个，那么它就是分类变量。要 检查分类变量的分布，可以使用条形图。条 形图的高度显示了每个x值的观测次数。\n\nggplot(penguins, aes(x = species)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n在具有非有序水平的分类变量的条形图中，如上面提到的企鹅物种，通常更可取思路的是根据它们的频率重新排序条形图。这 样做需要将变量转换为因子(R如何处理分类数据)，然后重新排序该因子的水平。\n\nggplot(penguins, aes(x = fct_infreq(species))) +\n  geom_bar()\n\n\n\n\n\n\n\n\n您将在 章节 16 中学到更多关于因子和处理因子的函数（如上面用到的fct_infreq()）。\n\n\n1.4.2 数值变量\n如果一个变量可以在一个大的数值范围内取值，并且对这些数值进行加、减或取平均数是有意义的，那么这个变量就是数值型（或定量型）的。数 值型变量可以是连续的，也可以是离散的。\n一个常用于连续变量分布的可视化方法是直方图。\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 200)\n\n\n\n\n\n\n\n\n直方图将x轴分成等间距的区间（或称为“箱”），然后使用条形的高度来显示落在每个区间内的观察值的数量。在 上面的图中，最高的条形表示有39个观察值的body_mass_g值在3,500克到3,700克之间，这是条形的左右边缘。\n你可以使用binwidth参数来设置直方图中区间的宽度，这个参数是以x变量的单位来衡量的。当 使用直方图时，你应该探索不同的区间宽度，因为不同的区间宽度可能会揭示不同的模式。在 下面的图中，区间宽度为20太窄了，导致条形太多，使得难以确定分布的形状。类 似地，区间宽度为2,000太高了，导致所有数据只被分到三个条形中，也难以确定分布的形状。区 间宽度取200达到了合理的平衡。\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 20)\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 2000)\n\n\n\n\n\n\n\n\n\n\n数值变量分布的另一种可视化方式是密度图。密 度图是直方图的平滑版本，是连续数据的实用替代方案，特别是当数据来自一个潜在的平滑分布时。我 们不会深入了解geom_density()如何估计密度（你可以在函数文档中了解更多），但我们可通过一个类比来解释如何绘制密度曲线。想 象一个由木块制成的直方图，然后想象你在直方图上放下一根煮熟的面条，面条在木块上披挂的形状可以看作是密度曲线的形状。与 直方图相比，它显示的细节较少，但可以更容易地快速了解分布的形状，特别是关于众数和偏态。\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_density()\n#&gt; Warning: Removed 2 rows containing non-finite outside the scale range\n#&gt; (`stat_density()`).\n\n\n\n\n\n\n\n\n\n\n1.4.3 练习\n\n做一个企鹅种类的条形图，把物种分配给y。这 个图有什么不同？\n下面两个图有什么不同？哪 种美学（颜色或填充）对改变条的颜色更有用？\n\nggplot(penguins, aes(x = species)) +\n  geom_bar(color = \"red\")\n\nggplot(penguins, aes(x = species)) +\n  geom_bar(fill = \"red\")\n\ngeom_histogram() 中的参数 bins 起什么作用？\n在加载tidyverse包后，对diamonds数据集中的carat变量制作一个直方图。尝 试使用不同的区间宽度。哪 种区间宽度揭示了最有趣的模式？",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#可视化关系",
    "href": "data-visualize.html#可视化关系",
    "title": "1  数据可视化",
    "section": "1.5 可视化关系",
    "text": "1.5 可视化关系\n为了可视化关系，我们需要将至少两个变量映射到图的美学上。在 下面的内容中，你将了解用于可视化两个或多个变量之间关系的常用绘图以及用于创建它们的几何图形。\nTo visualize a relationship we need to have at least two variables mapped to aesthetics of a plot. In the following sections you will learn about commonly used plots for visualizing relationships between two or more variables and the geoms used for creating them.\n\n1.5.1 数值变量和分类变量\n为了可视化数值变量和分类变量之间的关系，我们可以使用并列箱线图。箱 线图是一种描述分布的位置度量指标（百分位数）的视觉简写形式，它还有助于识别潜在的异常值。如 图 1.1 所示，每个箱线图包括：\n\n一个箱子，表示数据中间一半的范围，即从分布的25%百分位数到75%百分位数的距离，这个距离称为四分位距（interquartile range，IQR）。在箱子的中间有一条线，表示分布的中位数，即50%百分位数。这三条线可以让你感受到分布的离散程度以及分布是否关于中位数对称或偏向一侧。\n视觉点，用于显示距离箱子边缘超过1.5倍IQR的观测值。这些异常点是不寻常的，因此单独绘制。\n一条线（或称为“胡须”），从箱子的每个末端延伸出去，直到分布中最远的非异常值点。\n\n\n\n\n\n\n\n\n\n图 1.1: Diagram depicting how a boxplot is created.\n\n\n\n\n\n让我们用geom_boxplot()来看看按物种分组的企鹅体重的分布:\n\nggplot(penguins, aes(x = species, y = body_mass_g)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n或者，使用geom_density()绘制密度图。\n\nggplot(penguins, aes(x = body_mass_g, color = species)) +\n  geom_density(linewidth = 0.75)\n\n\n\n\n\n\n\n\n我们还使用了linewidth参数来定制线条的粗细，以便使它们在背景中更加突出。\n此外，我们可以将物种映射到颜色和填充的美学特性，并使用alpha美学特性为填充的密度曲线添加透明度。这 个美学特性取值范围在0（完全透明）和1（完全不透明）之间。在 下图中，它被设置为0.5。\n\nggplot(penguins, aes(x = body_mass_g, color = species, fill = species)) +\n  geom_density(alpha = 0.5)\n\n\n\n\n\n\n\n\n注意我们在这里使用的术语:\n\n如果想让美学所代表的视觉属性根据变量的值而变化，我们可以将变量映射到美学。\n否则，设置该美学特性的值。\n\n\n\n1.5.2 两个分类变量\n我们可以使用堆叠条形图来可视化两个分类变量之间的关系。例 如，下面的两个堆叠条形图都显示了岛屿和物种之间的关系，或者具体地说，显示了每个岛屿内物种的分布。\n第一张图显示了每个岛屿上每种企鹅的频数。频 数图显示，每个岛上的Adelies企鹅数量相等。但 是，我们无法很好地感知每个岛屿内部的比例平衡。\n\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n第二个图是通过在geom中设置position = \"fill\"创建的相对频数图，它对于比较不同岛屿上的物种分布更有用，因为它不受岛屿之间企鹅数量不等的影响。根 据此图，我们可以看到Gentoo企鹅都生活在Biscoe岛上，约占该岛屿企鹅的75%，Chinstrap企鹅都生活在Dream岛上，约占该岛屿企鹅的50%，而Adelie企鹅生活在所有三个岛屿上，并且Torgersen岛上都是Torgersen企鹅。\n\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar(position = \"fill\")\n\n\n\n\n\n\n\n\n在创建这些条形图时，我们将要被分割成条形的变量映射到x美学上，而将改变条形内部颜色的变量映射到fill美学上。\n\n\n1.5.3 两个数值变量\n到目前为止，你已经学习了散点图（用geom_point()创建）和平滑曲线（用geom_smooth()创建），用于可视化两个数值变量之间的关系。散 点图可能是用于可视化两个数值变量间关系的最常用图形。\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\n1.5.4 三个或更多变量\n正如我们在@sec-adding-aesthetics-layers 中看到的，我们可以通过将更多变量映射到额外的美学特性来将它们融入图表中。例 如，在下面的散点图中，点的颜色代表物种，而点的形状代表岛屿。\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species, shape = island))\n\n\n\n\n\n\n\n\n然而，在图表中添加过多的美学映射会使它变得杂乱无章且难以理解。另 一种特别适用于分类变量的方法是将图形拆分为多个分面（facets），即每个分面显示数据的一个子集。\n要通过单个变量将图表拆分为分面，请使用facet_wrap()。f acet_wrap()的第一个参数是一个公式（formula）3，通过~后跟变量名来创建这个公式，传递给facet_wrap()的变量应该是分类变量。\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species, shape = species)) +\n  facet_wrap(~island)\n\n\n\n\n\n\n\n\n在 章节 9 中，你将学习许多其他用于可视化变量分布以及它们之间关系的几何对象（geoms）。\n\n\n1.5.5 练习\n\nggplot2包中捆绑的mpg数据框包含了美国环境保护局收集的234个观测值，涵盖了38种汽车型号。m pg中的哪些变量是分类变量？哪 些变量是数值变量？（ 提示：键入?mpg以读取数据集的文档。）当你运行mpg时，如何查看这些信息？\n使用mpg数据框制作hwy与displ的散点图。接 下来，将第三个数值变量映射到 color，然后映射到size，再同时映射到color和size，最后映射到shape。这 些美学特性在分类变量与数值变量上表现有何不同？\n在hwy与displ的散点图中，如果将第三个变量映射到linewidth，会发生什么？\n如果你将同一个变量映射到多个美学特性上会发生什么？\n制作bill_depth_mm与bill_length_mm的散点图，并按species对点进行着色。通 过按物种着色，可以揭示这两个变量之间的关系是什么？如 果按species分面又会如何？\n为什么以下代码会生成两个独立的图例？你 如何修复它以合并这两个图例？\n\nggplot(\n  data = penguins,\n  mapping = aes(\n    x = bill_length_mm, y = bill_depth_mm, \n    color = species, shape = species\n  )\n) +\n  geom_point() +\n  labs(color = \"Species\")\n\n创建以下两个堆叠条形图。第 一个图可以回答哪个问题？第 二个图可以回答哪个问题？\n\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar(position = \"fill\")\nggplot(penguins, aes(x = species, fill = island)) +\n  geom_bar(position = \"fill\")",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#sec-ggsave",
    "href": "data-visualize.html#sec-ggsave",
    "title": "1  数据可视化",
    "section": "1.6 保存图形",
    "text": "1.6 保存图形\n一旦你创建了图形，你可能想将其从R中导出并保存为图像，以便在其他地方使用。这 就是ggsave()函数的作用，它会将最近创建的图保存到磁盘上：\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point()\nggsave(filename = \"penguin-plot.png\")\n\n这会将图保存到工作目录, 您会在@sec-workflow-scripts-projects 中更多地了解这个概念。\n如果你没有指定width和height，则将从当前绘图设备的尺寸中获取它们。为 了代码的可重复性，你应该指定它们。可 以在文档中了解更多关于ggsave()的信息。\n然而，一般来说，我们推荐你使用Quarto来组合你的最终报告，Quarto是一个可重复的创作系统，它允许你将代码和文本穿插在一起，并自动将你的图包含在报告中。你 将在 章节 28 中了解更多关于Quarto的信息。\n\n1.6.1 练习\n\n运行以下代码行。这 两个图中哪一个被保存为mpg-plot.png？为 什么？\n\nggplot(mpg, aes(x = class)) +\n  geom_bar()\nggplot(mpg, aes(x = cty, y = hwy)) +\n  geom_point()\nggsave(\"mpg-plot.png\")\n\n你需要在上面的代码中更改什么以将图形保存为PDF而不是PNG？如 何知道在ggsave()中可以保存哪些类型的图像文件？",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#常见问题",
    "href": "data-visualize.html#常见问题",
    "title": "1  数据可视化",
    "section": "1.7 常见问题",
    "text": "1.7 常见问题\n当你开始运行R代码时，你很可能会遇到问题。不 用担心，每个人都会遇到这样的问题。我 们已经写了多年的R代码，但每天我们还是会写出第一次尝试时不工作的代码！\n首先，仔细比较你正在运行的代码和书中的代码。R 非常挑剔，一个放错位置的字符可能就会产生截然不同的结果。确 保每个(都有一个匹配的)，每个双引号\"都有另一个\"配对。有 时你运行代码后什么都不会发生。检 查控制台左侧：如果是一个+，这意味着R认为你没有输入完整的表达式，它在等待你完成它。在 这种情况下，通常很容易通过按ESC键来中止当前命令的处理，然后重新开始。\n在创建ggplot2图形时，一个常见的问题是将加号+放在错误的位置：它必须放在行的末尾，而不是开头。换 句话说，确保你没有写出这样的代码：\n\nggplot(data = mpg) \n+ geom_point(mapping = aes(x = displ, y = hwy))\n\n如果你仍然无法解决问题，尝试使用帮助功能。你 可以在控制台中运行?function_name来获取任何R函数的帮助，或者在RStudio中突出显示函数名并按F1键。如 果帮助信息看起来不太有用，不要担心，直接跳到示例部分，寻找与你试图做的事情相匹配的代码。\n如果这没有帮助，请仔细阅读错误消息。有 时答案就隐藏在其中！但 是当你刚开始学习R时，即使答案在错误消息中，你可能还不知道如何理解它。另 一个很好的工具是Google：尝试搜索错误消息，因为很可能有人遇到过同样的问题，并在网上得到了帮助。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#小结",
    "href": "data-visualize.html#小结",
    "title": "1  数据可视化",
    "section": "1.8 小结",
    "text": "1.8 小结\n在本章中，你学习了使用ggplot2进行数据可视化的基础知识。我 们首先介绍了ggplot2的基本原理：可视化是一种将你的数据中的变量映射到诸如位置、颜色、大小和形状等美学属性的过程。然 后，你学习了如何逐层增加复杂性并改进你的图表的呈现方式。你 还学习了如何利用额外的美学映射和/或通过将图表分割成多个小图（faceting）来可视化单个变量的分布以及两个或多个变量之间的关系。\n在本书中，我们将反复使用可视化，并在需要时介绍新的技术；同时在 章节 9 到 章节 11 中更深入地探讨使用ggplot2创建可视化。\n掌握了可视化的基础后，我们将在下一章中稍微转换一下方向，给你一些实用的工作流程建议。我 们在本书的这一部分穿插了工作流程建议和数据科学工具，因为这将帮助你在编写越来越多的R代码时保持组织有序。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#footnotes",
    "href": "data-visualize.html#footnotes",
    "title": "1  数据可视化",
    "section": "",
    "text": "你可以通过使用冲突包（conflicted package）来消除该消息，并按需强制解决冲突，这在你加载更多包时变得尤为重要。可 以在https://conflicted.r-lib.org上了解更多关于此的信息。↩︎\nHorst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. https://allisonhorst.github.io/palmerpenguins/. doi: 10.5281/zenodo.3960218.↩︎\n这里的“formula”是由~创建的事物的名称，而不是“equation”的同义词。↩︎",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html",
    "href": "workflow-basics.html",
    "title": "2  工作流程：基础",
    "section": "",
    "text": "2.1 编程基础\n让我们回顾一下之前我们忽略的一些基础知识，以便让您尽快学会绘图。你 可以用R来做基本的数学计算：\n1 / 200 * 30\n#&gt; [1] 0.15\n(59 + 73 + 2) / 3\n#&gt; [1] 44.66667\nsin(pi / 2)\n#&gt; [1] 1\n可以使用赋值操作符创建新对象&lt;-:\nx &lt;- 3 * 4\n注意，x的值没有被打印出来, 它只是被保存起来了。如 果要查看该值，请在控制台中键入x。\n可以用c()将多个元素组合成一个向量：\nprimes &lt;- c(2, 3, 5, 7, 11, 13)\n向量的基本运算应用于向量的每一个元素：\nprimes * 2\n#&gt; [1]  4  6 10 14 22 26\nprimes - 1\n#&gt; [1]  1  2  4  6 10 12\n所有创建对象的R语句，亦即赋值语句，都有相同的形式:\nobject_name &lt;- value\n当你读这段代码时，在心里默念“对象名获得了值”。\n你会进行大量的赋值操作，而&lt;-打起来比较费劲，你可以使用 RStudio 的快捷键来节省时间：Alt + -（减号）。请 注意，RStudio 会自动在&lt;-周围添加空格，这是一种良好的写代码习惯。代 码在美好的日子里读起来也可能很令人痛苦（试试giveyoureyesabreak），所以给你的眼睛休息一下，使用空格吧。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>工作流程：基础</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#注释",
    "href": "workflow-basics.html#注释",
    "title": "2  工作流程：基础",
    "section": "2.2 注释",
    "text": "2.2 注释\nR会忽略该行中#之后的任何文本。这 允许你编写注释，即 R 会忽略但人类可以阅读的文本。我 们有时会在示例中包含注释，以解释代码正在做什么。\n注释可以帮助您简要描述下面代码的功能。\n\n# create vector of primes\nprimes &lt;- c(2, 3, 5, 7, 11, 13)\n\n# multiply primes by 2\nprimes * 2\n#&gt; [1]  4  6 10 14 22 26\n\n像这样简短的代码段，可能不需要为每一行代码都留下注释。但 是，随着编写的代码变得越来越复杂，注释可以帮助你（及你的合作者）节省很多时间来弄清楚代码是做什么的。\n使用注释来解释你编写代码的原因（why），而不是方法（how）或内容（what）。通 过仔细阅读代码，总是有可能弄清楚代码的方法和内容的，尽管这可能会很繁琐。如 果你在注释中描述了每一步，然后修改了代码，你需要记得同时更新注释，否则当你将来再次查看这段代码时，可能会感到困惑。\n弄清楚为什么这么做往往更加困难，甚至是不可能的。例 如，geom_smooth()函数有一个名为span的参数，它控制曲线的平滑度，较大的值会产生更平滑的曲线。假 设你决定将span的值从默认的 0.75 改为 0.9：未来的读者很容易理解发生了什么，但除非你在注释中注明你的思考过程，否则没有人会理解你为什么要改变默认值。\n对于数据分析代码，使用注释来解释你的整体策略和步骤，并在遇到重要见解时记录下来。这 些知识是无法仅从代码本身重新获取的。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>工作流程：基础</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#sec-whats-in-a-name",
    "href": "workflow-basics.html#sec-whats-in-a-name",
    "title": "2  工作流程：基础",
    "section": "2.3 对象名称",
    "text": "2.3 对象名称\n对象名必须以字母开头，并且只能包含字母、数字、_和 .。你希望对象名是描述性的，因此需要为多个单词采用一种约定。我 们推荐使用蛇形命名法（snake_case），即使用 _分隔小写单词。\n\ni_use_snake_case\notherPeopleUseCamelCase\nsome.people.use.periods\nAnd_aFew.People_RENOUNCEconvention\n\n当讨论 章节 4 中的代码风格时，我们将再次回到对象名。\n你可以通过输入一个对象的名字来检查它：\n\nx\n#&gt; [1] 12\n\n下面是另外一个赋值：\n\nthis_is_a_really_long_name &lt;- 2.5\n\n要检查这个对象，请尝试RStudio的补全功能：输入“this”，按TAB键，添加字符，直到有一个唯一的前缀，然后按回车键。\n假设你犯了一个错误，this_is_a_really_long_name的值应该是 3.5 而不是 2.5，你可以使用另一个键盘快捷键来帮助你修正它。例 如，按 ↑ 键来调出你刚才输入的最后一个命令并进行编辑。或 者输入 “this” ，然后按 Cmd/Ctrl + ↑ 来列出输入过的所有以这些字母开头的命令，使用箭头键来导航。然 后按 Enter 键重新输入命令，将 2.5 改为 3.5 并重新运行。\n再来一个赋值：\n\nr_rocks &lt;- 2^3\n\n试着检查一下：\n\nr_rock\n#&gt; Error: object 'r_rock' not found\nR_rocks\n#&gt; Error: object 'R_rocks' not found\n\n这说明你和R之间的存在隐含约定：R会为你完成繁琐的计算，但相应地，你的指令必须完全精确。如 果不这样做，你可能会收到一个错误提示，说未找到你正在查找的对象。拼 写很重要，如你在输入r_rock时可能指的是r_rocks，但R无法读懂你的想法。大 小写也很重要，如你输入R_rocks时可能指的是r_rocks，但R同样无法读懂你的想法。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>工作流程：基础</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#函数调用",
    "href": "workflow-basics.html#函数调用",
    "title": "2  工作流程：基础",
    "section": "2.4 函数调用",
    "text": "2.4 函数调用\nR有大量的内置函数，可以这样调用:\n\nfunction_name(argument1 = value1, argument2 = value2, ...)\n\n让我们尝试使用seq()函数来生成一系列有规律的数字，同时也学习 RStudio 的一些更实用的特性。输 入se并按下 TAB 键，这时会弹出一个窗口显示可能的补全选项。通 过输入更多内容（如q）来明确指定seq()，或者使用 ↑/↓ 箭头来选择。注 意弹出的浮动提示，它会提醒你函数的参数和用途。如 果你想要更多帮助，按下 F1 键，在右下角窗格的帮助选项卡中获取所有详细信息。\n当选择了想要的函数后，再次按下 TAB 键，RStudio 会为你添加匹配的左括号 ( 和右括号 ) 。输 入第一个参数的名字from，将其设置为等于 1，然后，输入第二个参数的名字to，并将其设置为等于10。最 后，按下回车键。\n\nseq(from = 1, to = 10)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\n在函数调用中我们经常省略前几个参数的名字，所以这一行代码也可以这样写:\n\nseq(1, 10)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\n输入以下代码，注意到 RStudio 在成对的引号上也提供了类似的帮助：\n\nx &lt;- \"hello world\"\n\n引号和括号总是成对出现。R Studio 会尽力帮助你，但仍然有可能出错并导致不匹配。如 果发生这种情况，R 会显示续行字符 +：\n&gt; x &lt;- \"hello\n+\n+告诉你 R 正在等待更多的输入，它认为你还没有完成。通 常，这意味着你忘记了输入一个\" 或者一个)。你可以添加缺失的配对符号，或者按下 ESCAPE 键来中止表达式并重新尝试。\n请注意，右上角窗格中的环境（Environment）选项卡显示了你创建的所有对象：",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>工作流程：基础</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#练习",
    "href": "workflow-basics.html#练习",
    "title": "2  工作流程：基础",
    "section": "2.5 练习",
    "text": "2.5 练习\n\n为什么这段代码不能正常运行？\n\nmy_variable &lt;- 10\nmy_varıable\n#&gt; Error in eval(expr, envir, enclos): object 'my_varıable' not found\n\n仔细看！这 可能看起来像是无意义的练习，但能训练你的大脑注意到即使是微小的差异，这在编程时也会让你有所受益。\n微调以下每个 R 命令，以便它们可以正确运行：\n\nlibary(todyverse)\n\nggplot(dTA = mpg) + \n  geom_point(maping = aes(x = displ y = hwy)) +\n  geom_smooth(method = \"lm)\n\n按下 Option + Shift + K / Alt + Shift + K，会发生什么？你 如何通过菜单到达同样的地方？\n重新看一下来自 小节 1.6 的一个练习。运 行以下代码行。哪 个图形被保存为 mpg-plot.png？为 什么？\n\nmy_bar_plot &lt;- ggplot(mpg, aes(x = class)) +\n  geom_bar()\nmy_scatter_plot &lt;- ggplot(mpg, aes(x = cty, y = hwy)) +\n  geom_point()\nggsave(filename = \"mpg-plot.png\", plot = my_bar_plot)",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>工作流程：基础</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#小结",
    "href": "workflow-basics.html#小结",
    "title": "2  工作流程：基础",
    "section": "2.6 小结",
    "text": "2.6 小结\n现在你已经学习了更多关于R代码如何工作的知识以及一些提示。在 将来重新使用代码时这些提示能帮助你更好地理解它。在 下一章，我们将继续数据科学之旅，向你介绍dplyr，它是tidyverse的一个包，可以帮助你转换数据，例如选择重要的变量、筛选感兴趣的行还是计算汇总统计量。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>工作流程：基础</span>"
    ]
  },
  {
    "objectID": "data-transform.html",
    "href": "data-transform.html",
    "title": "3  数据转换",
    "section": "",
    "text": "3.1 引言\n可视化是生成新见解的重要工具，但很少能刚好得到你所需的确切形式的数据来制作你想要的图。通 常，你需要创建一些新的变量或汇总统计量来用数据回答你的问题；或者你可能只是想重命名变量或重新排序观测值，以使数据更易于处理。在 本章中，你将学习如何做到这些（及更多）。本 章将介绍使用dplyr包和2013年从纽约市出发的航班数据集进行数据转换。\n本章的目标是为你概述转换数据框的所有关键工具。我 们将从对数据框的行和列进行操作的函数开始，然后再次回到讨论管道（pipe），这是一个重要的工具，用于组合动词。接 下来，我们将介绍处理分组的能力。我 们将以一个研究案例结束本章，该案例研究展示了这些函数的实际应用；当我们开始深入研究特定类型的数据（例如数字、字符串、日期）时，我们将在后续的章节中更详细地讨论这些函数。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据转换</span>"
    ]
  },
  {
    "objectID": "data-transform.html#引言",
    "href": "data-transform.html#引言",
    "title": "3  数据转换",
    "section": "",
    "text": "3.1.1 必要条件\n本章将重点讨论dplyr包，它是tidyverse的另一个核心成员。我 们将使用来自nycflights13包的数据来说明dplyr包的关键理念，并使用ggplot2来帮助我们理解数据。\n\nlibrary(nycflights13)\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.4     ✔ readr     2.1.5\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.1\n#&gt; ✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n#&gt; ✔ purrr     1.0.2     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n请注意加载tidyverse时显示的冲突消息。它 告诉你dplyr覆盖了R基础包中的一些函数。如 果你在加载dplyr后想使用这些函数的基础版本，你需要使用它们的全名：stats::filter() 和 stats::lag()。到 目前为止，我们主要忽略了函数来自哪个包，因为大多数情况下这并不重要。但 是，知道包名可以帮助你找到帮助和相关的函数，所以当我们需要精确地知道一个函数来自哪个包时，我们将使用与R相同的语法：packagename::functionname()。\n\n\n3.1.2 nycflights13\n为了探索基本的dplyr操作，我们将使用nycflights13::flights。此 数据集包含所有r format(nrow(nycflights13::flights), big.mark = “,”)2013年从纽约出发的航班。这 些数据来自美国Bureau of Transportation Statistics，并记录在 ?f lights。\n\nflights\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nflights是一个tibble（tibble是tidyverse使用的一种特殊类型的数据框），用于避免一些常见的意外情况。t ibble和数据框之间最重要的区别在于它们的输出方式；tibble是为了大型数据集设计的，因此它们只显示前几行和能够在一个屏幕上显示的列。有 几种方法可以查看所有内容。如 果你正在使用RStudio，最方便的可能是View(flights)，这会打开一个可以滚动和筛选的交互式视图。另 外你可以使用print(flights, width = Inf)来显示所有列，或者使用glimpse()函数：\n\nglimpse(flights)\n#&gt; Rows: 336,776\n#&gt; Columns: 19\n#&gt; $ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013…\n#&gt; $ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n#&gt; $ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n#&gt; $ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 55…\n#&gt; $ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 60…\n#&gt; $ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2,…\n#&gt; $ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 8…\n#&gt; $ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 8…\n#&gt; $ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7,…\n#&gt; $ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\"…\n#&gt; $ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301…\n#&gt; $ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N…\n#&gt; $ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LG…\n#&gt; $ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IA…\n#&gt; $ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149…\n#&gt; $ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 73…\n#&gt; $ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6…\n#&gt; $ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59…\n#&gt; $ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-0…\n\n在这两种视图中，变量名后面跟着缩写，这些缩写表示每个变量的类型：&lt;int&gt;是整数的缩写，&lt;dbl&gt;是双精度浮点数（也称为实数）的缩写，&lt;chr&gt;是字符（也称为字符串）的缩写，&lt;dttm&gt;是日期时间的缩写。这 些缩写很重要，因为你可以在一列上执行的操作在很大程度上取决于它的“类型”。\n\n\n3.1.3 dplyr 基础\n下面将学习dplyr的主要操作（即函数），这些函数能帮你解决绝大多数的数据处理问题。但 在讨论它们各自的差异之前，值得一提的是它们的共同点：\n\n第一个参数始终是一个数据框；\n后续参数通常使用变量名（不带引号）来描述要操作的列；\n输出始终是一个新的数据框。\n\n因为每个函数都擅长做一件事，所以解决复杂问题通常需要组合多个函数，我们将使用管道操作符|&gt;来实现这一点。我 们将在 小节 4.3 更详细地讨论管道操作符。简 言之，管道操作符将其左侧的内容传递给其右侧的函数，因此x |&gt; f(y)等同于f(x, y)，而x |&gt; f(y) |&gt; g(z)等同于g(f(x, y), z)，|&gt;最简单的发音是“then”。这 使得即使你还没有学习细节，也有可能理解下面的代码：\n\nflights |&gt;\n  filter(dest == \"IAH\") |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    arr_delay = mean(arr_delay, na.rm = TRUE)\n  )\n\ndplyr的函数根据作用对象不同分为四组：行（rows）、列（columns）、组（groups）或表（tables）。下 面将学习有关行、列和组的最重要函数，然后回到 章节 19 中探讨作用于表的合并操作。让 我们开始吧!",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据转换</span>"
    ]
  },
  {
    "objectID": "data-transform.html#行",
    "href": "data-transform.html#行",
    "title": "3  数据转换",
    "section": "3.2 行",
    "text": "3.2 行\n对数据集的行进行操作的最重要的函数是filter()，它影响行的去留而不改变它们的顺序；而函数arrange()改变行的顺序而不影响行的去留。这 两个函数都只影响行，列保持不变。我 们还将讨论distinct()，它找出具有唯一值的行，但与arrange()和filter()不同，它还可以选择性地修改列。\n\n3.2.1 filter()\nFilter()允许你根据列的值保留行1。 第一个参数是数据框，第二个及随后的参数是保留该行必须为真的条件。 例如，我们可以找出所有迟到超过120分钟(2小时)的航班:\n\nflights |&gt; \n  filter(dep_delay &gt; 120)\n#&gt; # A tibble: 9,723 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      848           1835       853     1001           1950\n#&gt; 2  2013     1     1      957            733       144     1056            853\n#&gt; 3  2013     1     1     1114            900       134     1447           1222\n#&gt; 4  2013     1     1     1540           1338       122     2020           1825\n#&gt; 5  2013     1     1     1815           1325       290     2120           1542\n#&gt; 6  2013     1     1     1842           1422       260     1958           1535\n#&gt; # ℹ 9,717 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n除了使用 &gt;（大于）之外，还可以使用 &gt;=（大于或等于）、&lt;（小于）、&lt;=（小于或等于）、==（等于）和 != （不等于）。你 还可以使用 & 或 , 来组合条件，表示“和”（检查两个条件是否都满足），或者使用 | 来表示“或”（检查任一条件是否满足）：\n\n# Flights that departed on January 1\nflights |&gt; \n  filter(month == 1 & day == 1)\n#&gt; # A tibble: 842 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 836 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n# Flights that departed in January or February\nflights |&gt; \n  filter(month == 1 | month == 2)\n#&gt; # A tibble: 51,955 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 51,949 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n当您结合使用 | 和 == 时有一个很有用的快捷方式：%in%。它 会保留变量等于右侧值之一的行：\n\n# A shorter way to select flights that departed in January or February\nflights |&gt; \n  filter(month %in% c(1, 2))\n#&gt; # A tibble: 51,955 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 51,949 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n我们将在 章节 12 中详细讨论这些比较和逻辑运算符。\n当你运行filter()时，dplyr会执行筛选操作，创建一个新的数据框，然后输出它。它 不会修改现有的flights数据集，因为dplyr函数永远不会修改它们的输入。要 保存结果，你需要使用赋值运算符&lt;-：\n\njan1 &lt;- flights |&gt; \n  filter(month == 1 & day == 1)\n\n\n\n3.2.2 常见错误\n从你刚开始学习R时，最容易犯的错误是在检验是否相等时使用=而不是==。f ilter()会告诉你发生了什么：\n\nflights |&gt; \n  filter(month = 1)\n#&gt; Error in `filter()`:\n#&gt; ! We detected a named input.\n#&gt; ℹ This usually means that you've used `=` instead of `==`.\n#&gt; ℹ Did you mean `month == 1`?\n\n另一个错误是像在英语中那样写“或”语句:\n\nflights |&gt; \n  filter(month == 1 | 2)\n\n这段代码“有效”，它不会抛出错误，但它没有按照你的期望去做，因为 | 首先检查条件month == 1，然后检查条件2，而检查2并不是一个合理的条件。我 们将在 小节 15.6.2 更多地了解这里发生了什么，以及为什么。\n\n\n3.2.3 arrange()\narrange()根据列的值改变行的顺序。它 根据一个数据框和一组列名（或更复杂的表达式）来排序。如 果你提供了多个列名，那么每个额外的列都将用于解决前面列中值的并列问题。例 如，下面的代码按出发时间排序，出发时间分布在四个列中。我 们首先得到最早的年份，然后在同一年份中，我们得到最早的月份，依此类推。\n\nflights |&gt; \n  arrange(year, month, day, dep_time)\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n你可以在arrange()内部对某一列使用desc()来根据该列的值以降序（从大到小）重新排序数据框。例 如，这段代码将航班按延误时间从长到短排序：\n\nflights |&gt; \n  arrange(desc(dep_delay))\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     9      641            900      1301     1242           1530\n#&gt; 2  2013     6    15     1432           1935      1137     1607           2120\n#&gt; 3  2013     1    10     1121           1635      1126     1239           1810\n#&gt; 4  2013     9    20     1139           1845      1014     1457           2210\n#&gt; 5  2013     7    22      845           1600      1005     1044           1815\n#&gt; 6  2013     4    10     1100           1900       960     1342           2211\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n注意，行数没有改变，我们只是对数据进行了排列，没有对其进行过筛选。\n\n\n3.2.4 distinct()\ndistinct()在数据集中找出所有唯一的行，所以从技术上讲，它主要对行进行操作。然 而，在大多数情况下，你会想要某些变量的不同组合，因此你也可以选择性地提供列名：\n\n# Remove duplicate rows, if any\nflights |&gt; \n  distinct()\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n# Find all unique origin and destination pairs\nflights |&gt; \n  distinct(origin, dest)\n#&gt; # A tibble: 224 × 2\n#&gt;   origin dest \n#&gt;   &lt;chr&gt;  &lt;chr&gt;\n#&gt; 1 EWR    IAH  \n#&gt; 2 LGA    IAH  \n#&gt; 3 JFK    MIA  \n#&gt; 4 JFK    BQN  \n#&gt; 5 LGA    ATL  \n#&gt; 6 EWR    ORD  \n#&gt; # ℹ 218 more rows\n\n或者，如果希望在筛选唯一行时保留其他列，您可以使用.keep_all = TRUE选项。\n\nflights |&gt; \n  distinct(origin, dest, .keep_all = TRUE)\n#&gt; # A tibble: 224 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 218 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n所有这些不同的航班都在1月1日并不是巧合：distinct()会在数据集中找到第一个出现的唯一行，并丢弃其余的行。\n如果你想要找到出现的次数，那么最好将distinct()替换为count()，并使用sort = TRUE参数，你可以按照出现次数的降序排列它们。你 将在 小节 13.3 学到更多关于count的内容。\n\nflights |&gt;\n  count(origin, dest, sort = TRUE)\n#&gt; # A tibble: 224 × 3\n#&gt;   origin dest      n\n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n#&gt; 1 JFK    LAX   11262\n#&gt; 2 LGA    ATL   10263\n#&gt; 3 LGA    ORD    8857\n#&gt; 4 JFK    SFO    8204\n#&gt; 5 LGA    CLT    6168\n#&gt; 6 EWR    ORD    6100\n#&gt; # ℹ 218 more rows\n\n\n\n3.2.5 练习\n\n针对每个条件，在单个管道中查找所有符合以下条件的航班：\n\n到达延误两小时或更长时间\n飞往休斯敦（IAH或HOU）\n由联合航空（United）、美国航空（American）,或达美航空（Delta）运营\n在夏季（七月、八月和九月）起飞\n到达延误超过两小时，但起飞不延误\n延误至少一小时，但在飞行中弥补了超过30分钟的时间\n\n对flights 进行排序以找到出发延误时间最长的航班；找到早上最早起飞的航班；\n对flights进行排序以找到最快的航班。（ 提示: 尝试在函数中包含数学计算。）\n2013年的每一天都有航班吗？\n哪些航班飞行了最远的距离？哪 些飞行了最短的距离？\n如果你同时使用filter()和arrange()，你使用的顺序重要吗？为 什么？思 考一下结果以及这些函数需要执行多少工作。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据转换</span>"
    ]
  },
  {
    "objectID": "data-transform.html#列",
    "href": "data-transform.html#列",
    "title": "3  数据转换",
    "section": "3.3 列",
    "text": "3.3 列\n有四个重要的函数，它们影响列而不改变行：mutate()用于根据现有列创建新列，select()用于更改列存留，rename()用于更改列的名称，而relocate()用于更改列的位置。\n\n3.3.1 mutate()\nmutate()的作用是添加根据现有列计算得到的新列。在 数据转换章节中，你将学习一系列函数，这些函数可用于处理不同类型的变量。目 前，我们将继续使用基础代数，这允许我们计算gain（即延误航班在空中弥补了多少时间）以及每小时的速度：\n\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60\n  )\n#&gt; # A tibble: 336,776 × 21\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n默认情况下，mutate()会在数据集的右侧添加新列，但这使得我们很难看到数据集里发生了什么。可 以使用.before参数来将变量添加到左侧2：\n\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60,\n    .before = 1\n  )\n#&gt; # A tibble: 336,776 × 21\n#&gt;    gain speed  year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1    -9  370.  2013     1     1      517            515         2      830\n#&gt; 2   -16  374.  2013     1     1      533            529         4      850\n#&gt; 3   -31  408.  2013     1     1      542            540         2      923\n#&gt; 4    17  517.  2013     1     1      544            545        -1     1004\n#&gt; 5    19  394.  2013     1     1      554            600        -6      812\n#&gt; 6   -16  288.  2013     1     1      554            558        -4      740\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, …\n\n.是一个标志，表示.before 是函数的参数，而不是我们正在创建的第三个新变量的名称。你 也可以使用.after在某个变量之后添加新变量，在.before和.after中，你都可以使用变量名而不是位置。例 如，我们可以在day之后添加新变量：\n\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60,\n    .after = day\n  )\n\n另外，你可以使用.keep参数来控制保留哪些变量。一 个特别有用的参数是”used”，它指定我们只保留在mutate()步骤中涉及或创建的列。例 如，以下输出将仅包含dep_delay、arr_delay、air_time、gain、hours和gain_per_hour这些变量。\n\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    hours = air_time / 60,\n    gain_per_hour = gain / hours,\n    .keep = \"used\"\n  )\n\n请注意，由于我们没有将上述计算的结果重新分配给flights数据框，新的变量gain、hours和gain_per_hour只会被输出出来，但不会被存储在一个数据框中。如 果我们希望这些变量在未来的数据框中可用，我们应该仔细考虑是否要将结果重新分配给flights，从而用更多的变量覆盖原始数据框，还是分配给一个新的对象。通 常，正确的答案是创建一个新的对象，并为其命名以清晰地指示其内容，例如delay_gain，但你也可能有充分的理由覆盖flights。\n\n\n3.3.2 select()\n获得包含数百甚至数千个变量的数据集并不罕见。在 这种情况下，第一个挑战通常是仅关注你感兴趣的变量。s elect()允许你基于变量的名称，通过操作快速缩小到一个有用的子集：\n\n按名称选择列:\n\nflights |&gt; \n  select(year, month, day)\n\n选择year和day之间的所有列:\n\nflights |&gt; \n  select(year:day)\n\n选择除了从year到day的所有列：\n\nflights |&gt; \n  select(!year:day)\n\n历史上，这个操作是用-而不是!来 完成的，所以你可能会在实际场景中看-。这 两个操作符具有相同的目的，但在行为上有细微的差别。我 们推荐使用!， 因为它读作“不是”，并且与&和|配合得很好。\n选择所有是字符的列：\n\nflights |&gt; \n  select(where(is.character))\n\n\n在select()中，你可以使用一些辅助函数：\n\nstarts_with(“abc”): 匹配以 “abc” 开头的名称；\nends_with(“xyz”): 匹配以 “xyz” 结尾的名称；\ncontains(“ijk”): 匹配包含 “ijk” 的名称；\nnum_range(“x”, 1:3): 匹配 x1、x2 和 x3。\n\n参阅?s elect以获取更多详细信息。一 旦你熟悉了正则表达式（这是 章节 15 的内容），你也可以使用matches()来选择匹配某个模式的变量。\n你可以在select()变量时使用=来重命名它们，新名称出现在=的左侧，旧变量出现在右侧：\n\nflights |&gt; \n  select(tail_num = tailnum)\n#&gt; # A tibble: 336,776 × 1\n#&gt;   tail_num\n#&gt;   &lt;chr&gt;   \n#&gt; 1 N14228  \n#&gt; 2 N24211  \n#&gt; 3 N619AA  \n#&gt; 4 N804JB  \n#&gt; 5 N668DN  \n#&gt; 6 N39463  \n#&gt; # ℹ 336,770 more rows\n\n\n\n3.3.3 rename()\n如果你想保留所有现有的变量，只是对几个重命名，可以使用rename()而不是select():\n\nflights |&gt; \n  rename(tail_num = tailnum)\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n如果您有一堆命名不一致的列，并且手工修复它们会很痛苦，请查看janitor::clean_names()，它提供了一些有用的自动清理方法。\n\n\n3.3.4 relocate()\n使用relocate()来移动变量。你 可能希望将相关变量收集在一起或将重要变量移到前面。默 认情况下，relocate()将变量移到前面:\n\nflights |&gt; \n  relocate(time_hour, air_time)\n#&gt; # A tibble: 336,776 × 19\n#&gt;   time_hour           air_time  year month   day dep_time sched_dep_time\n#&gt;   &lt;dttm&gt;                 &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1 2013-01-01 05:00:00      227  2013     1     1      517            515\n#&gt; 2 2013-01-01 05:00:00      227  2013     1     1      533            529\n#&gt; 3 2013-01-01 05:00:00      160  2013     1     1      542            540\n#&gt; 4 2013-01-01 05:00:00      183  2013     1     1      544            545\n#&gt; 5 2013-01-01 06:00:00      116  2013     1     1      554            600\n#&gt; 6 2013-01-01 05:00:00      150  2013     1     1      554            558\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 12 more variables: dep_delay &lt;dbl&gt;, arr_time &lt;int&gt;, …\n\n你也可以使用.before和.after参数指定放置它们的位置，就像mutate()一样:\n\nflights |&gt; \n  relocate(year:dep_time, .after = time_hour)\nflights |&gt; \n  relocate(starts_with(\"arr\"), .before = dep_time)\n\n\n\n3.3.5 练习\n\n比较dep_time、sched_dep_time和dep_delay，你认为这三个数字是如何联系起来的？\n头脑风暴，想尽可能多的从flights中选择变量dep_time、dep_delay、arr_time和arr_delay的方法。\n如果在select()调用中多次指定相同变量的名称，会出现什么情况？\nany_of()函数的作用是什么？为 什么它和下面这个向量结合会有用?\n\nvariables &lt;- c(\"year\", \"month\", \"day\", \"dep_delay\", \"arr_delay\")\n\n运行以下代码的结果是否让你感到惊讶？默 认情况下，select()的辅助函数如何处理大写和小写？如 何更改该默认值？\n\nflights |&gt; select(contains(\"TIME\"))\n\n将air_time重命名为air_time_min，以表明度量单位，并将其移动到数据框的开头。\n为什么下面的代码不运行，error 代表什么意思?\n\nflights |&gt; \n  select(tailnum) |&gt; \n  arrange(arr_delay)\n#&gt; Error in `arrange()`:\n#&gt; ℹ In argument: `..1 = arr_delay`.\n#&gt; Caused by error:\n#&gt; ! object 'arr_delay' not found",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据转换</span>"
    ]
  },
  {
    "objectID": "data-transform.html#sec-the-pipe",
    "href": "data-transform.html#sec-the-pipe",
    "title": "3  数据转换",
    "section": "3.4 管道",
    "text": "3.4 管道\n上面已经展示了管道的简单示例，但是当你开始组合使用多个函数时，它的真正功能才会出现。例 如，假设你想查找飞往休斯顿IAH机场的最快航班，您需要组合函数filter()、mutate()、select()和arrange():\n\nflights |&gt; \n  filter(dest == \"IAH\") |&gt; \n  mutate(speed = distance / air_time * 60) |&gt; \n  select(year:day, dep_time, carrier, flight, speed) |&gt; \n  arrange(desc(speed))\n#&gt; # A tibble: 7,198 × 7\n#&gt;    year month   day dep_time carrier flight speed\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n#&gt; 1  2013     7     9      707 UA         226  522.\n#&gt; 2  2013     8    27     1850 UA        1128  521.\n#&gt; 3  2013     8    28      902 UA        1711  519.\n#&gt; 4  2013     8    28     2122 UA        1022  519.\n#&gt; 5  2013     6    11     1628 UA        1178  515.\n#&gt; 6  2013     8    27     1017 UA         333  515.\n#&gt; # ℹ 7,192 more rows\n\n即使这个管道有四个步骤，也很容易浏览，因为每个步骤的函数都位于每行的开头：从flights数据开始，然后过滤，转换，选择，最后排序。\n如果我们不使用管道会发生什么？我 们可以将每个函数调用嵌套在前一个调用内部：\n\narrange(\n  select(\n    mutate(\n      filter(\n        flights, \n        dest == \"IAH\"\n      ),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n\n或者可以使用一些中间对象：\n\nflights1 &lt;- filter(flights, dest == \"IAH\")\nflights2 &lt;- mutate(flights1, speed = distance / air_time * 60)\nflights3 &lt;- select(flights2, year:day, dep_time, carrier, flight, speed)\narrange(flights3, desc(speed))\n\n虽然这两种形式都有其适用的时间和场合，但管道通常会产生更易于编写和阅读的数据分析代码。\n要在代码中添加管道，我们建议使用内置的键盘快捷键 Ctrl/Cmd + Shift + M。要 使用|&gt;而不是%&gt;%，你需要对 RStudio 选项进行一项更改，如 图 3.1 所示；稍后会详细介绍%&gt;%。\n\n\n\n\n\n\n\n\n图 3.1: To insert |&gt;, make sure the “Use native pipe operator” option is checked.\n\n\n\n\n\n\n\n\n\n\n\nMagrittr\n\n\n\n如果您已经使用了一段时间的tidyverse，那么你可能对magrittr包提供的%&gt;%管道很熟悉。m agrittr包包含在tidyverse中，所以你可以在加载tidyverse时使用%&gt;%：\n\nlibrary(tidyverse)\n\nmtcars %&gt;% \n  group_by(cyl) %&gt;%\n  summarize(n = n())\n\n对于简单的情况，|&gt;和%&gt;%的行为是相同的。那 么我们为什么推荐基础管道|&gt;呢？首 先，因为它是 R 语言的基础部分，所以你总是可以使用它，即使你没有使用 tidyverse。其 次，|&gt;比%&gt;%简单得多：在%&gt;%于 2014 年被发明和|&gt;于 2021 年在 R 4.1.0 中被引入之间的这段时间里，我们对管道有了更好的理解。这 使得|&gt;能够舍弃那些不常用且不太重要的特性。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据转换</span>"
    ]
  },
  {
    "objectID": "data-transform.html#分组",
    "href": "data-transform.html#分组",
    "title": "3  数据转换",
    "section": "3.5 分组",
    "text": "3.5 分组\n到目前为止，你已经学习了处理行和列的函数。当 你添加了处理分组的能力时，dplyr会变得更加强大。在 本节中，我们将重点关注最重要的函数：group_by()、summarize()和slice函数族。\n\n3.5.1 group_by()\n使用group_by()将数据集划分为对分析有意义的组:\n\nflights |&gt; \n  group_by(month)\n#&gt; # A tibble: 336,776 × 19\n#&gt; # Groups:   month [12]\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\ngroup_by()并不改变数据，但如果你仔细观察输出，你会注意到输出显示它是按月“分组”（Groups: month [12]）。这 意味着后续的操作将“按月”进行。g roup_by()将这个分组特性（称为类）添加到数据框中，从而改变了后续应用于数据的函数的行为。\n\n\n3.5.2 summarize()\n最重要的分组操作是汇总，如果用于计算单个汇总统计量，它将数据框缩减为每个组只有一行。在 dplyr 中，这个操作是通过summarize()3完成的，如下例所示，它计算了每个月的平均离港延误时间：\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(\n    avg_delay = mean(dep_delay)\n  )\n#&gt; # A tibble: 12 × 2\n#&gt;   month avg_delay\n#&gt;   &lt;int&gt;     &lt;dbl&gt;\n#&gt; 1     1        NA\n#&gt; 2     2        NA\n#&gt; 3     3        NA\n#&gt; 4     4        NA\n#&gt; 5     5        NA\n#&gt; 6     6        NA\n#&gt; # ℹ 6 more rows\n\n哎呀！出 错了，我们所有的结果都是 NA（读作“N-A”），这是 R 中缺失值的符号。这 是因为我们观察的一些航班在延误列中有缺失数据，所以当我们将这些值包括在内计算平均值时，我们就得到了一个 NA 结果。我 们将在 章节 18 部分中详细讨论缺失值，但现在我们会告诉mean()函数通过设置na.rm参数为TRUE来忽略所有缺失值：\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE)\n  )\n#&gt; # A tibble: 12 × 2\n#&gt;   month avg_delay\n#&gt;   &lt;int&gt;     &lt;dbl&gt;\n#&gt; 1     1      10.0\n#&gt; 2     2      10.8\n#&gt; 3     3      13.2\n#&gt; 4     4      13.9\n#&gt; 5     5      13.0\n#&gt; 6     6      20.8\n#&gt; # ℹ 6 more rows\n\n你可以在单次调用summarize()时创建任意数量的汇总。在 接下来的章节中，你将学习各种有用的汇总，但其中一个非常有用的摘要是n()，它返回每个组的行数\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    n = n()\n  )\n#&gt; # A tibble: 12 × 3\n#&gt;   month avg_delay     n\n#&gt;   &lt;int&gt;     &lt;dbl&gt; &lt;int&gt;\n#&gt; 1     1      10.0 27004\n#&gt; 2     2      10.8 24951\n#&gt; 3     3      13.2 28834\n#&gt; 4     4      13.9 28330\n#&gt; 5     5      13.0 28796\n#&gt; 6     6      20.8 28243\n#&gt; # ℹ 6 more rows\n\nMeans和counts在数据科学中可以让你走得很远，远到让你吃惊!\n\n\n3.5.3 slice_ 函数族\n有五个函数允许你方便地提取每个组中内特定行:\n\ndf |&gt; slice_head(n = 1) t从每个组中取第一行；\ndf |&gt; slice_tail(n = 1) 从每个组中取最后一行；\ndf |&gt; slice_min(x, n = 1) 取列x值最小的行；\ndf |&gt; slice_max(x, n = 1) 取列x值最大的行；\ndf |&gt; slice_sample(n = 1) 随机取一行。\n\n你可以改变参数n来选择多行，或者代替n=，你可以使用prop = 0.1（例如）来选择每个组的 10% 的行。例 如，以下代码查找每个目的地到达时延误最严重的航班：\n\nflights |&gt; \n  group_by(dest) |&gt; \n  slice_max(arr_delay, n = 1) |&gt;\n  relocate(dest)\n#&gt; # A tibble: 108 × 19\n#&gt; # Groups:   dest [105]\n#&gt;   dest   year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;   &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1 ABQ    2013     7    22     2145           2007        98      132\n#&gt; 2 ACK    2013     7    23     1139            800       219     1250\n#&gt; 3 ALB    2013     1    25      123           2000       323      229\n#&gt; 4 ANC    2013     8    17     1740           1625        75     2042\n#&gt; 5 ATL    2013     7    22     2257            759       898      121\n#&gt; 6 AUS    2013     7    10     2056           1505       351     2347\n#&gt; # ℹ 102 more rows\n#&gt; # ℹ 11 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, …\n\n请注意，虽然有 105 个目的地，但我们这里得到了 108 行，这是怎么回事？s lice_min()和slice_max()会保留并列的值，所以n = 1意味着给我们所有具有最高值的行。如 果你想要每个组正好一行，你可以设置with_ties = FALSE。\n这与使用summarize()计算最大延误类似，但你会得到整个对应的行（如果有并列值，则是多行），而不是单个汇总统计量。\n\n\n3.5.4 按多变量分组\n可以使用多个变量创建分组。例 如，我们可以为每个日期创建一个组。\n\ndaily &lt;- flights |&gt;  \n  group_by(year, month, day)\ndaily\n#&gt; # A tibble: 336,776 × 19\n#&gt; # Groups:   year, month, day [365]\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n当你在使用多个变量对 tibble 进行分组并对其进行汇总时，每个汇总都会去掉最后一个分组。事 后看来，这不是让这个函数工作的好方法，但如果不破坏现有代码就很难改变它。为 了让发生的事情变得显而易见，dplyr 显示了一条消息，告诉你如何改变这种行为：\n\ndaily_flights &lt;- daily |&gt; \n  summarize(n = n())\n#&gt; `summarise()` has grouped output by 'year', 'month'. You can override using\n#&gt; the `.groups` argument.\n\n如果你对这种行为感到满意，你可以明确地要求它以抑制这条消息:\n\ndaily_flights &lt;- daily |&gt; \n  summarize(\n    n = n(), \n    .groups = \"drop_last\"\n  )\n\n或者，通过设置不同的值来改变默认行为，例如，“drop” 删除所有分组，或者 “keep” 保留相同的分组。\n\n\n3.5.5 去消分组\n您可能还希望在不使用summarize()的情况下从数据框中删除分组。您 可以使用ungroup()实现这一点。\n\ndaily |&gt; \n  ungroup()\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n现在让我们看看在汇总未分组的数据框时会发生什么。\n\ndaily |&gt; \n  ungroup() |&gt;\n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    flights = n()\n  )\n#&gt; # A tibble: 1 × 2\n#&gt;   avg_delay flights\n#&gt;       &lt;dbl&gt;   &lt;int&gt;\n#&gt; 1      12.6  336776\n\n返回一行，因为dplyr将未分组数据框中的所有行视为属于一个组。\n\n\n3.5.6 .by\ndplyr 1.1.0 引入了一个新的处于试验阶段的语法，用于每次操作的分组，即.by参数。g roup_by()和ungroup()不会被弃用，但现在你也可以在单个操作中使用.by参数进行分组：\n\nflights |&gt; \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = month\n  )\n\n或者如果你想按多个变量分组：\n\nflights |&gt; \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = c(origin, dest)\n  )\n\n.by与所有动词（函数）兼容，其优势在于你不需要使用.groups参数来抑制分组消息，或在完成后使用ungroup()。\n我们在编写本书时，没有重点关注这种语法，因为它当时非常新。但 我们还是想提一下，因为我们认为它很有前景，并且可能会非常受欢迎。你 可以在 dplyr 1.1.0 的博客中了解更多关于它的信息。\n\n\n3.5.7 练习\n\n哪家航空公司的平均延误时间最长？挑 战：你能理清机场差和航空公司差的影响吗？为 什么能/为什么不能？（ 提示: 考虑使用 flights |&gt; group_by(carrier, dest) |&gt; summarize(n())）\n找出从每个目的地出发延误最严重的航班；\n延误情况在一天中是如何变化的？用 图表来展示你的答案；\n如果你给slice_min()及其相关函数提供负的n值会怎样？\n用你刚刚学习的 dplyr 动词（函数）来解释count()做了什么。c ount()的sort参数有什么作用？\n假设我们有以下的小数据框:\n\ndf &lt;- tibble(\n  x = 1:5,\n  y = c(\"a\", \"b\", \"a\", \"a\", \"b\"),\n  z = c(\"K\", \"K\", \"L\", \"L\", \"K\")\n)\n\n\n写下你认为的输出是什么样子，然后检查是否正确，并描述group_by()的作用。\n\ndf |&gt;\n  group_by(y)\n\n写下你认为的输出是什么样子，然后检查你是否正确，并描述arrange()的作用。同 时评论一下它与（a）部分中的group_by()有什么不同。\n\ndf |&gt;\n  arrange(y)\n\n写下你认为的输出是什么样子，然后检查你是否正确，并描述管道的功能。\n\ndf |&gt;\n  group_by(y) |&gt;\n  summarize(mean_x = mean(x))\n\n写下你认为的输出是什么样子，然后检查你是否正确，并描述管道的功能。然 后对信息内容进行评论。\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  summarize(mean_x = mean(x))\n\n写下你认为的输出是什么样子，然后检查你是否正确，并描述管道的功能。与 (d)部分中的输出有何不同?\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  summarize(mean_x = mean(x), .groups = \"drop\")\n\n写下你认为的输出是什么样子，然后检查你是否正确，并描述每个管道的作用。两 个管道的输出有什么不同?\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  summarize(mean_x = mean(x))\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  mutate(mean_x = mean(x))",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据转换</span>"
    ]
  },
  {
    "objectID": "data-transform.html#sec-sample-size",
    "href": "data-transform.html#sec-sample-size",
    "title": "3  数据转换",
    "section": "3.6 案例研究: 汇总数据和样本量",
    "text": "3.6 案例研究: 汇总数据和样本量\n无论何时进行数据汇总，包含计数（n()）总是一个好主意。这 样可以确保你不是基于很少量的数据来得出结论。我 们将使用Lahman包中的棒球数据来演示这一点。具 体来说，我们将比较球员击球成功（H）的次数与尝试击球（AB）的次数之间的比例：\n\nbatters &lt;- Lahman::Batting |&gt; \n  group_by(playerID) |&gt; \n  summarize(\n    performance = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),\n    n = sum(AB, na.rm = TRUE)\n  )\nbatters\n#&gt; # A tibble: 20,469 × 3\n#&gt;   playerID  performance     n\n#&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 aardsda01      0          4\n#&gt; 2 aaronha01      0.305  12364\n#&gt; 3 aaronto01      0.229    944\n#&gt; 4 aasedo01       0          5\n#&gt; 5 abadan01       0.0952    21\n#&gt; 6 abadfe01       0.111      9\n#&gt; # ℹ 20,463 more rows\n\n当我们绘制击球手的技巧（通过击球率来衡量，即performance）与击球机会的数量（通过击球次数来衡量，即n）之间的关系时，你会看到两种模式：\n\n击球次数较少的球员之间的技巧差异更大。这种图的形状非常典型：每当你绘制平均值（或其他汇总统计量）与组大小时，你会看到随着样本量的增加，变异程度会降低4。\n技巧（performance）与击球机会（n）之间存在正相关关系，因为球队希望给他们的最佳击球手最多的击球机会。\n\n\nbatters |&gt; \n  filter(n &gt; 100) |&gt; \n  ggplot(aes(x = n, y = performance)) +\n  geom_point(alpha = 1 / 10) + \n  geom_smooth(se = FALSE)\n\n\n\n\n\n\n\n\n请注意将ggplot2和dplyr结合使用的便捷模式。你 只需要记住在数据集处理时使用|&gt;，而在向你的图添加图层时使用+。\n这对于排名也有重要的影响。如 果你只是简单地根据desc(performance)进行排序，那么显然击球率最好的人是那些尝试击球次数很少但碰巧击中的人，他们不一定是技术最熟练的球员：\n\nbatters |&gt; \n  arrange(desc(performance))\n#&gt; # A tibble: 20,469 × 3\n#&gt;   playerID  performance     n\n#&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 abramge01           1     1\n#&gt; 2 alberan01           1     1\n#&gt; 3 banisje01           1     1\n#&gt; 4 bartocl01           1     1\n#&gt; 5 bassdo01            1     1\n#&gt; 6 birasst01           1     2\n#&gt; # ℹ 20,463 more rows\n\n关于这个问题及其解决方法，你可以在以下网址找到很好的解释： http://varianceexplained.org/r/empirical_bayes_baseball/ 和 https://www.evanmiller.org/how-not-to-sort-by-average-rating.html.",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据转换</span>"
    ]
  },
  {
    "objectID": "data-transform.html#小结",
    "href": "data-transform.html#小结",
    "title": "3  数据转换",
    "section": "3.7 小结",
    "text": "3.7 小结\n在本章中，你学习了dplyr为处理数据框提供的工具。这 些工具大致分为三类：操作行的工具（如filter()和arrange()），操作列的工具（如select()和mutate()），以及操作组的工具（如group_by()和summarize()）。在 本章中，我们专注于这些“整个数据框”的工具，但你还没有深入了解可以使用单个变量做什么。我 们将在本书的转换部分回到这个问题，其中每一章都将为你提供特定类型变量的工具。\n在下一章中，我们将回到工作流程，讨论代码风格的重要性，保持您的代码组织良好，以便你和他人能够轻松阅读和理解你的代码。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据转换</span>"
    ]
  },
  {
    "objectID": "data-transform.html#footnotes",
    "href": "data-transform.html#footnotes",
    "title": "3  数据转换",
    "section": "",
    "text": "稍后，您将学习slice_*()系列函数，它允许你根据行的位置选择行。↩︎\n在RStudio中，查看包含多列的数据集最简单的方法是View()。↩︎\n如果你喜欢英式英语，也可以用summarise()。↩︎\n大数定律↩︎",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据转换</span>"
    ]
  },
  {
    "objectID": "workflow-style.html",
    "href": "workflow-style.html",
    "title": "4  工作流程: 代码风格",
    "section": "",
    "text": "4.1 名称\n我们在@sec-whats-in-a-name 简要地讨论了名称。请 记住，变量名（通过&lt;-和mutate()创建的）应该只使用小写字母、数字和_。使 用_来分隔名称中的单词。\n# Strive for:\nshort_flights &lt;- flights |&gt; filter(air_time &lt; 60)\n\n# Avoid:\nSHORTFLIGHTS &lt;- flights |&gt; filter(air_time &lt; 60)\n作为一条通用的经验法则，最好选择长而描述性强的名称，这样更容易理解，而不是快速输入的简洁名称。在 编写代码时，短名称节省的时间相对较少（特别是当自动补全功能帮助你完成输入时），但当你回到旧代码并被迫猜测一个晦涩的缩写时，这可能会很耗时。\n如果你有一组与相关事物相关的名称，请尽量保持一致。当 你忘记之前的约定时，不一致性很容易产生，所以如果你必须回去重命名事物，也不要感到难过。一 般来说，如果你有一组变量是某个主题的变体，最好给它们一个共同的前缀而不是共同的后缀，因为自动补全在变量的开头效果最好。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流程: 代码风格</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#空格",
    "href": "workflow-style.html#空格",
    "title": "4  工作流程: 代码风格",
    "section": "4.2 空格",
    "text": "4.2 空格\n在除^以外的数学运算符(即-、==、&lt;、…)以及赋值运算符(&lt;-)的两侧加上空格。\n\n# Strive for\nz &lt;- (a + b)^2 / d\n\n# Avoid\nz&lt;-( a + b ) ^ 2/d\n\n对于常规函数调用，不要在圆括号内或圆括号外放空格。总 是在逗号后面加一个空格，就像在标准英语中一样。\n\n# Strive for\nmean(x, na.rm = TRUE)\n\n# Avoid\nmean (x ,na.rm=TRUE)\n\n如果可以提高对齐效果，可以添加额外的空格。例 如，如果要在mutate()中创建多个变量，则可能需要添加空格，以便所有的=对齐1。 这会使得浏览代码更容易。\n\nflights |&gt; \n  mutate(\n    speed      = distance / air_time,\n    dep_hour   = dep_time %/% 100,\n    dep_minute = dep_time %%  100\n  )",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流程: 代码风格</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#sec-pipes",
    "href": "workflow-style.html#sec-pipes",
    "title": "4  工作流程: 代码风格",
    "section": "4.3 管道",
    "text": "4.3 管道\n|&gt;前面应该始终有一个空格，并且通常应该是行的最后一个元素。这 样做可以更容易地添加新步骤、重新排列现有步骤、修改步骤中的元素，并通过浏览左侧的动词（函数）来获得一个全局视角。\n\n# Strive for \nflights |&gt;  \n  filter(!is.na(arr_delay), !is.na(tailnum)) |&gt; \n  count(dest)\n\n# Avoid\nflights|&gt;filter(!is.na(arr_delay), !is.na(tailnum))|&gt;count(dest)\n\n如果你正在使用管道传递数据的函数具有被命名的参数（如mutate()或summarize()），请将每个参数放在新行上。如 果函数没有命名参数（如select()或filter()），则除非参数过长无法放在一行中，否则将所有内容放在一行上。在 参数过长的情况下，你应该将每个参数放在自己的行上。\n\n# Strive for\nflights |&gt;  \n  group_by(tailnum) |&gt; \n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE),\n    n = n()\n  )\n\n# Avoid\nflights |&gt;\n  group_by(\n    tailnum\n  ) |&gt; \n  summarize(delay = mean(arr_delay, na.rm = TRUE), n = n())\n\n在管道的第一步之后，将每行缩进两个空格。在 |&gt;后面的换行后，RStudio会自动为你添加空格。如 果你将每个参数放在单独的一行上，则再缩进两个空格。确 保)单独放在一行上，并且不缩进，以匹配函数名的水平位置。\n\n# Strive for \nflights |&gt;  \n  group_by(tailnum) |&gt; \n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE),\n    n = n()\n  )\n\n# Avoid\nflights|&gt;\n  group_by(tailnum) |&gt; \n  summarize(\n             delay = mean(arr_delay, na.rm = TRUE), \n             n = n()\n           )\n\n# Avoid\nflights|&gt;\n  group_by(tailnum) |&gt; \n  summarize(\n  delay = mean(arr_delay, na.rm = TRUE), \n  n = n()\n  )\n\n如果你的管道可以很容易地放在一行上，那么忽略一些规则是可以的。但 根据我们的共同经验，简短的代码片段经常会变得更长，所以通常一开始就使用所有你需要的垂直空间会在长远上节省时间。\n\n# This fits compactly on one line\ndf |&gt; mutate(y = x + 1)\n\n# While this takes up 4x as many lines, it's easily extended to \n# more variables and more steps in the future\ndf |&gt; \n  mutate(\n    y = x + 1\n  )\n\n最后，要警惕编写非常长的管道，比如超过10-15行的管道。尝 试将它们分解成更小的子任务，并为每个任务赋予一个信息性强的名称。这 些名称将帮助读者了解正在发生的事情，并更容易地检查中间结果是否符合预期。只 要你能为某个事物赋予一个信息性强的名称，你就应该这样做，例如当你从根本上改变数据的结构时，例如在透视或汇总之后。不 要期望第一次就能做对！这 意味着，如果中间状态可以得到好的名称，就应该拆分长的管道。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流程: 代码风格</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#ggplot2",
    "href": "workflow-style.html#ggplot2",
    "title": "4  工作流程: 代码风格",
    "section": "4.4 ggplot2",
    "text": "4.4 ggplot2\n适用于管道的基本规则也适用于ggplot2，对待+就像对待|&gt;一样。\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE)\n  ) |&gt; \n  ggplot(aes(x = month, y = delay)) +\n  geom_point() + \n  geom_line()\n\n同样，如果你不能将函数的所有参数放在一行中，请将每个参数放在单独的一行中:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(\n    distance = mean(distance),\n    speed = mean(distance / air_time, na.rm = TRUE)\n  ) |&gt; \n  ggplot(aes(x = distance, y = speed)) +\n  geom_smooth(\n    method = \"loess\",\n    span = 0.5,\n    se = FALSE, \n    color = \"white\", \n    linewidth = 4\n  ) +\n  geom_point()\n\n注意从 |&gt; 到 + 的转换。我 们希望这种转换是不必要的，但不幸的是，ggplot2 是在管道发明之前编写的。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流程: 代码风格</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#分段注释",
    "href": "workflow-style.html#分段注释",
    "title": "4  工作流程: 代码风格",
    "section": "4.5 分段注释",
    "text": "4.5 分段注释\n随着你的脚本变长，你可以使用分段注释（sectioning comments）将文件分解成可管理的片段：\n\n# Load data --------------------------------------\n\n# Plot data --------------------------------------\n\nRStudio提供了一个快捷键来创建这些标题(Cmd/Ctrl Shift R)，并将它们显示在编辑器左下角的代码导航下拉菜单中，如 图 4.2 所示。\n\n\n\n\n\n\n\n\n图 4.2: After adding sectioning comments to your script, you can easily navigate to them using the code navigation tool in the bottom-left of the script editor.",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流程: 代码风格</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#练习",
    "href": "workflow-style.html#练习",
    "title": "4  工作流程: 代码风格",
    "section": "4.6 练习",
    "text": "4.6 练习\n\n按照上面的指南重新设计以下管道的样式。\n\nflights|&gt;filter(dest==\"IAH\")|&gt;group_by(year,month,day)|&gt;summarize(n=n(),\ndelay=mean(arr_delay,na.rm=TRUE))|&gt;filter(n&gt;10)\n\nflights|&gt;filter(carrier==\"UA\",dest%in%c(\"IAH\",\"HOU\"),sched_dep_time&gt;\n0900,sched_arr_time&lt;2000)|&gt;group_by(flight)|&gt;summarize(delay=mean(\narr_delay,na.rm=TRUE),cancelled=sum(is.na(arr_delay)),n=n())|&gt;filter(n&gt;10)",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流程: 代码风格</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#小结",
    "href": "workflow-style.html#小结",
    "title": "4  工作流程: 代码风格",
    "section": "4.7 小结",
    "text": "4.7 小结\n在本章中，你学习了代码风格最重要的原则。这 些原则一开始可能感觉像是一套任意的规则（因为它们确实是），但随着时间的推移，当你编写更多的代码并与更多的人分享代码时，你会看到一致的样式是多么重要。别 忘了styler包，它是快速提高样式不佳的代码质量的绝佳方式。\n在下一章中，我们将回到数据科学工具，学习整理数据。整 理数据是一种组织数据框的一致方式，它在tidyverse中得到了广泛应用。这 种一致性让你的生活变得更加容易，因为一旦你有了整洁的数据，它就可以与绝大多数tidyverse函数一起工作。当 然，生活从来都不容易，你在实际中遇到的大多数数据集都不会是整洁的。所 以，我们还将教你如何使用tidyr包来整理你的不整洁的数据。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流程: 代码风格</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#footnotes",
    "href": "workflow-style.html#footnotes",
    "title": "4  工作流程: 代码风格",
    "section": "",
    "text": "由于dep_time是HMM或HHMM格式，因此我们使用整数除法(%/%)来获得小时，使用余数(也称为取模，%%)来获得分钟。↩︎",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流程: 代码风格</span>"
    ]
  },
  {
    "objectID": "data-tidy.html",
    "href": "data-tidy.html",
    "title": "5  数据整齐",
    "section": "",
    "text": "5.1 引言\n在本章中，你将学习一种在R中组织数据的一致方法，即利用一种被称为整齐数据（tidy data）的系统。将 数据整理成这种格式需要一些前期工作，但从长远来看，这些工作是值得的。一 旦你有了整齐的数据和tidyverse包提供的整理工具，你将花费更少的时间将数据从一种表现形式转换为另一种表现形式，从而让你有更多的时间投入到你关心的数据问题上。\n在本章中，你将首先学习整齐数据的定义，并将其应用于一个简单的示例数据集。然 后，我们将深入探讨用于整理数据的主要工具：数据重塑（data pivoting），数据透视允许你改变数据的格式而不改变任何值。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>数据整齐</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#引言",
    "href": "data-tidy.html#引言",
    "title": "5  数据整齐",
    "section": "",
    "text": "“幸福的家庭都是相似的；每个不幸的家庭各有各的不幸。”\n— 列夫·托尔斯泰\n\n\n“整洁的数据集都是相似的，但每个混乱的数据集各有各的混乱方式。”\n— 哈德利·威克汉姆\n\n\n\n\n5.1.1 必要条件\n本章将重点介绍tidyr，它提供了一系列工具来帮助整理混乱的数据集，是tidyverse的一个成员。\n\nlibrary(tidyverse)\n\n从本章开始，我们将阻止library(tidyverse)的加载消息。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>数据整齐</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#sec-tidy-data",
    "href": "data-tidy.html#sec-tidy-data",
    "title": "5  数据整齐",
    "section": "5.2 整齐数据",
    "text": "5.2 整齐数据\n你可以用多种方式表示相同的基础数据。下 面的例子展示了以三种不同的方式组织的同一数据。每 个数据集都显示了四个变量的相同值：国家（country）、年份（year）、人口（population）和记录在案的结核病（tuberculosis，TB）病例数（cases），但每个数据集都以不同的方式组织这些值。\n\ntable1\n#&gt; # A tibble: 6 × 4\n#&gt;   country      year  cases population\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071\n#&gt; 2 Afghanistan  2000   2666   20595360\n#&gt; 3 Brazil       1999  37737  172006362\n#&gt; 4 Brazil       2000  80488  174504898\n#&gt; 5 China        1999 212258 1272915272\n#&gt; 6 China        2000 213766 1280428583\n\ntable2\n#&gt; # A tibble: 12 × 4\n#&gt;   country      year type           count\n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999 cases            745\n#&gt; 2 Afghanistan  1999 population  19987071\n#&gt; 3 Afghanistan  2000 cases           2666\n#&gt; 4 Afghanistan  2000 population  20595360\n#&gt; 5 Brazil       1999 cases          37737\n#&gt; 6 Brazil       1999 population 172006362\n#&gt; # ℹ 6 more rows\n\ntable3\n#&gt; # A tibble: 6 × 3\n#&gt;   country      year rate             \n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;            \n#&gt; 1 Afghanistan  1999 745/19987071     \n#&gt; 2 Afghanistan  2000 2666/20595360    \n#&gt; 3 Brazil       1999 37737/172006362  \n#&gt; 4 Brazil       2000 80488/174504898  \n#&gt; 5 China        1999 212258/1272915272\n#&gt; 6 China        2000 213766/1280428583\n\n它们都表示了同一基础数据，但使用难度并不相同。其 中，table1 在tidyverse中更容易使用，因为它很整齐（tidy）。\n使一个数据集整齐的三个相互关联的规则是：\n\n每个变量都是一列；每一列都是一个变量；\n每个观测值都是一行；每一行都是一个观测值；\n每个值都是一个单元格；每个单元格都是一个单一的值。\n\n图 5.1 直观地展示了这些规则。\n\n\n\n\n\n\n\n\n图 5.1: The following three rules make a dataset tidy: variables are columns, observations are rows, and values are cells.\n\n\n\n\n\n为什么要确保你的数据是整齐的？有 两个主要优势：\n\n选择一种一致的数据存储方式具有普遍优势。如果你的数据结构是一致的，学习与之配合使用的工具就更容易，因为它们具有底层的一致性。\n将变量放在列中具有特定的优势，因为这可以让R的矢量化特性大放异彩。正如你在@sec-mutate 和@sec-summarize 所学到的，大多数内置的R函数都使用值的向量。这使得处理整齐数据感觉特别自然。\n\ndplyr、ggplot2以及tidyverse中的所有其他包都是为处理整齐数据而设计的。下 面代码是一些展示如何使用table1的小示例。\n\n# Compute rate per 10,000\ntable1 |&gt;\n  mutate(rate = cases / population * 10000)\n#&gt; # A tibble: 6 × 5\n#&gt;   country      year  cases population  rate\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071 0.373\n#&gt; 2 Afghanistan  2000   2666   20595360 1.29 \n#&gt; 3 Brazil       1999  37737  172006362 2.19 \n#&gt; 4 Brazil       2000  80488  174504898 4.61 \n#&gt; 5 China        1999 212258 1272915272 1.67 \n#&gt; 6 China        2000 213766 1280428583 1.67\n\n# Compute total cases per year\ntable1 |&gt; \n  group_by(year) |&gt; \n  summarize(total_cases = sum(cases))\n#&gt; # A tibble: 2 × 2\n#&gt;    year total_cases\n#&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1  1999      250740\n#&gt; 2  2000      296920\n\n# Visualize changes over time\nggplot(table1, aes(x = year, y = cases)) +\n  geom_line(aes(group = country), color = \"grey50\") +\n  geom_point(aes(color = country, shape = country)) +\n  scale_x_continuous(breaks = c(1999, 2000)) # x-axis breaks at 1999 and 2000\n\n\n\n\n\n\n\n\n\n5.2.1 练习\n\n对于每个示例表格，描述每个观测值和每列分别代表什么。\n概述你将如何计算table2和table3中的rate。你 需要执行四个操作：\n\n提取每个国家每年的TB病例数；\n提取每个国家每年对应的人口数；\n将病例数除以人口数，然后乘以10000；\n将结果存储回适当的地方.\n\n你还没有学习所有实际执行这些操作所需的函数，但应该仍然能够思考出所需的转换步骤。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>数据整齐</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#sec-pivoting",
    "href": "data-tidy.html#sec-pivoting",
    "title": "5  数据整齐",
    "section": "5.3 数据转换—长格式",
    "text": "5.3 数据转换—长格式\n整齐数据的原则可能看起来如此显而易见，以至于你怀疑是否会遇到不整齐的数据集。然 而，不幸的是，大多数真实数据都是不整齐的。这 主要有两个原因：\n\n数据通常是为了方便除了分析以外的其他目的而组织的。例 如，数据通常以易于数据录入而不是分析的结构来组织。\n大多数人并不熟悉整齐数据的原则，除非你花很多时间处理数据，否则很难自己推导出这些原则。\n\n这意味着大多数实际分析至少需要进行一些整理。首 先要弄清楚基础变量和观测值是什么，有时这很简单，有时你需要咨询最初生成数据的人；接下来，你需要将数据重塑（pivot）为整齐的形式，将变量放在列中，将观测值放在行中。\ntidyr包提供了两个用于数据重塑的函数：pivot_longer()和pivot_wider()。我 们将首先从pivot_longer()开始，因为它是最常见的情况。让 我们深入探讨一些示例。\n\n5.3.1 列名中的数据\nbillboard数据集记录了 2000 年歌曲的 Billboard 排行榜排名:\n\nbillboard\n#&gt; # A tibble: 317 × 79\n#&gt;   artist       track               date.entered   wk1   wk2   wk3   wk4   wk5\n#&gt;   &lt;chr&gt;        &lt;chr&gt;               &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 2 Pac        Baby Don't Cry (Ke… 2000-02-26      87    82    72    77    87\n#&gt; 2 2Ge+her      The Hardest Part O… 2000-09-02      91    87    92    NA    NA\n#&gt; 3 3 Doors Down Kryptonite          2000-04-08      81    70    68    67    66\n#&gt; 4 3 Doors Down Loser               2000-10-21      76    76    72    69    67\n#&gt; 5 504 Boyz     Wobble Wobble       2000-04-15      57    34    25    17    17\n#&gt; 6 98^0         Give Me Just One N… 2000-08-19      51    39    34    26    26\n#&gt; # ℹ 311 more rows\n#&gt; # ℹ 71 more variables: wk6 &lt;dbl&gt;, wk7 &lt;dbl&gt;, wk8 &lt;dbl&gt;, wk9 &lt;dbl&gt;, …\n\n在这个数据集中，每个观测都是一首歌。前 三列（artist、track 和 date.entered）是描述歌曲的变量。然 后有76列（wk1-wk76）描述了歌曲在每周的排名1。 在这里，列名是一个变量（week），而单元格的值是另一个变量（rank）。\n为了整理这个数据，我们使用 pivot_longer():\n\nbillboard |&gt; \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\"\n  )\n#&gt; # A tibble: 24,092 × 5\n#&gt;    artist track                   date.entered week   rank\n#&gt;    &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n#&gt;  1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n#&gt;  2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n#&gt;  3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n#&gt;  4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n#&gt;  5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n#&gt;  6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n#&gt;  7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n#&gt;  8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n#&gt;  9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n#&gt; 10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n#&gt; # ℹ 24,082 more rows\n\n数据之后，有三个关键参数：\n\ncols 指定了哪些列需要进行重塑，即哪些列不是变量。这个参数使用了与select()相同的语法，因此在这里我们可以使用!c(artist, track, date.entered)或者starts_with(\"wk\")。\nnames_to 用于命名列名中存储的变量，我们将其命名为week\nvalues_to 用于命名单元格值中存储的变量，我们将其命名为rank。\n\n请注意，代码中“week”和“rank”被引号括起来，因为这些是我们创建的新变量，在运行pivot_longer()调用时它们还不在数据中。\n现在让我们把注意力转向得到的长数据框。如 果一首歌在前100名中的时间少于76周，会发生什么？以 2 Pac的《Baby Don’t Cry》为例。上 面的输出表明它只在前100名中待了7周，而其余所有周都填充了缺失值。这 些NA并不真正代表未知的观测值，它们是由于数据集的结构而被迫存在的，因此我们可以要求pivot_longer()通过设置values_drop_na = TRUE来删除它们：\n\nbillboard |&gt; \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\",\n    values_drop_na = TRUE\n  )\n#&gt; # A tibble: 5,307 × 5\n#&gt;   artist track                   date.entered week   rank\n#&gt;   &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n#&gt; 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n#&gt; 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n#&gt; 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n#&gt; 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n#&gt; 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n#&gt; # ℹ 5,301 more rows\n\n现在行数大大减少，这表明许多包含NA的行已被删除。\n你也可能会好奇，如果一首歌在前100名中超过76周，会发生什么？从 这些数据中我们无法得知，但你可以猜测数据集会添加额外的列，如wk77、wk78等。\n现在数据已经整齐了，但我们可以通过使用mutate()和readr::parse_number()将week的值从字符串转换为数字，以使未来的计算更加方便。p arse_number()是一个方便的函数，它会从字符串中提取第一个数字，忽略其他所有文本。\n\nbillboard_longer &lt;- billboard |&gt; \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\",\n    values_drop_na = TRUE\n  ) |&gt; \n  mutate(\n    week = parse_number(week)\n  )\nbillboard_longer\n#&gt; # A tibble: 5,307 × 5\n#&gt;   artist track                   date.entered  week  rank\n#&gt;   &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26       1    87\n#&gt; 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26       2    82\n#&gt; 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26       3    72\n#&gt; 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26       4    77\n#&gt; 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26       5    87\n#&gt; 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26       6    94\n#&gt; # ℹ 5,301 more rows\n\n既然我们已经将所有周数放入一个变量，并将所有排名值放入另一个变量，现在可以很好地可视化歌曲排名如何随时间变化。下 面的代码展示了这一点，结果位于@fig-billboard-ranks 。我 们可以看到，很少有歌曲能在前100名中保持超过20周的时间。\n\nbillboard_longer |&gt; \n  ggplot(aes(x = week, y = rank, group = track)) + \n  geom_line(alpha = 0.25) + \n  scale_y_reverse()\n\n\n\n\n\n\n\n图 5.2: A line plot showing how the rank of a song changes over time.\n\n\n\n\n\n\n\n5.3.2 pivoting是如何工作的?\n既然你已经看到了我们如何使用pivoting来重塑我们的数据，让我们花点时间来直观地理解pivoting对数据做了什么。让 我们从一个非常简单的数据集开始，以便更容易地看到发生了什么。假 设我们有三个患者，id分别为A、B和C，对每个患者进行了两次血压测量。我 们使用tribble()来创建这些数据，tribble()是一个易用的函数，这里通过手动构造小型tibble对象：\n\ndf &lt;- tribble(\n  ~id,  ~bp1, ~bp2,\n   \"A\",  100,  120,\n   \"B\",  140,  115,\n   \"C\",  120,  125\n)\n\n我们希望新数据集有三个变量：id（已存在）、measurement（列名）和value（单元格值）。为 了实现这一点，我们需要将df重塑（pivot）为更长的格式：\n\ndf |&gt; \n  pivot_longer(\n    cols = bp1:bp2,\n    names_to = \"measurement\",\n    values_to = \"value\"\n  )\n#&gt; # A tibble: 6 × 3\n#&gt;   id    measurement value\n#&gt;   &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;\n#&gt; 1 A     bp1           100\n#&gt; 2 A     bp2           120\n#&gt; 3 B     bp1           140\n#&gt; 4 B     bp2           115\n#&gt; 5 C     bp1           120\n#&gt; 6 C     bp2           125\n\n重塑是如何工作的？如 果我们按列思考，就会更容易理解。如 图 5.3 所示，在原始数据集中已经是变量的列（如id）的值需要被重复，每个被重塑的列重复一次。\n\n\n\n\n\n\n\n\n图 5.3: Columns that are already variables need to be repeated, once for each column that is pivoted.\n\n\n\n\n\n列名变成新变量的值，新变量的名称由names_to定义，如@fig-pivot-names 所示。它 们需要在原始数据集的每一行中重复一次。\n\n\n\n\n\n\n\n\n图 5.4: The column names of pivoted columns become values in a new column. The values need to be repeated once for each row of the original dataset.\n\n\n\n\n\n单元格值也变成新变量的值，新变量的名称由values_to定义。它 们被逐行地展开。@ fig-pivot-values 展示了这一过程。\n\n\n\n\n\n\n\n\n图 5.5: The number of values is preserved (not repeated), but unwound row-by-row.\n\n\n\n\n\n\n\n5.3.3 列名中包含多个变量\n当列名中融合了多个信息片段而你希望将这些信息分散到独立的新变量中时，情况就会变得更加复杂。这 里以你之前看到的table1等表的源头数据集who2为例：\n\nwho2\n#&gt; # A tibble: 7,240 × 58\n#&gt;   country      year sp_m_014 sp_m_1524 sp_m_2534 sp_m_3544 sp_m_4554\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan  1980       NA        NA        NA        NA        NA\n#&gt; 2 Afghanistan  1981       NA        NA        NA        NA        NA\n#&gt; 3 Afghanistan  1982       NA        NA        NA        NA        NA\n#&gt; 4 Afghanistan  1983       NA        NA        NA        NA        NA\n#&gt; 5 Afghanistan  1984       NA        NA        NA        NA        NA\n#&gt; 6 Afghanistan  1985       NA        NA        NA        NA        NA\n#&gt; # ℹ 7,234 more rows\n#&gt; # ℹ 51 more variables: sp_m_5564 &lt;dbl&gt;, sp_m_65 &lt;dbl&gt;, sp_f_014 &lt;dbl&gt;, …\n\n这个数据集由世界卫生组织收集，记录了关于结核病诊断的信息,其中有两个列已经是变量且易于解读：country和year。接 着是56个像sp_m_014、ep_m_4554和rel_m_3544这样的列。如 果你长时间盯着这些列看就会发现一个规律。每 个列名都由三部分组成，由_分隔。第 一部分sp/rel/ep描述了用于诊断的方法；第二部分m/f是性别（在这个数据集中被编码为二进制变量）；第三部分，014/1524/2534/3544/4554/5564/65是年龄范围（例如，014代表0-14岁）。\n因此，在这种情况下，who2数据集中记录了六条信息：country和year（已经是列）；诊断方法、性别和年龄范围类别（包含在其他列名中），以及该类别中的患者数量（单元格值）。为 了将这六条信息组织到六个单独的列中，我们使用pivot_longer()函数，并为names_to提供一个列名字符串向量，以及为names_sep提供一个指令来将原始变量名分割成片段，并为values_to提供一个列名：\n\nwho2 |&gt; \n  pivot_longer(\n    cols = !(country:year),\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), \n    names_sep = \"_\",\n    values_to = \"count\"\n  )\n#&gt; # A tibble: 405,440 × 6\n#&gt;   country      year diagnosis gender age   count\n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan  1980 sp        m      014      NA\n#&gt; 2 Afghanistan  1980 sp        m      1524     NA\n#&gt; 3 Afghanistan  1980 sp        m      2534     NA\n#&gt; 4 Afghanistan  1980 sp        m      3544     NA\n#&gt; 5 Afghanistan  1980 sp        m      4554     NA\n#&gt; 6 Afghanistan  1980 sp        m      5564     NA\n#&gt; # ℹ 405,434 more rows\n\n除了names_sep之外，你还可以使用names_pattern。当 你在@sec-regular-expressions 学习了正则表达式之后，就可以使用它来从更复杂的命名场景中提取变量。\n从概念上讲，这只是在你之前看到的简单情况上做了微小的变化。@ sec-regular-expressions 展示了基本思想：现在，列名不再只是转换为一个单独的列，而是转换为多个列。你 可以想象这个过程分为两步（首先转换然后分割），但实际上它是在一步中完成的，因为这样更快。\n\n\n\n\n\n\n\n\n图 5.6: Pivoting columns with multiple pieces of information in the names means that each column name now fills in values in multiple output columns.\n\n\n\n\n\n\n\n5.3.4 列标题中的数据和变量名\n接下来更复杂的步骤是当列名包含变量值和变量名的混合时。例 如，以household数据集为例：\n\nhousehold\n#&gt; # A tibble: 5 × 5\n#&gt;   family dob_child1 dob_child2 name_child1 name_child2\n#&gt;    &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;       &lt;chr&gt;      \n#&gt; 1      1 1998-11-26 2000-01-29 Susan       Jose       \n#&gt; 2      2 1996-06-22 NA         Mark        &lt;NA&gt;       \n#&gt; 3      3 2002-07-11 2004-04-05 Sam         Seth       \n#&gt; 4      4 2004-10-10 2009-08-27 Craig       Khai       \n#&gt; 5      5 2000-12-05 2005-02-28 Parker      Gracie\n\n这个数据集包含了五个家庭的数据，每个家庭最多有两个孩子的姓名和出生日期。数 据集中的新挑战是列名包含了两个变量的名称（dob、name）和另一个变量（child，其值为1或2）的值。为 了解决这个问题，我们再次需要向names_to提供一个向量，但这次我们使用特殊的\".value\"哨兵值（sentinel）；这不是变量的名称，而是一个独特的值，它告诉pivot_longer()做一些不同的事情。这 会覆盖通常的values_to参数，使用重塑后的列名的第一个组成部分作为输出中的变量名。\n\nhousehold |&gt; \n  pivot_longer(\n    cols = !family, \n    names_to = c(\".value\", \"child\"), \n    names_sep = \"_\", \n    values_drop_na = TRUE\n  )\n#&gt; # A tibble: 9 × 4\n#&gt;   family child  dob        name \n#&gt;    &lt;int&gt; &lt;chr&gt;  &lt;date&gt;     &lt;chr&gt;\n#&gt; 1      1 child1 1998-11-26 Susan\n#&gt; 2      1 child2 2000-01-29 Jose \n#&gt; 3      2 child1 1996-06-22 Mark \n#&gt; 4      3 child1 2002-07-11 Sam  \n#&gt; 5      3 child2 2004-04-05 Seth \n#&gt; 6      4 child1 2004-10-10 Craig\n#&gt; # ℹ 3 more rows\n\n由于输入数据的格式，必须创建一些明确的缺失变量（例如，对于只有一个孩子的家庭）通过设置values_drop_na = TRUE，我们可以选择忽略这些由于数据不完整而产生的NA值。。\n图 5.7 通过一个更简单的示例说明了基本思想。当 您在names_to中使用\".value\"时，输入中的列名对输出中的值和变量名都有贡献。\n\n\n\n\n\n\n\n\n图 5.7: Pivoting with names_to = c(\".value\", \"num\") splits the column names into two components: the first part determines the output column name (x or y), and the second part determines the value of the num column.",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>数据整齐</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#数据转换宽格式",
    "href": "data-tidy.html#数据转换宽格式",
    "title": "5  数据整齐",
    "section": "5.4 数据转换—宽格式",
    "text": "5.4 数据转换—宽格式\n到目前为止，我们已经使用pivot_longer()函数来解决了一个常见问题，即值最终出现在列名中的情况。接 下来，我们将转置（HA HA，这里是一个双关语，因为pivot在英语中也有“转置”的意思）到pivot_wider()函数，该函数通过增加列和减少行来使数据集变宽，这在一个观测分布在多行时特别有用。这 种情况在实际数据中较少出现，但在处理政府数据时似乎很常见。\n我们将首先查看cms_patient_experience数据集，这是一个来自医疗保险和医疗补助服务中心（Centers of Medicare and Medicaid Services）的数据集，该数据集收集了关于患者体验的数据：\n\ncms_patient_experience\n#&gt; # A tibble: 500 × 5\n#&gt;   org_pac_id org_nm                     measure_cd   measure_title   prf_rate\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                      &lt;chr&gt;        &lt;chr&gt;              &lt;dbl&gt;\n#&gt; 1 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_1  CAHPS for MIPS…       63\n#&gt; 2 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_2  CAHPS for MIPS…       87\n#&gt; 3 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_3  CAHPS for MIPS…       86\n#&gt; 4 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_5  CAHPS for MIPS…       57\n#&gt; 5 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_8  CAHPS for MIPS…       85\n#&gt; 6 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_12 CAHPS for MIPS…       24\n#&gt; # ℹ 494 more rows\n\n被研究的核心单位是组织，但每个组织都分布在六行中，每行代表调查组织中的一个测量值。我 们可以通过使用distinct()函数来查看measure_cd和measure_title值的完整集。\n\ncms_patient_experience |&gt; \n  distinct(measure_cd, measure_title)\n#&gt; # A tibble: 6 × 2\n#&gt;   measure_cd   measure_title                                                 \n#&gt;   &lt;chr&gt;        &lt;chr&gt;                                                         \n#&gt; 1 CAHPS_GRP_1  CAHPS for MIPS SSM: Getting Timely Care, Appointments, and In…\n#&gt; 2 CAHPS_GRP_2  CAHPS for MIPS SSM: How Well Providers Communicate            \n#&gt; 3 CAHPS_GRP_3  CAHPS for MIPS SSM: Patient's Rating of Provider              \n#&gt; 4 CAHPS_GRP_5  CAHPS for MIPS SSM: Health Promotion and Education            \n#&gt; 5 CAHPS_GRP_8  CAHPS for MIPS SSM: Courteous and Helpful Office Staff        \n#&gt; 6 CAHPS_GRP_12 CAHPS for MIPS SSM: Stewardship of Patient Resources\n\n这两列都不会成为特别好的变量名：measure_cd没有暗示变量的含义，而measure_title是一个包含空格的长句子。目 前我们将使用measure_cd作为新列名的来源，但在实际分析中，你可能希望创建既简短又有意义的变量名。\npivot_wider()与pivot_longer()的操作正好相反。它 不需要定义新的列名，而是选择一个现有列来提供值（values_from），并选择另一个列来定义新的列名（names_from）。\n\ncms_patient_experience |&gt; \n  pivot_wider(\n    names_from = measure_cd,\n    values_from = prf_rate\n  )\n#&gt; # A tibble: 500 × 9\n#&gt;   org_pac_id org_nm                   measure_title   CAHPS_GRP_1 CAHPS_GRP_2\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                    &lt;chr&gt;                 &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          63          NA\n#&gt; 2 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          87\n#&gt; 3 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          NA\n#&gt; 4 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          NA\n#&gt; 5 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          NA\n#&gt; 6 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          NA\n#&gt; # ℹ 494 more rows\n#&gt; # ℹ 4 more variables: CAHPS_GRP_3 &lt;dbl&gt;, CAHPS_GRP_5 &lt;dbl&gt;, …\n\n输出的结果看起来不太对，因为似乎每个组织仍然有多行数据。这 是因为我们还需告诉pivot_wider()哪个列或哪些列的值能够唯一地标识每一行；在这个例子中，这些是以 \"org\" 开头的变量。\n\ncms_patient_experience |&gt; \n  pivot_wider(\n    id_cols = starts_with(\"org\"),\n    names_from = measure_cd,\n    values_from = prf_rate\n  )\n#&gt; # A tibble: 95 × 8\n#&gt;   org_pac_id org_nm           CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3 CAHPS_GRP_5\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                  &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1 0446157747 USC CARE MEDICA…          63          87          86          57\n#&gt; 2 0446162697 ASSOCIATION OF …          59          85          83          63\n#&gt; 3 0547164295 BEAVER MEDICAL …          49          NA          75          44\n#&gt; 4 0749333730 CAPE PHYSICIANS…          67          84          85          65\n#&gt; 5 0840104360 ALLIANCE PHYSIC…          66          87          87          64\n#&gt; 6 0840109864 REX HOSPITAL INC          73          87          84          67\n#&gt; # ℹ 89 more rows\n#&gt; # ℹ 2 more variables: CAHPS_GRP_8 &lt;dbl&gt;, CAHPS_GRP_12 &lt;dbl&gt;\n\n这就给出了我们想要的输出。\n\n5.4.1 pivot_wider()是如何工作的？\n为了理解pivot_wider()是如何工作的，让我们再次从一个非常简单的数据集开始。这 次我们有两个患者，id分别为A和B，我们在患者A上进行了三次血压测量，在患者B上进行了两次测量：\n\ndf &lt;- tribble(\n  ~id, ~measurement, ~value,\n  \"A\",        \"bp1\",    100,\n  \"B\",        \"bp1\",    140,\n  \"B\",        \"bp2\",    115, \n  \"A\",        \"bp2\",    120,\n  \"A\",        \"bp3\",    105\n)\n\n我们将从value列中获取值，从measurement列中获取名称:\n\ndf |&gt; \n  pivot_wider(\n    names_from = measurement,\n    values_from = value\n  )\n#&gt; # A tibble: 2 × 4\n#&gt;   id      bp1   bp2   bp3\n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 A       100   120   105\n#&gt; 2 B       140   115    NA\n\n要开始这个过程，pivot_wider()首先需要弄清楚行和列中的内容。新 的列名将是measurement的唯一值。\n\ndf |&gt; \n  distinct(measurement) |&gt; \n  pull()\n#&gt; [1] \"bp1\" \"bp2\" \"bp3\"\n\n默认情况下，输出中的行由不包含在新名称或值中的所有变量决定。这 些被称为id_cols。这 里只有一列，但通常可以是任意数量的列。\n\ndf |&gt; \n  select(-measurement, -value) |&gt; \n  distinct()\n#&gt; # A tibble: 2 × 1\n#&gt;   id   \n#&gt;   &lt;chr&gt;\n#&gt; 1 A    \n#&gt; 2 B\n\n然后pivot_wider()将这些结果组合起来生成一个空数据框:\n\ndf |&gt; \n  select(-measurement, -value) |&gt; \n  distinct() |&gt; \n  mutate(x = NA, y = NA, z = NA)\n#&gt; # A tibble: 2 × 4\n#&gt;   id    x     y     z    \n#&gt;   &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt;\n#&gt; 1 A     NA    NA    NA   \n#&gt; 2 B     NA    NA    NA\n\n然后，它使用输入中的数据填充所有缺失的值。在 这个例子中，输出中的每个单元格在输入中并非都有对应的值，因为患者B没有第三次血压测量，所以那个单元格的值是缺失的。我 们将在 章节 18 中探讨pivot_wider()可以“制造”缺失值这个观点。\n你可能还会想，如果输入中有多个行对应于输出中的一个单元格会发生什么。下 面的例子中有两行对应于id为“A”和measurement为“bp1”的单元格：\n\ndf &lt;- tribble(\n  ~id, ~measurement, ~value,\n  \"A\",        \"bp1\",    100,\n  \"A\",        \"bp1\",    102,\n  \"A\",        \"bp2\",    120,\n  \"B\",        \"bp1\",    140, \n  \"B\",        \"bp2\",    115\n)\n\n如果我们尝试对这样的数据集进行重塑，会得到一个包含列表-列的输出，你将在 章节 23 中学习更多关于列表-列的内容：\n\ndf |&gt;\n  pivot_wider(\n    names_from = measurement,\n    values_from = value\n  )\n#&gt; Warning: Values from `value` are not uniquely identified; output will contain\n#&gt; list-cols.\n#&gt; • Use `values_fn = list` to suppress this warning.\n#&gt; • Use `values_fn = {summary_fun}` to summarise duplicates.\n#&gt; • Use the following dplyr code to identify duplicates.\n#&gt;   {data} |&gt;\n#&gt;   dplyr::summarise(n = dplyr::n(), .by = c(id, measurement)) |&gt;\n#&gt;   dplyr::filter(n &gt; 1L)\n#&gt; # A tibble: 2 × 3\n#&gt;   id    bp1       bp2      \n#&gt;   &lt;chr&gt; &lt;list&gt;    &lt;list&gt;   \n#&gt; 1 A     &lt;dbl [2]&gt; &lt;dbl [1]&gt;\n#&gt; 2 B     &lt;dbl [1]&gt; &lt;dbl [1]&gt;\n\n由于你还不知道如何处理这类数据，因此需要遵循警告中的提示来找出问题所在:\n\ndf |&gt; \n  group_by(id, measurement) |&gt; \n  summarize(n = n(), .groups = \"drop\") |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 1 × 3\n#&gt;   id    measurement     n\n#&gt;   &lt;chr&gt; &lt;chr&gt;       &lt;int&gt;\n#&gt; 1 A     bp1             2\n\n接下来你需要找出你的数据出了什么问题，然后修复潜在的损坏，或者使用你的分组和汇总技能来确保每个行和列值的组合都只有一行。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>数据整齐</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#小结",
    "href": "data-tidy.html#小结",
    "title": "5  数据整齐",
    "section": "5.5 小结",
    "text": "5.5 小结\n在本章中，你学习了整整齐数据：将数据变量放在列中，观测放在行中。整 齐数据使得在tidyverse环境中工作更加容易，因为它是一种被大多数函数所理解的统一结构。主 要的挑战是将你从任何结构中接收到的数据转换为整齐格式。为 此，你学习了pivot_longer()和pivot_wider()函数，它们允许你整理许多不整齐的数据集。我 们在这里给出的例子是从vignette(\"pivot\", package = \"tidyr\")中挑选出来的，因此如果你遇到本章没有帮助你解决的问题，那么vignette是一个进行尝试的好地方。\n另一个挑战是，对于给定的数据集，可能无法将更长或更宽的版本标记为“整齐”的，这在一定程度上反映了我们对整洁数据的定义。我 们说整齐数据在每列中都有一个变量，但我们实际上并没有定义什么是变量（而且实际上很难这样做）。务 实地说，变量就是使你的分析最容易进行的任何东西。因 此，如果你正在为如何进行某些计算而苦恼，请考虑更改你的数据组织方式；不要害怕在需要时取消整齐化、转换和重新整齐化！\n如果你喜欢这一章并想了解更多底层理论，你可以学习发表在《Journal of Statistical Software》上的Tidy Data 论文中的历史和理论基础。\n现在你已经编写了大量的R代码，是时候学习如何将你的代码组织到文件和目录中了。在 下一章中，你将了解脚本和项目的所有优势，以及它们提供的一些工具，这些工具将使你的生活更加轻松。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>数据整齐</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#footnotes",
    "href": "data-tidy.html#footnotes",
    "title": "5  数据整齐",
    "section": "",
    "text": "只要这首歌在2000年的某个时间点进入排行榜前100名，它就会被收录，并在它出现后的72周内被追踪。↩︎",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>数据整齐</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html",
    "href": "workflow-scripts.html",
    "title": "6  工作流程: 脚本和项目",
    "section": "",
    "text": "6.1 脚本\n到目前为止，你已经使用控制台来运行代码。这 是一个很好的起点，但是当你创建更复杂的ggplot2图形和更长的dplyr管道时，您会发现控制台空间很快就变得不够用了。为 了给自己更多的工作空间，请使用脚本编辑器。通 过点击“文件”菜单，选择“新建文件”，然后选择“R脚本”，或者使用键盘快捷键Cmd/Ctrl + Shift + N来打开它。你 会看到四个窗格，如 图 6.1 所示。脚 本编辑器是测试代码的好地方。当 你想要更改某些内容时，不再需要重新输入整个代码，只需编辑脚本并重新运行它。而 且，一旦编写好了符合你需求的代码，可以将其保存为脚本文件，以便以后轻松返回。\n图 6.1: Opening the script editor adds a new pane at the top-left of the IDE.",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>工作流程: 脚本和项目</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#脚本",
    "href": "workflow-scripts.html#脚本",
    "title": "6  工作流程: 脚本和项目",
    "section": "",
    "text": "6.1.1 运行代码\n脚本编辑器是构建复杂的ggplot2图形或长序列的dplyr操作的好地方。有 效使用脚本编辑器的关键是记住一个最重要的键盘快捷键：Cmd/Ctrl + Enter。这 个快捷键可以在控制台中执行当前的R表达式。例 如，请看下面的代码。\n\nlibrary(dplyr)\nlibrary(nycflights13)\n\nnot_cancelled &lt;- flights |&gt; \n  filter(!is.na(dep_delay)█, !is.na(arr_delay))\n\nnot_cancelled |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(mean = mean(dep_delay))\n\n如果你的光标位于█处，按下Cmd/Ctrl + Enter将运行生成not_cancelled的完整命令。同 时，光标也会移动到下一个语句（以not_cancelled |&gt;开头）。这 使得通过反复按下Cmd/Ctrl + Enter来逐步执行整个脚本变得很容易。\n与其逐个表达式地运行代码，还可以使用Cmd/Ctrl + Shift + S一次性执行完整的脚本。定 期这样做是保证你捕获了脚本中代码所有重要部分的好方法。\n我们建议你始终在脚本开头列出所需的包。这 样，如果与他人共享代码，他们可以轻松地看到他们需要安装哪些包。但 是，请注意，不要在共享的脚本中包含install.packages()。如 果不小心将一个会更改计算机的脚本交给他们是欠考虑的！\n在学习后续章节时，我们强烈推荐从脚本编辑器开始并练习您的键盘快捷键。随 着时间的推移，以这种方式将代码发送到控制台会变得如此自然，甚至不用去考虑。\n\n\n6.1.2 RStudio 诊断\n在脚本编辑器中，RStudio会在侧边栏中用一条红色弯弯曲曲的线和一个叉来突出显示语法错误。\n\n\n\n\n\n\n\n\n\n将鼠标悬停在十字上，看看问题是什么：\n\n\n\n\n\n\n\n\n\nRStudio 还会让您了解潜在的问题：\n\n\n\n\n\n\n\n\n\n\n\n6.1.3 文件保存和命名\nRStudio 在你退出时会自动保存脚本编辑器的内容，并在重新打开时自动加载它。然 而，最好不要使用“Untitled1”，“Untitled2”，“Untitled3”等命名方式，而是应该保存您的脚本并给它们起一个有意义的名字。\n可能你会想用code.R或myscript.R来命名文件，但在选择文件名之前应该多考虑一下。文 件命名的三个重要原则是：\n\n文件名应该是机器可读的：避免空格、符号和特殊字符，不要依赖大小写来区分文件。\n文件名应该是人类可读的：使用文件名来描述文件中的内容。\n文件名应该与默认排序方式兼容：以数字开头命名文件，以便按字母顺序排序时，它们能按照使用的顺序排列。\n\n例如，假设您在一个项目文件夹中有以下文件：\nalternative model.R\ncode for exploratory analysis.r\nfinalreport.qmd\nFinalReport.qmd\nfig 1.png\nFigure_02.png\nmodel_first_try.R\nrun-first.r\ntemp.txt\n这里存在几个问题：很难确定先运行哪个文件；文件名包含空格；有两个名称相同但大小写不同的文件（finalreport 与 FinalReport1），并且一些名称没有描述其内容（run-first 和 temp）。\n下面是一种更好的命名和组织同一组文件的方法:\n01-load-data.R\n02-exploratory-analysis.R\n03-model-approach-1.R\n04-model-approach-2.R\nfig-01.png\nfig-02.png\nreport-2022-03-20.qmd\nreport-2022-04-02.qmd\nreport-draft-notes.txt\n对关键脚本进行编号可以明确它们的运行顺序，而一致的命名方案可以更容易地看出发生了什么变化。此 外，图表的标签也类似；报告通过文件名中包含的日期进行区分，而temp被重命名为report-draft-notes以更好地描述其内容。如 果您在目录中有大量文件，建议进一步组织文件，将不同类型的文件（脚本、图表等）放在不同的目录中。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>工作流程: 脚本和项目</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#项目",
    "href": "workflow-scripts.html#项目",
    "title": "6  工作流程: 脚本和项目",
    "section": "6.2 项目",
    "text": "6.2 项目\n有时，你可能需要退出R去做其他的事情，稍后再回到分析任务中；有时，你会同时处理多个任务，并且希望将它们分开。有 时，你需要将外部世界的数据带入R，并将R中的数值结果和图表发送回外部世界。\n为了处理这些实际情况，你需要做出两个决定：\n\n什么是真相的来源？你会保存什么作为发生的事情的永久记录？\n你的分析在哪里进行？\n\n\n6.2.1 什么是真相的来源？\n作为初学者，依靠当前环境（Environment ）包含分析过程中创建的所有对象是无可厚非的。但 是，为了更容易地进行大型项目或与他人合作，R脚本应该成为事实真相的来源，你可以通过R脚本（和数据文件）重新创建环境。如 果只有自己的环境，则很难重新创建R脚本：你要么必须从记忆中重新键入大量代码（在此过程中不可避免地会犯错误），要么必须仔细挖掘您的R历史记录。\n为了帮助保持R脚本作为你分析的真相来源，我们强烈建议你不要让RStudio在会话之间保留您的工作空间（workspace）。您 可以通过运行usethis::use_blank_slate()2或模仿 图 6.2 中所示的选项来实现。 这将会给您带来一些短期的痛苦，因为现在当您重新启动RStudio时，它将不再记住您上次运行的代码，您创建的对象或读取的数据集也将无法使用。 但是这种短期的痛苦可以避免长期的痛苦，因为它迫使你在代码中捕获所有重要的过程。 没有什么比在事实发生三个月后发现你只在环境中存储了重要计算的结果，而没有在代码中存储计算更糟糕的了。\n\n\n\n\n\n\n\n\n图 6.2: Copy these options in your RStudio options to always start your RStudio session with a clean slate.\n\n\n\n\n\n有一组非常实用的键盘快捷键组合，它们将协同工作以确保你已经在编辑器中捕获了代码的重要部分：\n\n按Cmd/Ctrl + Shift + 0/F10来重启R。\n按Cmd/Ctrl + Shift + S来重新运行当前脚本。\n\n我们每周都会使用这种模式数百次。\n或者，如果不使用快捷键，你可以转到“会话”&gt;“重启R”，然后选中并重新运行当前脚本。\n\n\n\n\n\n\nRStudio server\n\n\n\n如果您使用的是RStudio server，默认情况下R会话不会自动重启。当 你关闭RStudio server标签页时，可能会感觉正在关闭R，但实际上服务器会在后台保持其运行状态。下 次你返回时，你将处于和离开时完全相同的位置。这 使得定期重启R变得尤为重要，以便你是从一个干净状态开始的。\n\n\n\n\n6.2.2 分析在哪里进行?\n工作目录是R中非常重要的概念。R 在这个目录中查找你想要加载的文件，也将要保存的文件存放在这里。R Studio在控制台顶部显示当前的工作目录：\n\n\n\n\n\n\n\n\n\n可以通过运行getwd()函数在R代码中输出当前的工作目录:\n\ngetwd()\n#&gt; [1] \"/Users/hadley/Documents/r4ds\"\n\n本次R会话中，当前工作目录（可以将其视为“主目录”）位于Hadley的Documents文件夹中一个名为r4ds的子文件夹中。当 您运行此代码时，它将返回不同的结果，因为你的计算机的目录结构与Hadley的不同！\n作为R的初学者，让工作目录成为你的主目录、文档目录或者计算机上的任何其他奇怪的目录都是可以的。但 是，你已经阅读了本书中的多个章节，不再是初学者了。现 在，你应该开始将项目组织到目录中，并在处理项目时将R的工作目录设置为相关目录。\n你可以在R内部设置工作目录，但不推荐这样做：\n\nsetwd(\"/path/to/my/CoolProject\")\n\n有一种更好的方法，这种方法也能让您像专家一样管理R工作。那 就是使用RStudio项目。\n\n\n6.2.3 RStudio项目\n将所有与某个项目相关的文件（输入数据、R脚本、分析结果和图表）保存在一个目录中是一种明智且常见的做法，RStudio通过项目提供了内置支持。让 我们为您创建一个项目，以便您在使用本书的其余部分时可以使用它。点 击“文件”&gt;“新建项目”，然后按照@fig-new-project 中显示的步骤操作。\n\n\n\n\n\n\n\n\n图 6.3: To create new project: (top) first click New Directory, then (middle) click New Project, then (bottom) fill in the directory (project) name, choose a good subdirectory for its home and click Create Project.\n\n\n\n\n\n将你的项目命名为r4ds，并仔细考虑将其放在哪个子目录中。如 果不将其存储在一个合理的地方，将来会很难找到它！\n一旦完成此过程，你将获得一个专为此书创建的新RStudio项目。请 检查项目的“主目录”是否已设置为当前工作目录：\n\ngetwd()\n#&gt; [1] /Users/hadley/Documents/r4ds\n\n现在，在脚本编辑器中输入以下命令并将文件保存为“diamonds.R”。然 后，创建一个名为“data”的新文件夹。你 可以通过在RStudio的“文件”面板中点击“新建文件夹”按钮来完成此操作。最 后，运行完整的脚本，它将把PNG和CSV文件保存到您的项目目录中。不 用关注细节，你将在本书的后续中学习它们。\n\nlibrary(tidyverse)\n\nggplot(diamonds, aes(x = carat, y = price)) + \n  geom_hex()\nggsave(\"diamonds.png\")\n\nwrite_csv(diamonds, \"data/diamonds.csv\")\n\n退出RStudio。检 查与你的项目关联的文件夹——注意.Rproj文件。双 击该文件以重新打开项目。请 注意，你回到了离开时的位置：工作目录和命令历史与原来相同，你正在处理的所有文件仍然打开。但 是，由于遵循了上面的说明，你将拥有一个全新的环境，确保你是从一个干净的状态开始的。\n根据操作系统的不同，选择你最喜欢的方式在计算机上搜索diamonds.png。你 会找到PNG文件（这并不奇怪），还会找到创建它的脚本文件diamonds.R。这 是一个巨大的胜利！有 一天，你可能会想要重新生成一个图形或只是了解它的来源。如 果你严格地使用R代码将图形保存到文件中而从不使用鼠标或剪贴板，那么你将能够轻松地重复以前的工作！\n\n\n6.2.4 相对和绝对路径\n一旦进入一个项目，你应该只使用相对路径而不是绝对路径。有 什么区别呢？相 对路径是相对于工作目录的，即项目的根目录。当 Hadley在上面写data/diamonds.csv时，它是/Users/hadley/Documents/r4ds/data/diamonds.csv的快捷方式。但 如果Mine在她的计算机上运行这段代码，它将指向/Users/Mine/Documents/r4ds/data/diamonds.csv。这 就是为什么相对路径很重要：无论R项目文件夹最终位于何处，它们都能正常工作。\n绝对路径是指向同一个位置，与你的工作目录无关。根 据操作系统不同，它们看上去会有所不同。在 Windows上，它们以驱动器字母（例如，C:）或两个反斜杠（例如，\\\\servername）开头，而在Mac/Linux上，它们以斜杠“/”开头（例如，/users/hadley）。你 不应该在脚本中使用绝对路径，因为它们会妨碍共享：没有人会拥有与你完全相同的目录配置。\n操作系统之间还有一个重要的区别：如何分隔路径的各个部分。M ac和Linux使用斜杠（例如，data/diamonds.csv），而Windows使用反斜杠（例如，data\\diamonds.csv）。R 可以与这两种类型一起工作（无论你当前使用什么平台），但不幸的是，反斜杠在R中有特殊含义，要在路径中获得单个反斜杠，您需要键入两个反斜杠！这 会使生活变得令人沮丧，因此我们建议使用Linux/Mac风格的斜杠。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>工作流程: 脚本和项目</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#练习",
    "href": "workflow-scripts.html#练习",
    "title": "6  工作流程: 脚本和项目",
    "section": "6.3 练习",
    "text": "6.3 练习\n\n登录RStudio Tips Twitter账户 https://twitter.com/rstudiotips，找到一个有趣的技巧，练习使用它！\nRStudio诊断还会报告哪些常见错误？阅 读 https://support.posit.co/hc/en-us/articles/205753617-Code-Diagnostics 找到答案。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>工作流程: 脚本和项目</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#小结",
    "href": "workflow-scripts.html#小结",
    "title": "6  工作流程: 脚本和项目",
    "section": "6.4 小结",
    "text": "6.4 小结\n在本章中，你学习了如何在脚本（文件）和项目（目录）中组织代码。就 像代码风格一样，这在一开始可能会感觉像是在做无用功。但 是，随着你在多个项目中积累更多的代码，你会开始认识到前期的一点组织工作可以为你节省大量的时间。\n总的来说，脚本和项目为你提供了一个坚实的工作流程，这会在未来很好地为你服务：\n\n为每个数据分析项目创建一个RStudio项目；\n在项目中保存你的脚本（起一个带有信息的名字），编辑它们，分部分或整体运行它们；经常重新启动R以确保你已将所有内容捕获到脚本中。\n永远只使用相对路径，而不是绝对路径。\n\n然后，你需要的所有内容都存放于一个地方，并且与您正在处理的所有其他项目干净地分隔开。\n到目前为止，我们一直在使用R包中包含的数据集。这 使得在预先准备的数据上进行一些实践变得更容易，但显然你的数据不会以这种方式提供。因 此，在下一章中将学习如何使用readr包将数据从磁盘加载到R会话中。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>工作流程: 脚本和项目</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#footnotes",
    "href": "workflow-scripts.html#footnotes",
    "title": "6  工作流程: 脚本和项目",
    "section": "",
    "text": "如果你在名字中使用“final”更是在冒险😆；漫画《Piled Higher and Deeper》中有一个关于此话题的有趣连载。↩︎\n如果没有安装usethis，可以使用install.packages(\"usethis\")安装。↩︎",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>工作流程: 脚本和项目</span>"
    ]
  },
  {
    "objectID": "data-import.html",
    "href": "data-import.html",
    "title": "7  数据导入",
    "section": "",
    "text": "7.1 引言\n使用R包提供的数据来学习数据科学工具是一个很好的方法，但总有一天你会想将所学应用于自己的数据。在 本章中，你将学习将数据文件读入R的基础知识。\n具体来说，本章将重点关注读取纯文本矩形文件。我 们将从处理列名、类型和缺失数据的实用建议开始。然 后，学习如何一次从多个文件中读取数据，以及如何将R中的数据写入文件。最 后，学习如何在R中手动创建数据框。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "data-import.html#引言",
    "href": "data-import.html#引言",
    "title": "7  数据导入",
    "section": "",
    "text": "7.1.1 必要条件\n在本章中，你将学习如何使用readr包在R中加载平面文件，readr包是核心包tidyverse的一部分。\n\nlibrary(tidyverse)",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "data-import.html#从文件读取数据",
    "href": "data-import.html#从文件读取数据",
    "title": "7  数据导入",
    "section": "7.2 从文件读取数据",
    "text": "7.2 从文件读取数据\n首先，我们将关注最常见的矩形数据文件类型：CSV（Comma-Separated Values的缩写）。下 面是一个简单的CSV文件，第一行通常被称为标题行，给出了列名，接下来的六行提供了数据，列之间由逗号分隔，也称为定界符。\n\nStudent ID,Full Name,favourite.food,mealPlan,AGE\n1,Sunil Huffmann,Strawberry yoghurt,Lunch only,4\n2,Barclay Lynn,French fries,Lunch only,5\n3,Jayendra Lyne,N/A,Breakfast and lunch,7\n4,Leon Rossini,Anchovies,Lunch only,\n5,Chidiegwu Dunkel,Pizza,Breakfast and lunch,five\n6,Güvenç Attila,Ice cream,Lunch only,6\n\n表 7.1 以表格形式呈现了相同的数据。\n\n\n\n\n表 7.1: Data from the students.csv file as a table.\n\n\n\n\n\n\n\n\n\n\n\n\n\nStudent ID\nFull Name\nfavourite.food\nmealPlan\nAGE\n\n\n\n\n1\nSunil Huffmann\nStrawberry yoghurt\nLunch only\n4\n\n\n2\nBarclay Lynn\nFrench fries\nLunch only\n5\n\n\n3\nJayendra Lyne\nN/A\nBreakfast and lunch\n7\n\n\n4\nLeon Rossini\nAnchovies\nLunch only\nNA\n\n\n5\nChidiegwu Dunkel\nPizza\nBreakfast and lunch\nfive\n\n\n6\nGüvenç Attila\nIce cream\nLunch only\n6\n\n\n\n\n\n\n\n\n我们使用read_csv()将这个文件读入R。第 一个参数是最重要的：文件路径。可 以将路径视为文件的地址，文件名为students.csv，它位于data文件夹中。\n\nstudents &lt;- read_csv(\"data/students.csv\")\n#&gt; Rows: 6 Columns: 5\n#&gt; ── Column specification ─────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; chr (4): Full Name, favourite.food, mealPlan, AGE\n#&gt; dbl (1): Student ID\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n上面的代码在你的项目中存在名为 data 的文件夹并且其中包含 students.csv 文件时有效。您 可以从https://pos.it/r4ds-students-csv下载 students.csv 文件，或者可以直接从该URL读取它，使用如下方式：\n\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\")\n\n当你运行read_csv()时，它会输出一条消息，告诉你数据的行数和列数、所使用的分隔符以及列规范（按列中数据类型组织的列名）。它 还会输出关于如何检索完整列规范和如何静默此消息的一些信息。这 条消息是readr包的一个组成部分，我们将在 小节 7.3 中再次讨论它。\n\n7.2.1 实用建议\n一旦你读取了数据，第一步通常是以某种方式转换它，以使其在剩余的分析中更容易处理。让 我们带着这个想法再次查看students数据。\n\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 Güvenç Attila    Ice cream          Lunch only          6\n\n在favourite.food列中有一堆食品项目，然后是字符串N/A，它应该是一个 R 会识别为“不可用”的真正的NA值。这 是我们可以通过na参数来解决的问题。默 认情况下，read_csv()只将此数据集中的空字符串(\"\") 识别为 NAs，我们希望它也能识别字符串\"N/A\"。\n\nstudents &lt;- read_csv(\"data/students.csv\", na = c(\"N/A\", \"\"))\n\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 Güvenç Attila    Ice cream          Lunch only          6\n\n你可能还注意到，Student ID和Full Name列使用了反引号。这 是因为它们包含空格，违反了 R 中变量名的常规规则，它们是非语法（non-syntactic）名称。要 引用这些变量，你需要使用反引号`将它们括起来。\n\nstudents |&gt; \n  rename(\n    student_id = `Student ID`,\n    full_name = `Full Name`\n  )\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite.food     mealPlan            AGE  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n\n另一种方法是使用janitor::clean_names()函数，该函数使用一些启发式方法一次性将它们全部转换为蛇形命名法（snake case）1。\n\nstudents |&gt; janitor::clean_names()\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n\n读取数据后的另一个常见任务是考虑变量类型。例 如，meal_plan是一个分类变量，具有一组已知的可能值，在 R 中应该表示为因子：\n\nstudents |&gt;\n  janitor::clean_names() |&gt;\n  mutate(meal_plan = factor(meal_plan))\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n\n请注意，meal_plan变量中的值保持不变，但变量名下方表示的变量类型已经从字符型（&lt;chr&gt;）变为了因子型（&lt;fct&gt;）。你 将在 章节 16 中了解更多关于因子的内容。\n在分析这些数据之前，你可能想要修复age和id列。目 前，age是一个字符型变量，因为其中一个观测值被输入为文本five而不是数字5。我 们将在 章节 20 详细讨论如何修复这个问题。\n\nstudents &lt;- students |&gt;\n  janitor::clean_names() |&gt;\n  mutate(\n    meal_plan = factor(meal_plan),\n    age = parse_number(if_else(age == \"five\", \"5\", age))\n  )\n\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\n\n这里有一个新的函数if_else()，它有三个参数。第 一个参数test应该是一个逻辑向量。当 test为TRUE时，结果将包含第二个参数yes的值；当它为FALSE时，将包含第三个参数no的值。在 这里，我们表示如果age是字符串 \"five\"，则将其变为 \"5\"，如果不是，则保持原样。你 将在 章节 12 部分了解更多关于if_else()和逻辑向量的内容。\n\n\n7.2.2 其他参数\n这里还有一些其他重要的参数我们需要提及。如 果先向你们展示一个有用的技巧，这些参数的演示就会更容易理解：read_csv()可以读取你创建并格式化为 CSV 文件格式的文本字符串。\n\nread_csv(\n  \"a,b,c\n  1,2,3\n  4,5,6\"\n)\n#&gt; # A tibble: 2 × 3\n#&gt;       a     b     c\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n\n通常，read_csv()使用数据的第一行作为列名，这是一个非常常见的约定。但 是，在文件的顶部包含几行元数据的情况也不少见。你 可以使用skip = n来跳过前 n 行，或者使用comment = \"#\"来忽略所有以（例如）# 开头的行：\n\nread_csv(\n  \"The first line of metadata\n  The second line of metadata\n  x,y,z\n  1,2,3\",\n  skip = 2\n)\n#&gt; # A tibble: 1 × 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n\nread_csv(\n  \"# A comment I want to skip\n  x,y,z\n  1,2,3\",\n  comment = \"#\"\n)\n#&gt; # A tibble: 1 × 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n\n在其他情况下，数据可能没有列名。你 可以使用col_names = FALSE来告诉 read_csv()不要将第一行作为标题，而是从X1到Xn顺序地给它们标记列名：\n\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = FALSE\n)\n#&gt; # A tibble: 2 × 3\n#&gt;      X1    X2    X3\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n\n另外，你可以向col_names传递一个字符向量，这个字符向量将被用作列名：\n\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = c(\"x\", \"y\", \"z\")\n)\n#&gt; # A tibble: 2 × 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n\n这些参数是你需要知道的，以便读取你在实践中遇到的大多数 CSV 文件。（ 对于其他情况，你需要仔细检查你的 .csv 文件，并阅读read_csv()的许多其他参数的文档。）\n\n\n7.2.3 其他文件类型\n一旦你掌握了read_csv()，使用readr的其他函数就很简单了；你只需要知道应该使用哪个函数：\n\nread_csv2() 用于读取分号分隔的文件。这 些文件使用;而不是,来分隔字段，这在使用,作为小数点标记符的国家中很常见；\nread_tsv() 用于读取制表符分隔（tab-delimited）的文件；\nread_delim() 用于读取具有任何分隔符的文件，如果你没有指定分隔符，它会尝试自动猜测分隔符；\nread_fwf() 用于读取固定宽度的文件。你 可以使用fwf_widths()通过宽度指定字段，或者使用fwf_positions()通过位置指定字段；\nread_table() 用于读取固定宽度文件的常见变体，其中列由空白字符分隔；\nread_log() 用于读取 Apache 风格的日志文件。\n\n\n\n7.2.4 练习\n\n如果你想要读取一个字段之间使用 “|” 分隔的文件，你会使用什么函数？\n除了file、skip和comment之外，read_csv()和read_tsv()还有哪些共同的参数？\nread_fwf()的最重要参数是什么？\n有时 CSV 文件中的字符串包含逗号。为 了防止它们引起问题，这些字符串需要用引号字符（如 \" 或 '）括起来。默 认情况下，read_csv()假设引号字符为 \"。为了将以下文本读取到数据框中，你需要为read_csv()指定哪个参数？\n\n\"x,y\\n1,'a,b'\"\n\n识别以下内联CSV文件中的每个错误是什么。当 你运行代码时会发生什么？\n\nread_csv(\"a,b\\n1,2,3\\n4,5,6\")\nread_csv(\"a,b,c\\n1,2\\n1,2,3,4\")\nread_csv(\"a,b\\n\\\"1\")\nread_csv(\"a,b\\n1,2\\na,b\")\nread_csv(\"a;b\\n1;3\")\n\n通过以下方式练习在数据框中引用非语法名称：\n\n提取名为1的变量；\n绘制 1 与 2的散点图；\n创建一个名为3的新列，该列是2除以1的结果；\n将列名重命名为 one, two和 three.\n\n\nannoying &lt;- tibble(\n  `1` = 1:10,\n  `2` = `1` * 2 + rnorm(length(`1`))\n)",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "data-import.html#sec-col-types",
    "href": "data-import.html#sec-col-types",
    "title": "7  数据导入",
    "section": "7.3 控制列类型",
    "text": "7.3 控制列类型\nCSV 文件不包含关于每个变量类型（即它是否是逻辑型、数字型、字符串型等）的任何信息，因此readr 会尝试猜测类型。本 节将描述猜测过程的工作原理，如何解决一些常见的导致猜测失败的问题，以及（如果需要的话）如何自己提供列类型。最 后，我们将提及一些在readr 遭遇严重失败且你需要更深入地了解文件结构时非常有用的通用策略。\n\n7.3.1 猜测类型\nreadr 使用一种启发式方法来确定列的类型。对 于每一列，它会从第一行到最后一行均匀地抽取 1,0002 行的值，并忽略缺失值。 然后，它会通过以下问题进行判断：\n\n它是否只包含 F、T、FALSE 或 TRUE（忽略大小写）？如果是，则它是逻辑型；\n它是否只包含数字（如1、-4.5、5e6、Inf）？如果是，则它是数字型；\n它是否符合 ISO8601 标准？如果是，则它是日期或日期-时间型。（我们将在@sec-creating-datetimes 更详细地讨论日期-时间型）；\n否则，它一定是字符串型。\n\n你可以通过以下简单示例看到这个行为：\n\nread_csv(\"\n  logical,numeric,date,string\n  TRUE,1,2021-01-15,abc\n  false,4.5,2021-02-15,def\n  T,Inf,2021-02-16,ghi\n\")\n#&gt; # A tibble: 3 × 4\n#&gt;   logical numeric date       string\n#&gt;   &lt;lgl&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt; \n#&gt; 1 TRUE        1   2021-01-15 abc   \n#&gt; 2 FALSE       4.5 2021-02-15 def   \n#&gt; 3 TRUE      Inf   2021-02-16 ghi\n\n如果你有一个干净的数据集，这种启发式方法很有效，但在现实生活中，你会遇到各种奇怪而美丽的失败。\n\n\n7.3.2 缺失值、列类型和问题\n列检测失败最常见的方式是某列包含了意外值，结果你得到了一个字符型列而不是更具体的类型。这 种情况最常见的原因之一是缺失值，这些缺失值不是使用readr 所期望的NA来记录的。\n以下面这个简单的只有一列的 CSV 文件为例：\n\nsimple_csv &lt;- \"\n  x\n  10\n  .\n  20\n  30\"\n\n如果我们在没有任何附加参数的情况下读取它，x将变成一个字符列：\n\nread_csv(simple_csv)\n#&gt; # A tibble: 4 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 10   \n#&gt; 2 .    \n#&gt; 3 20   \n#&gt; 4 30\n\n在这个很小的例子中，你可以很容易地看到缺失值.。但 是，如果你的文件中有数千行，并且只有少数几个缺失值，并且这些缺失值分散在文件中，那么会发生什么呢？一 种方法是告诉readr x 是一列数字型数据，然后查看它在哪里失败。你 可以使用col_types参数来实现这一点，该参数接受一个命名列表，其中列表的名称与 CSV 文件中的列名相匹配：\n\ndf &lt;- read_csv(\n  simple_csv, \n  col_types = list(x = col_double())\n)\n#&gt; Warning: One or more parsing issues, call `problems()` on your data frame for\n#&gt; details, e.g.:\n#&gt;   dat &lt;- vroom(...)\n#&gt;   problems(dat)\n\n现在read_csv()报告存在问题，并告诉我们可以通过problems()找到更多信息:\n\nproblems(df)\n#&gt; # A tibble: 1 × 5\n#&gt;     row   col expected actual file                                           \n#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;                                          \n#&gt; 1     3     1 a double .      /private/var/folders/q5/6nls1_g145s2fl1lbvx2zb…\n\n这告诉我们，在第 3 行、第 1 列出现了问题， readr 期待一个双精度浮点数，但是得到了一个.。这 表明这个数据集使用.来表示缺失值。因 此，我们设置na = \".\"，自动猜测成功，得到了我们想要的数字列：\n\nread_csv(simple_csv, na = \".\")\n#&gt; # A tibble: 4 × 1\n#&gt;       x\n#&gt;   &lt;dbl&gt;\n#&gt; 1    10\n#&gt; 2    NA\n#&gt; 3    20\n#&gt; 4    30\n\n\n\n7.3.3 列类型\nreadr总共提供了九种列类型供您使用:\n\ncol_logical()和col_double()分别用于读取逻辑值和实数。由于readr 通常会自动为你猜测这些类型，因此它们相对不常用（除了上述情况）；\ncol_integer() 用于读取整数。在本书中，我们很少区分整数和双精度浮点数，因为它们在功能上是等价的，但明确读取整数有时是有用的，因为它们占用的内存只有双精度浮点数的一半；\ncol_character() 用于读取字符串。当某列是数字标识符时，明确指定它可以很有用，例如，用于标识对象的长数字序列，但对这些数字应用数学运算没有意义。示例包括电话号码、社会保障号码、信用卡号码等；\ncol_factor(), col_date()和col_datetime() 分别用于创建因子、日期和日期-时间；当我们 章节 16 和 章节 17 学习这些数据类型时，你会了解更多相关信息；\ncol_number() 是一个宽容的数字解析器，它将忽略非数字部分，特别适用于货币。在@sec-numbers 你将了解更多相关信息；\ncol_skip() 用于跳过某列，使其不包含在结果中；这在处理大型 CSV 文件且只想使用其中的某些列时有用，可以加快数据读取速度。\n\n此外，也可以通过将list()切换到cols()并指定.default来覆盖默认列。\n\nanother_csv &lt;- \"\nx,y,z\n1,2,3\"\n\nread_csv(\n  another_csv, \n  col_types = cols(.default = col_character())\n)\n#&gt; # A tibble: 1 × 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     2     3\n\nAnother useful helper is cols_only() which will read in only the columns you specify:\n\nread_csv(\n  another_csv,\n  col_types = cols_only(x = col_character())\n)\n#&gt; # A tibble: 1 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 1",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "data-import.html#sec-readr-directory",
    "href": "data-import.html#sec-readr-directory",
    "title": "7  数据导入",
    "section": "7.4 从多个文件读取数据",
    "text": "7.4 从多个文件读取数据\n有时，你的数据分散在多个文件中，而不是只包含在一个文件中。例 如，你可能有多个月份的销售数据，每个月的数据都保存在一个单独的文件中：1月的销售数据在01-sales.csv中，2月的在02-sales.csv中，3月的在03-sales.csv中。使 用read_csv()函数可以一次性读取这些数据，并将它们堆叠在一个数据框中。\n\nsales_files &lt;- c(\"data/01-sales.csv\", \"data/02-sales.csv\", \"data/03-sales.csv\")\nread_csv(sales_files, id = \"file\")\n#&gt; # A tibble: 19 × 6\n#&gt;   file              month    year brand  item     n\n#&gt;   &lt;chr&gt;             &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 data/01-sales.csv January  2019     1  1234     3\n#&gt; 2 data/01-sales.csv January  2019     1  8721     9\n#&gt; 3 data/01-sales.csv January  2019     1  1822     2\n#&gt; 4 data/01-sales.csv January  2019     2  3333     1\n#&gt; 5 data/01-sales.csv January  2019     2  2156     9\n#&gt; 6 data/01-sales.csv January  2019     2  3987     6\n#&gt; # ℹ 13 more rows\n\n同样，如果在项目的data文件夹中有CSV文件，上述代码就可以工作。你 可以从https://pos.it/r4ds-01-sales, https://pos.it/r4ds-02-sales和https://pos.it/r4ds-03-sales下载这些文件，或者你可以直接读取它们:\n\nsales_files &lt;- c(\n  \"https://pos.it/r4ds-01-sales\",\n  \"https://pos.it/r4ds-02-sales\",\n  \"https://pos.it/r4ds-03-sales\"\n)\nread_csv(sales_files, id = \"file\")\n\nid参数会在结果数据框中添加一个名为file的新列，用于标识数据来自哪个文件。这 在读取的文件没有包含可以帮助你追踪观测回到其原始来源的标识列时特别有用。\n如果你有很多文件想要读取，一个个写出它们的名称可能会很麻烦。相 反，你可以使用基础函数list.files()来通过匹配文件名中的模式找到这些文件。你 将在@章节 15 部分学习更多关于这些模式的知识。\n\nsales_files &lt;- list.files(\"data\", pattern = \"sales\\\\.csv$\", full.names = TRUE)\nsales_files\n#&gt; [1] \"data/01-sales.csv\" \"data/02-sales.csv\" \"data/03-sales.csv\"",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "data-import.html#sec-writing-to-a-file",
    "href": "data-import.html#sec-writing-to-a-file",
    "title": "7  数据导入",
    "section": "7.5 写入文件",
    "text": "7.5 写入文件\nreadr 还提供了两个有用的函数，用于将数据写回磁盘：write_csv()和write_tsv()。这 些函数最重要的参数是x(要保存的数据框)和file(要保存的位置)。你 还可以指定如何使用na来写入缺失值以及是否希望将其附加到现有文件中。\n\nwrite_csv(students, \"students.csv\")\n\n现在让我们读入csv文件。请 注意，当你保存到CSV时，刚刚设置的变量类型信息会丢失，因为你重新开始从纯文本文件读取:\n\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\nwrite_csv(students, \"students-2.csv\")\nread_csv(\"students-2.csv\")\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\n\n这使得CSV在缓存中间结果时有些不可靠，每次加载时都需要重新创建列规范。主 要有两种替代方案：\n\nwrite_rds() 和 read_rds() 是围绕基础函数readRDS()和saveRDS()的统一包装器。这 些函数将数据存储在R的自定义二进制格式RDS中。这 意味着当你重新加载对象时，你加载的是与存储时完全相同的R对象。\n\nwrite_rds(students, \"students.rds\")\nread_rds(\"students.rds\")\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\n\narrow包允许你读取和写入 parquet 文件，这是一种可以快速跨编程语言共享的二进制文件格式。我 们将在 章节 22 中更深入地探讨arrow。\n\nlibrary(arrow)\nwrite_parquet(students, \"students.parquet\")\nread_parquet(\"students.parquet\")\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    NA                 Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\n\n\nParquet往往比RDS快得多，并且可以在R之外使用，但确实需要arrow包。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "data-import.html#数据录入",
    "href": "data-import.html#数据录入",
    "title": "7  数据导入",
    "section": "7.6 数据录入",
    "text": "7.6 数据录入\n有时，你需要在R脚本中手动组装一个tibble（数据框），进行一些数据录入。有 两个有用的函数可以帮助你完成这项工作，这两个函数的不同之处在于它们是通过列还是通过行来布局tibble的。t ibble()函数是按列工作的：\n\ntibble(\n  x = c(1, 2, 5), \n  y = c(\"h\", \"m\", \"g\"),\n  z = c(0.08, 0.83, 0.60)\n)\n#&gt; # A tibble: 3 × 3\n#&gt;       x y         z\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     1 h      0.08\n#&gt; 2     2 m      0.83\n#&gt; 3     5 g      0.6\n\n按列布局数据可能会难以看到行之间的关系，因此另一种方法是tribble()（transposed tibble的缩写），它允许你逐行布局数据。t ribble()是为代码中的数据输入定制的：列标题以~开头，条目之间用逗号分隔。这 使得以易于阅读的形式布局少量数据成为可能：\n\ntribble(\n  ~x, ~y, ~z,\n  1, \"h\", 0.08,\n  2, \"m\", 0.83,\n  5, \"g\", 0.60\n)\n#&gt; # A tibble: 3 × 3\n#&gt;       x y         z\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     1 h      0.08\n#&gt; 2     2 m      0.83\n#&gt; 3     5 g      0.6",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "data-import.html#小结",
    "href": "data-import.html#小结",
    "title": "7  数据导入",
    "section": "7.7 小结",
    "text": "7.7 小结\n在本章中，你学习了如何使用read_csv()加载CSV文件，以及如何使用tibble()和tribble()进行自己的数据输入。你 了解了CSV文件的工作原理，可能会遇到的一些问题，以及如何解决这些问题。在 本书中，我们将多次涉及数据导入：从Excel和Google表格中导入数据的 章节 20 ，章节 21 将向你展示如何从数据库中加载数据，章节 22 将介绍如何从Parquet文件中加载数据，章节 23 将涉及从JSON中导入数据，以及@sec-scraping 将介绍如何从网站上抓取数据。\n本书的这个部分即将结束，但还有一个重要的主题需要讨论：如何获取帮助。因 此，在下一章中，你将学习一些寻求帮助的好地方，如何创建一个可重现的示例（reprex）以最大化获得良好帮助的机会，以及一些关于跟上R世界步伐的一般性建议。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "data-import.html#footnotes",
    "href": "data-import.html#footnotes",
    "title": "7  数据导入",
    "section": "",
    "text": "janitor包不是tidyverse的一部分，但它提供了方便的数据清理功能，并且在使用|&gt;的数据管道中工作得很好。↩︎\n你可以使用guess_max参数覆盖1000的默认值。↩︎",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "workflow-help.html",
    "href": "workflow-help.html",
    "title": "8  工作流程：获取帮助",
    "section": "",
    "text": "8.1 充分利用互联网\n如果你遇到了困难，首先尝试使用Google搜索。通 常，在查询中加上“R”就能将结果限制在相关的范围内：如果搜索结果没有帮助，那通常意味着没有特定的R语言相关结果。此 外，添加包名如“tidyverse”或“ggplot2”将有助于将结果缩小到你更熟悉的代码范围内，例如，“如何在R中制作箱线图”与“如何在R中使用ggplot2制作箱线图”。G oogle对错误消息特别有用，如果你收到一个错误消息而不知道它是什么意思，试着搜索它！很 有可能其他人以前也被这个错误消息搞糊涂过，网上某个地方会有帮助。（ 如果错误消息不是英文的，运行Sys.setenv(LANGUAGE = \"en\")并重新运行代码；你更有可能找到英文错误消息的帮助。）\n如果Google没有帮助，尝试使用Stack Overflow。首 先花一些时间搜索现有的答案，包括[R]标签，以将搜索限制在使用R的问题和答案上。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>工作流程：获取帮助</span>"
    ]
  },
  {
    "objectID": "workflow-help.html#制作reprexx",
    "href": "workflow-help.html#制作reprexx",
    "title": "8  工作流程：获取帮助",
    "section": "8.2 制作reprexx",
    "text": "8.2 制作reprexx\n如果你的Google搜索没有找到有用的信息，制作一个最小化的reprex（reproducible example的缩写）是一个很好的主意。一 个好的reprex会让其他人更容易帮助你，而且通常在制作它的过程中，你自己就会发现问题所在。制 作reprex有两个部分：\n\n首先，你需要让你的代码可复现。这 意味着你需要捕获所有内容，即包括任何library()调用并创建所有必要的对象。确 保你已经做到这一点的最简单方法是使用reprex包。\n其次，你需要将其简化到最小。去 掉所有与问题不直接相关的内容。这 通常意味着创建一个比你实际面对的更小、更简单的R对象，或者甚至使用内置数据。\n\n这听起来像是一项繁重的工作！确 实可能如此，但它的回报非常大\n\n80%的情况下，创建一个出色的reprex会揭示问题的根源。令 人惊讶的是，多少次在编写一个独立且简化的例子的过程中，你就能够自己解答问题了；\n另外20%的情况下，你已经以易于他人操作的方式捕捉到了问题的本质，这极大地提高了你获得帮助的机会！\n\n在手动创建reprex时，很容易不小心遗漏某些内容，导致你的代码无法在别人的计算机上运行。通 过使用reprex包可以避免这个问题，该包是tidyverse的一部分。假 设你将这段代码复制到了剪贴板（或者，在RStudio Server或Cloud上，选择它）：\n\ny &lt;- 1:4\nmean(y)\n\n然后调用reprex()，其默认输出格式为GitHub所需的格式:\nreprex::reprex()\n如果你正在使用RStudio，一个精美的HTML预览将会在RStudio的Viewer中显示；否则，它会在你的默认浏览器中显示。r eprex会被自动复制到你的剪贴板（在RStudio Server或Cloud上，你需要手动复制）：\n``` r\ny &lt;- 1:4\nmean(y)\n#&gt; [1] 2.5\n```\n这段文本以一种特殊的方式格式化，称为Markdown，它可以粘贴到像StackOverflow或Github这样的网站上，并且这些网站会自动将其渲染成代码的样子。以 下是这段Markdown在Github上的渲染效果：\n\ny &lt;- 1:4\nmean(y)\n#&gt; [1] 2.5\n\n任何人都可以立即复制、粘贴和运行这个例子。\n要使你的例子可重复，需要包含三样东西：必要的包、数据和代码。\n\n包应该在脚本的顶部加载，这样很容易看出这个例子需要哪些包。现 在是检查你是否在使用每个包的最新版本的好时机；你可能发现了一个自你安装或最后一次更新包以来已经被修复的错误。对 于tidyverse中的包，最简单的检查方法是运行tidyverse_update()。\n包含数据的最简单方法是使用dput()来生成重新创建它所需的R代码。例 如，要在R中重新创建mtcars数据集，请按照以下步骤操作：\n\n在R中运行dput(mtcars)\n复制输出结果t\n在reprex中，键入mtcars &lt;-，然后粘贴。\n\n尽量使用数据的最小子集，但还要能揭示问题。\n花点时间确保你的代码易于他人阅读：\n\n确保你使用了空格，并且你的变量名简洁但富有信息性；\n使用注释来指出问题所在；\n尽最大努力移除与问题无关的所有内容。\n\n你的代码越短，就越容易理解，也就越容易修复。\n\n最后，通过启动一个新的R会话并复制粘贴你的脚本来检查你是否真的创建了一个可重复的例子。\n创建reprexes并不是一件简单的事情，而且学习创建好的、真正精简的reprexes需要一些实践。然 而，学习在问题中包含代码，并投入时间使其可重复，将随着你学习和掌握R而不断得到回报。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>工作流程：获取帮助</span>"
    ]
  },
  {
    "objectID": "workflow-help.html#投资自己",
    "href": "workflow-help.html#投资自己",
    "title": "8  工作流程：获取帮助",
    "section": "8.3 投资自己",
    "text": "8.3 投资自己\n你也应该花一些时间在问题发生之前做好解决问题的准备。每 天花一点时间学习R，长期来看会有丰厚的回报。一 种方法是关注tidyverse团队在tidyverse博客上的动态。为 了更广泛地了解R社区，我们推荐阅读R Weekly：它是社区的一项努力，每周汇总R社区中最有趣的新闻。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>工作流程：获取帮助</span>"
    ]
  },
  {
    "objectID": "workflow-help.html#小结",
    "href": "workflow-help.html#小结",
    "title": "8  工作流程：获取帮助",
    "section": "8.4 小结",
    "text": "8.4 小结\n本书全貌概览（Whole Game）部分到此结束。现 在你已经看到了数据科学过程中最重要的部分：可视化、转换、整理和导入。现 在你已经有了一个对整个过程的整体认识，接下来我们将深入到各个小部分的细节。\n本书的下一部分，可视化，将深入探讨图形语法和如何使用ggplot2创建数据可视化，展示如何使用你迄今为止学到的工具进行探索性数据分析，并介绍创建用于交流的图的良好实践。",
    "crumbs": [
      "全貌概览",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>工作流程：获取帮助</span>"
    ]
  },
  {
    "objectID": "layers.html",
    "href": "layers.html",
    "title": "9  图层",
    "section": "",
    "text": "9.1 引言\n在 章节 1 中, 你学到的远不止如何制作散点图、条形图和箱线图。你 学习了利用ggplot2可以制作任何类型图形的基础知识。\n在本章中你将在这个基础上进行扩展，学习图形的分层语法。首 先，我们将更深入地探讨美学映射、几何对象和切面。然 后，你将了解ggplot2在创建图形时背后进行的统计转换。这 些转换用于计算新的绘图值，例如条形图中的条形高度或箱线图的中位数。你 还将学习位置调整，这会修改几何对象在图表中的显示方式。最 后，我们将简要介绍坐标系。\n我们不会涵盖这些图层中的每一个函数和选项，但我们将引导你了解ggplot2提供的最重要和最常用的功能，并向你介绍扩展ggplot2的包。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "layers.html#引言",
    "href": "layers.html#引言",
    "title": "9  图层",
    "section": "",
    "text": "9.1.1 必要条件\n本章重点介绍ggplot2。要 访问本章中使用的数据集、帮助页面和函数，请运行以下代码加载tidyverse:\n\nlibrary(tidyverse)",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "layers.html#美学映射",
    "href": "layers.html#美学映射",
    "title": "9  图层",
    "section": "9.2 美学映射",
    "text": "9.2 美学映射\n\n“图片的最大价值在于它能够迫使我们注意到我们从未预期到的内容。”\n— John Tukey\n\n请记住，ggplot2 包附带的 mpg 数据框包含了关于38种不同汽车型号的234条观测数据。\n\nmpg\n#&gt; # A tibble: 234 × 11\n#&gt;   manufacturer model displ  year   cyl trans      drv     cty   hwy fl   \n#&gt;   &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;\n#&gt; 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p    \n#&gt; 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p    \n#&gt; 3 audi         a4      2    2008     4 manual(m6) f        20    31 p    \n#&gt; 4 audi         a4      2    2008     4 auto(av)   f        21    30 p    \n#&gt; 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p    \n#&gt; 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p    \n#&gt; # ℹ 228 more rows\n#&gt; # ℹ 1 more variable: class &lt;chr&gt;\n\nmpg 中的变量包括:\n\ndispl: 汽车发动机的排量，单位为升。这 是一个数值型变量。\nhwy: 高速公路上汽车的燃油效率，以每加仑行驶的英里数（mpg）为单位。当 两辆汽车行驶相同的距离时，燃油效率低的汽车比燃油效率高的汽车消耗更多的燃油。这 是一个数值型变量。\nclass: 汽车的型号。这 是一个分类变量。\n\n让我们首先通过可视化不同车型类别（class）的排量（displ）和高速公路燃油效率（hwy）之间的关系来开始。我 们可以使用散点图来实现这一点，其中数值变量映射到 x 和 y 美学上，而分类变量则映射到color或shape等美学上。\n# Left\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point()\n\n# Right\nggplot(mpg, aes(x = displ, y = hwy, shape = class)) +\n  geom_point()\n#&gt; Warning: The shape palette can deal with a maximum of 6 discrete values because more\n#&gt; than 6 becomes difficult to discriminate\n#&gt; ℹ you have requested 7 values. Consider specifying shapes manually if you\n#&gt;   need that many have them.\n#&gt; Warning: Removed 62 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n当类别（class）映射到形状（shape）时，我们得到了两个警告：\n\n1: 形状调色板最多只能处理 6 个离散值，因为超过 6 个值后就很难区分；但你有 7 个。如 果你必须使用它们，请考虑手动指定形状。\n2: 删除了包含缺失值的 62 行（geom_point()）。\n\n由于 ggplot2 默认一次只会使用六个形状，因此当使用形状美学时，额外的组将不会被绘制。第 二个警告与此相关——数据集中有 62 辆 SUV，它们没有被绘制出来。\n类似地，我们也可以将类别（class）映射到大小（size）或透明度（alpha）美学上，它们分别控制点的大小和透明度。\n# Left\nggplot(mpg, aes(x = displ, y = hwy, size = class)) +\n  geom_point()\n#&gt; Warning: Using size for a discrete variable is not advised.\n\n# Right\nggplot(mpg, aes(x = displ, y = hwy, alpha = class)) +\n  geom_point()\n#&gt; Warning: Using alpha for a discrete variable is not advised.\n\n\n\n\n\n\n\n\n\n\n这两种方法都会产生警告:\n\n不建议将alpha用作离散变量。\n\n将一个无序的离散（分类）变量（如车型class）映射到一个有序的美学属性（如大小size或透明度alpha）通常不是明智之举，因为它暗含了一个实际上并不存在的排名。\n一旦你映射了一个美学属性，ggplot2 就会处理其余部分。它 会选择一个合理的刻度来与这个美学属性一起使用，并构造一个图例来解释水平和值之间的映射关系。对 于 x 和 y 美学属性，ggplot2 不会创建图例，但会创建一个带有刻度线和标签的坐标轴线。坐 标轴线提供了与图例相同的信息；它解释了位置和值之间的映射关系。\n你也可以通过几何对象函数的参数（在 aes() 之外）来手动设置你的几何对象的视觉属性，而不是依赖变量映射来确定外观。例 如，我们可以让我们的图形中的所有点都呈现蓝色：\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(color = \"blue\")\n\n\n\n\n\n\n\n\n在这里颜色并不传达关于变量的信息，而只是改变图的外观。你 需要选择一个对该美学属性有意义的值：\n\n颜色的名称作为字符串, 例如 color = \"blue\"\n点的大小以毫米为单位，例如 size = 1\n点的形状作为一个数字，例如 shape = 1, 如图 图 9.1 所示。\n\n\n\n\n\n\n\n\n\n图 9.1: R has 25 built-in shapes that are identified by numbers. There are some seeming duplicates: for example, 0, 15, and 22 are all squares. The difference comes from the interaction of the color and fill aesthetics. The hollow shapes (0–14) have a border determined by color; the solid shapes (15–20) are filled with color; the filled shapes (21–24) have a border of color and are filled with fill. Shapes are arranged to keep similar shapes next to each other.\n\n\n\n\n\n到目前为止，我们讨论了在使用点几何对象（point geom）创建散点图时可以映射或设置的美学属性。你 可以在https://ggplot2.tidyverse.org/articles/ggplot2-specs.html 的美学规范文档中了解更多关于所有可能的美学映射的信息。\n你可以在一个图中使用的具体美学属性取决于你用来表示数据的几何对象（geom）。在 下一节中，我们将更深入地探讨几何对象。\n\n9.2.1 练习\n\n创建一个hwy和displ的散点图，其中的点是粉红色填充的三角形。\n以下代码为什么没有生成带有蓝色点的图：\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy, color = \"blue\"))\n\n描边美学（stroke aesthetic）是做什么用的？它 与哪些形状一起工作？（ 提示：使用 ?geom_point）\n如果你将美学映射到变量名之外的其他东西，比如 aes(color = displ &lt; 5)，会发生什么？注 意，你还需要指定 x 和 y。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "layers.html#sec-geometric-objects",
    "href": "layers.html#sec-geometric-objects",
    "title": "9  图层",
    "section": "9.3 几何对象",
    "text": "9.3 几何对象\n下面两张图有什么相似之处？\n\n\n\n\n\n\n\n\n\n\n\n\n\n两张图包含相同的x变量和y变量，并且都描述了相同的数据。但 是，这两张图并不完全相同。每 张图都使用不同的几何对象（geom）来表示数据。左 侧的图使用了点几何对象（point geom），而右侧的图表使用了平滑几何对象（smooth geom），即用平滑线拟合到数据上。\n要在你的图中更改几何对象（geom），请更改你添加到ggplot()函数中的几何对象函数。例 如，要绘制上述图可以使用以下代码：\n\n# Left\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point()\n\n# Right\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_smooth()\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n在ggplot2中，每个geom函数都接受一个映射参数，这个参数可以在geom图层中本地定义，也可以在ggplot()图层中全局定义。然 而，并不是每个美学属性（aesthetic）都适用于每个geom。你 可以设置点的形状，但你不能设置线的“形状”。如 果你尝试这样做，ggplot2会静默地忽略该美学映射。另 一方面，你可以设置线的线型。g eom_smooth()会根据你映射到线型变量的不同值，绘制具有不同线型的平滑线。\n# Left\nggplot(mpg, aes(x = displ, y = hwy, shape = drv)) + \n  geom_smooth()\n\n# Right\nggplot(mpg, aes(x = displ, y = hwy, linetype = drv)) + \n  geom_smooth()\n\n\n\n\n\n\n\n\n\n\n在这里，geom_smooth()根据汽车的drv值（描述了汽车的驱动方式）将汽车数据分成三条线。一 条线描述了所有值为4的点，一条线描述了所有值为f的点，还有一条线描述了所有值为r的点。在 这里，4代表四轮驱动，f代表前轮驱动，r代表后轮驱动。\n如果这听起来有些奇怪，我们可以通过将这三条线叠加在原始数据上，并根据drv的值给所有内容上色，来使其更加清晰。\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) + \n  geom_point() +\n  geom_smooth(aes(linetype = drv))\n\n\n\n\n\n\n\n\n请注意，这个图在同一个图形中包含了两个几何对象（geoms）。\n许多几何对象（如geom_smooth()）使用单个几何对象来显示多行数据。对 于这些几何对象，你可以将组（group）美学属性设置为分类变量来绘制多个对象。g gplot2会为分组变量的每个值绘制一个独立的对象。在 实践中，当你将美学属性映射到离散变量时（如线型示例），ggplot2会自动为这些几何对象分组数据。依 赖这个特性是很方便的，因为组（group）美学属性本身不会给几何对象添加图例或区分特征。\n# Left\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth()\n\n# Middle\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth(aes(group = drv))\n\n# Right\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth(aes(color = drv), show.legend = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n如果你在geom函数中放置映射，ggplot2会将这些映射视为该图层的本地映射。它 将使用这些映射来扩展或覆盖该图层的全局映射。这 使得在不同的图层中显示不同的美学属性成为可能。\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(aes(color = class)) + \n  geom_smooth()\n\n\n\n\n\n\n\n\n你可以使用相同的思路来为每一层指定不同的数据。在 这里，我们使用红色的点和空心的圆圈来突出显示两座车。g eom_point()中的局部数据参数（local data argument）仅针对那一层覆盖了ggplot()中的全局数据参数（global data argument）。\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  geom_point(\n    data = mpg |&gt; filter(class == \"2seater\"), \n    color = \"red\"\n  ) +\n  geom_point(\n    data = mpg |&gt; filter(class == \"2seater\"), \n    shape = \"circle open\", size = 3, color = \"red\"\n  )\n\n\n\n\n\n\n\n\n几何对象（geoms）是ggplot2的基本构建模块。你 可以通过改变图形的geom来完全改变其外观，而不同的geoms可以揭示数据的不同特征。例 如下面的直方图和密度图揭示了高速公路里程的分布是双峰的且向右偏斜，而箱线图则揭示了两个潜在的异常值。\n# Left\nggplot(mpg, aes(x = hwy)) +\n  geom_histogram(binwidth = 2)\n\n# Middle\nggplot(mpg, aes(x = hwy)) +\n  geom_density()\n\n# Right\nggplot(mpg, aes(x = hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot2提供了超过 40 个geoms，但这并不覆盖所有可能创建的图形。如 果你需要一个不同的geom，我们建议先查看扩展包，看看是否有人已经实现了它（可以在https://exts.ggplot2.tidyverse.org/gallery/找到一个示例）。例 如，ggridges包（https://wilkelab.org/ggridges）对于制作山脊线图（ridgeline plots）很有用，这种图可以用于可视化数值变量在不同类别变量水平下的密度。在 下面的图形中，我们不仅使用了一个新的geom（geom_density_ridges()），而且我们还将相同的变量映射到多个美学属性（drv到y、fill和color），并设置了一个美学属性（alpha = 0.5）以使密度曲线透明。\n\nlibrary(ggridges)\n\nggplot(mpg, aes(x = hwy, y = drv, fill = drv, color = drv)) +\n  geom_density_ridges(alpha = 0.5, show.legend = FALSE)\n#&gt; Picking joint bandwidth of 1.28\n\n\n\n\n\n\n\n\n要了解ggplot2提供的所有geoms的全面概述以及包中的所有函数，最好的地方是参考https://ggplot2.tidyverse.org/reference。要 深入了解任何单一的geom，请使用帮助函数（例如 ?geom_smooth）。\n\n9.3.1 练习\n\n你会使用哪种geom来绘制折线图？箱 线图？直 方图？面 积图？\n在本章的前面部分，我们使用了show.legend而没有解释它：\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth(aes(color = drv), show.legend = FALSE)\n\nshow.legend = FALSE在这里的作用是什么?如 果你把它去掉会怎么样?你 觉得我们之前为什么用它?\ngeom_smooth() 的参数se起什么作用?\n重新创建生成以下图形所需的R代码。 请注意，图中用到的分类变量的都是drv。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "layers.html#分面",
    "href": "layers.html#分面",
    "title": "9  图层",
    "section": "9.4 分面",
    "text": "9.4 分面\n在 章节 1 ，你学习了使用facet_wrap()进行分面，该方法可以将一个图形分割成子图，每个子图都基于一个分类变量显示数据的一个子集。\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_wrap(~cyl)\n\n\n\n\n\n\n\n\n要使用两个变量的组合来对你的图形进行分面，你需要从facet_wrap()切换到facet_grid()。f acet_grid()的第一个参数也是一个公式，但现在它是一个双面公式：rows ~ cols。\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_grid(drv ~ cyl)\n\n\n\n\n\n\n\n\n默认情况下，每个分面共享相同的x轴和y轴的刻度和范围。当 你想跨分面比较数据时，这很有用，但当你希望更好地可视化每个分面内的关系时，这可能会有所限制。将 分面函数中的scales参数设置为\"free\"将允许行和列之间使用不同的轴刻度，“free_x”将允许行之间使用不同的刻度，“free_y”将允许列之间使用不同的刻度。\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_grid(drv ~ cyl, scales = \"free_y\")\n\n\n\n\n\n\n\n\n\n9.4.1 练习\n\n如果你对一个连续变量进行分面会发生什么？\n上面的图中使用facet_grid(drv ~ cyl)生成的空单元格是什么意思？运 行以下代码，它们与生成的图有什么关系？\n\nggplot(mpg) + \n  geom_point(aes(x = drv, y = cyl))\n\n以下代码生成了什么样的图形？. 在这里代表什么？\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ .)\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) +\n  facet_grid(. ~ cyl)\n\n查看本节中的第一个分面图：\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) + \n  facet_wrap(~ class, nrow = 2)\n\n使用分面（faceting）而不是颜色美学（color aesthetic）的优势是什么？劣 势是什么？如 果你有一个更大的数据集，这种平衡可能会如何改变？\n阅读?facet_wrap的帮助文档，nrow是做什么的？n col呢？还 有哪些选项控制单个面板的布局？为 什么facet_grid()没有nrow和ncol参数？\n下面的哪个图使得比较不同驱动方式的汽车的发动机排量（displ）更容易？\n\nggplot(mpg, aes(x = displ)) + \n  geom_histogram() + \n  facet_grid(drv ~ .)\n\nggplot(mpg, aes(x = displ)) + \n  geom_histogram() +\n  facet_grid(. ~ drv)\n\n使用facet_wrap()重新创建以下图形。这 时分面标签的位置如何变化？\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ .)",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "layers.html#统计变换",
    "href": "layers.html#统计变换",
    "title": "9  图层",
    "section": "9.5 统计变换",
    "text": "9.5 统计变换\n下面是一个用geom_bar()或geom_col()绘制的基本条形图，图形显示了diamonds数据集中按cut分组的钻石总数。d iamonds数据集位于ggplot2包中，包含约 54,000 颗钻石的信息，包括每颗钻石的价格（price）、重量（carat）、颜色（color）、净度（clarity）和切割方式（cut ）。图 形显示，高质量切割的钻石比低质量切割的钻石更多。\n\nggplot(diamonds, aes(x = cut)) + \n  geom_bar()\n\n\n\n\n\n\n\n\n在 x 轴上图形显示了来自 diamonds 数据集的变量 cut。在 y 轴上显示了 count，但 count 并不是 diamonds 数据集中的变量！c ount 是从哪里来的？许 多图形，如散点图会绘制数据集的原始值。而 其他图形，如条形图则会计算新的值来绘制：\n\n条形图、直方图和频数多边形会将数据进行分箱，然后绘制每个分箱中的点数（即分箱计数）。\n平滑器（smoothers）会对您的数据拟合一个模型，然后绘制该模型的预测值。\n箱线图会计算分布的五数汇总（five-number summary），然后以特殊格式的箱子显示该汇总。\n\n用于计算图形新值的算法被称为 stat，是 statistical transformation（统计变换）的缩写。@ fig-vis-stat-bar 展示了 geom_bar() 是如何工作的。\n\n\n\n\n\n\n\n\n图 9.2: When creating a bar chart we first start with the raw data, then aggregate it to count the number of observations in each bar, and finally map those computed variables to plot aesthetics.\n\n\n\n\n\n你可以通过检查stat参数的默认值来了解一个geom使用的是哪种统计变换。例 如?geom_bar显示stat的默认值是”count”，这意味着geom_bar()使用的是stat_count()。s tat_count()的文档与geom_bar()在同一页面。如 果你向下滚动，名为“Computed variables”的部分说明它计算了两个新变量：count和prop。\n每个geom都有一个默认的统计变换；每个统计变换也有一个默认的geom。这 意味着你通常可以使用geoms而不用担心底层的统计变换。然 而，在三种情况下你可能需要指明使用何种统计变换：\n\n你可能想要覆盖默认的统计变换。在 下面的代码中，我们将geom_bar()的统计变换从默认的count更改为identity。这 样我们就可以将条形的高度映射到 y 变量的原始值。\n\ndiamonds |&gt;\n  count(cut) |&gt;\n  ggplot(aes(x = cut, y = n)) +\n  geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\n\n你可能想要覆盖从变换后的变量到视觉属性的默认映射。例 如，你可能想要显示一个比例条形图，而不是计数条形图：\n\nggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) + \n  geom_bar()\n\n\n\n\n\n\n\n\n要找到可以由统计变换计算的可能的变量，请在geom_bar()的帮助文档中寻找标题为“computed variables”的部分。\n你可能希望在你的代码中更加关注统计变换。例 如你可能使用stat_summary()，它对每个唯一的 x 值汇总 y 值，以此来强调你正在计算的汇总统计量：\n\nggplot(diamonds) + \n  stat_summary(\n    aes(x = cut, y = depth),\n    fun.min = min,\n    fun.max = max,\n    fun = median\n  )\n\n\n\n\n\n\n\n\n\nggplot2 提供了超过 20 种统计变换。每 个统计变换都是一个函数，所以你可以通过常规方式获取帮助，例如使用?stat_bin。\n\n9.5.1 练习\n\nstat_summary()的默认geom是什么？如 何使用这个geom函数而不是stat函数来重写前面的图形？\ngeom_col()是做什么的？它 与geom_bar()有什么不同？\n大多数geoms和stats都是成对出现的，它们几乎总是协同工作。请 列出所有这些对子。它 们有什么共同点？（ 提示：阅读文档。）\nstat_smooth()函数计算哪些变量？哪 些参数控制其行为？\n在我们的比例条形图中，我们需要设置group = 1。为 什么呢？换 句话说，这两个图有什么问题？\n\nggplot(diamonds, aes(x = cut, y = after_stat(prop))) + \n  geom_bar()\nggplot(diamonds, aes(x = cut, fill = color, y = after_stat(prop))) + \n  geom_bar()",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "layers.html#位置调整",
    "href": "layers.html#位置调整",
    "title": "9  图层",
    "section": "9.6 位置调整",
    "text": "9.6 位置调整\n与条形图相关的还有一个神奇的特性。你 可以使用颜色美学（color aesthetic）来为条形图上色，但更有用的是，你还可以使用填充美学（fill aesthetic）来为条形图上色：\n# Left\nggplot(mpg, aes(x = drv, color = drv)) + \n  geom_bar()\n\n# Right\nggplot(mpg, aes(x = drv, fill = drv)) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\n\n请注意，如果你将填充美学映射到另一个变量，比如class，条形图会自动堆叠。每 个彩色矩形代表drv和class的一个组合。\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar()\n\n\n\n\n\n\n\n\n堆叠是通过由position参数指定的位置调整（position adjustment）自动执行的。如 果你不想创建堆叠条形图，你可以使用以下三种选项之一：\"identity\"、\"dodge\" 或 \"fill\"。\n\nposition = \"identity\"会将每个对象精确地放置在其在图中的位置。这 对于条形图来说不是很有用，因为它会使它们重叠。为 了看到这种重叠，我们需要将条形设置为稍微透明，通过将alpha设置为一个小值，或者通过设置fill = NA使其完全透明。\n# Left\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(alpha = 1/5, position = \"identity\")\n\n# Right\nggplot(mpg, aes(x = drv, color = class)) + \n  geom_bar(fill = NA, position = \"identity\")\n\n\n\n\n\n\n\n\n\n\n“identity”位置调整对于二维几何对象（如点）更为有用，它是这些对象的默认设置。\nposition = \"fill\" 的作用类似于堆叠，但会使每组堆叠的条形具有相同的高度。这 使得比较各组之间的比例更容易。\nposition = \"dodge\" 将重叠的对象直接并排放置，这使得比较各个值更容易。\n# Left\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"fill\")\n\n# Right\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"dodge\")\n\n\n\n\n\n\n\n\n\n\n\n还有一种调整不适用于条形图，但对散点图非常有用。回 想我们的第一个散点图。你 有没有注意到，尽管数据集中有234个观测值，但图中只显示了126个点？\n\n\n\n\n\n\n\n\n\nhwy和displ的基础值被四舍五入，因此点显示在一个网格上，许多点互相重叠。这 个问题被称为过度绘制（overplotting）。这 种布局使得很难看到数据的分布。数 据点在整个图中是均匀分布的吗，还是hwy和displ的某个特殊组合包含了109个值？\n你可以通过设置位置调整为 “jitter” 来避免这种网格化。p osition = \"jitter\"会给每个点添加一小部分随机噪声。这 会将点分散开来，因为两个点不太可能获得相同数量的随机噪声。\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(position = \"jitter\")\n\n\n\n\n\n\n\n\n添加随机性似乎是一种奇怪的改进图表的方式，但尽管它在小范围内降低了图形的准确性，但在大范围内却使图形更清晰。由 于这是一种非常有用的操作，ggplot2 为geom_point(position = \"jitter\")提供了一个简写形式：geom_jitter()。\n要了解更多关于位置调整的信息，请查阅与每个调整相关的帮助页面：?position_dodge、?position_fill、?position_identity、?position_jitter 和 ?position_stack。\n\n9.6.1 练习\n\n下面的图有什么问题？如 何改进它？\n\nggplot(mpg, aes(x = cty, y = hwy)) + \n  geom_point()\n\n这两个图之间有什么区别（如果有的话）？为 什么？\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point()\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(position = \"identity\")\n\ngeom_jitter()中的哪些参数控制抖动量（amount of jittering）？\n将geom_jitter()与geom_count()进行比较和对比。\ngeom_boxplot()的默认位置调整是什么？使 用 mpg 数据集创建一个可视化来展示它。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "layers.html#坐标系",
    "href": "layers.html#坐标系",
    "title": "9  图层",
    "section": "9.7 坐标系",
    "text": "9.7 坐标系\n坐标系可能是 ggplot2 中最复杂的部分。默 认的坐标系是笛卡尔坐标系，其中 x 和 y 位置独立地确定每个点的位置。还 有另外两种坐标系在某些情况下也很有用。\n\ncoord_quickmap()为地理地图设置了正确的纵横比。如 果你使用 ggplot2 绘制空间数据，这一点非常重要。本 书中没有空间讨论地图，但你可以在《ggplot2: Elegant graphics for data analysis》一书的Maps chapter 中了解更多信息。\nnz &lt;- map_data(\"nz\")\n\nggplot(nz, aes(x = long, y = lat, group = group)) +\n  geom_polygon(fill = \"white\", color = \"black\")\n\nggplot(nz, aes(x = long, y = lat, group = group)) +\n  geom_polygon(fill = \"white\", color = \"black\") +\n  coord_quickmap()\n\n\n\n\n\n\n\n\n\n\ncoord_polar() 使用极坐标系。极 坐标系揭示了条形图和扇形图（Coxcomb chart）之间一个有趣的联系。\nbar &lt;- ggplot(data = diamonds) + \n  geom_bar(\n    mapping = aes(x = clarity, fill = clarity), \n    show.legend = FALSE,\n    width = 1\n  ) + \n  theme(aspect.ratio = 1)\n\nbar + coord_flip()\nbar + coord_polar()\n\n\n\n\n\n\n\n\n\n\n\n\n9.7.1 练习\n\n使用coord_polar()将堆叠的条形图转换为饼状图。\ncoord_quickmap() 和 coord_map() 之间的区别是什么？\n下图告诉你city和高速公路mpg之间的关系是什么？为 什么coord_fixed()很重要？g eom_abline()的作用什么？\n\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +\n  geom_point() + \n  geom_abline() +\n  coord_fixed()",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "layers.html#图形的分层语法",
    "href": "layers.html#图形的分层语法",
    "title": "9  图层",
    "section": "9.8 图形的分层语法",
    "text": "9.8 图形的分层语法\n我们可以通过添加位置调整、统计量、坐标系和分面来扩展你在@sec-ggplot2-calls 学到的绘图模板：\nggplot(data = &lt;DATA&gt;) + \n  &lt;GEOM_FUNCTION&gt;(\n     mapping = aes(&lt;MAPPINGS&gt;),\n     stat = &lt;STAT&gt;, \n     position = &lt;POSITION&gt;\n  ) +\n  &lt;COORDINATE_FUNCTION&gt; +\n  &lt;FACET_FUNCTION&gt;\n我们的新模板需要七个参数，即模板中出现的括号中的词。在 实践中，你很少需要为制作图形提供所有七个参数，因为 ggplot2 会为除了数据、映射和 geom 函数之外的所有内容提供有用的默认值。\n模板中的七个参数构成了图形的语法（grammar of graphics），这是一个用于构建图形的正式系统。图 形的语法基于这样一个见解：你可以将任何图形唯一地描述为数据集、geom、一组映射、统计量、位置调整、坐标系、分面方案和主题的组合。\n为了了解这是如何工作的，请考虑如何从零开始构建一个基本的图形：你可以从一个数据集开始，然后将其转换为你想要显示的信息（使用统计量）。接 下来，你可以选择一个几何对象来表示转换后数据中的每个观测值。然 后，你可以使用 geom 的美学属性来表示数据中的变量。你 可以将每个变量的值映射到美学的水平。这 些步骤在 图 9.3 中进行了说明。然 后，你会选择一个坐标系来放置 geom，使用对象的位置（它本身也是一个美学属性）来显示 x 和 y 变量的值。\n\n\n\n\n\n\n\n\n图 9.3: Steps for going from raw data to a table of frequencies to a bar plot where the heights of the bar represent the frequencies.\n\n\n\n\n\n在这一点上，你将拥有一个完整的图形，但你可以进一步调整 geom 在坐标系内的位置（位置调整）或将图形拆分为子图（分面）。你 还可以通过添加一个或多个附加层来扩展图形，其中每个附加层都使用数据集、geom、一组映射、统计量和位置调整。\n你可以使用这种方法来构建你想象中的任何图形。换 句话说，你可以使用本章中学习的代码模板来构建数十万个独特的图形。\n如果你想了解更多关于 ggplot2 的理论基础，你可能会喜欢阅读《The Layered Grammar of Graphics》这篇科学论文，它详细描述了 ggplot2 的理论。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "layers.html#小结",
    "href": "layers.html#小结",
    "title": "9  图层",
    "section": "9.9 小结",
    "text": "9.9 小结\n在本章中，你从美学和几何图形开始学习了图形的分层语法，以构建简单的图形、通过分面将图形拆分为子集、通过统计量了解 geom 是如何计算的、通过位置调整控制 geom 可能重叠时的位置细节，以及通过坐标系统从根本上改变 x 和 y 的含义。我 们尚未涉及的一个层次是主题（theme），我们将在 小节 11.5 中介绍。\n两个非常有用的资源可以帮助你全面了解 ggplot2 的完整功能，分别是 ggplot2 速查表（你可以在https://posit.co/resources/cheatsheets找到）和 ggplot2 包网站（https://ggplot2.tidyverse.org./)）。\n你应该从本章中学到的一个重要教训是，当你觉得需要 ggplot2 没有提供的 geom 时，最好先查看是否有人已经通过创建提供该 geom 的 ggplot2 扩展包来解决了你的问题。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "EDA.html",
    "href": "EDA.html",
    "title": "10  探索性数据分析",
    "section": "",
    "text": "10.1 引言\n本章将向你展示如何系统地使用可视化和转换来探索数据，这项任务被统计学家称为探索性数据分析（Exploratory Data Analysis，简称EDA）。E DA是一个迭代循环的过程。你 需要：\nEDA并不是一个有着严格规则的正式流程，其更多的是一种思维方式。在 EDA的初始阶段，你应该自由地调查任何出现在你脑海中的想法。这 些想法中的一些会成功，而一些则会是死胡同。随 着你的探索继续，你将专注于一些特别有效的见解，并最终将其记录下来并与他人交流。\nEDA是任何数据分析的重要组成部分，即使主要的研究问题已经被直接提出，因为你总是需要调查你的数据质量。数 据清洗只是EDA的一个应用：你问的问题是数据是否符合你的期望。为 了进行数据清洗，你需要运用EDA的所有工具：可视化、转换和建模。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "EDA.html#引言",
    "href": "EDA.html#引言",
    "title": "10  探索性数据分析",
    "section": "",
    "text": "对你的数据产生疑问。\n通过数据可视化、转换和建模来寻找答案。\n利用所学的知识来完善你的问题或者产生新的问题。\n\n\n\n\n10.1.1 必要条件\n在本章中，我们将结合你学到的关于dplyr和ggplot2的知识，以交互的方式提出问题，用数据来回答问题，然后提出新的问题。\n\nlibrary(tidyverse)",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "EDA.html#问题",
    "href": "EDA.html#问题",
    "title": "10  探索性数据分析",
    "section": "10.2 问题",
    "text": "10.2 问题\n\n“没有常规的统计问题，只有可疑的统计常规。” — Sir David Cox\n\n\n“一个对正确问题的近似答案（这个问题常常是模糊的）远胜于一个对错误问题的精确答案（这个问题总是可以精确化的）。” — John Tukey\n\n在EDA期间，你的目标是了解你的数据。要 做到这一点，最简单的方法是将问题作为工具来指导你的调查。当 你提出一个问题时，这个问题会将你的注意力集中在数据集的特定部分上，并帮助你决定制作哪些图形、模型或转换。\nEDA本质上是一个创造性的过程。和 大多数创造性过程一样，提出高质量问题的关键是生成大量问题。在 你的分析开始时，很难提出有启示性的问题，因为你不知道可以从数据集中获取哪些见解。另 一方面，你提出的每一个新问题都会让你了解数据的一个新方面，并增加你发现新事物的机会。如 果你根据所发现的内容，针对每个问题都提出一个新问题，你就能迅速深入数据中最有趣的部分，并开发出一系列引人深思的问题。\n没有规定你应该提出哪些问题来指导你的研究。然 而，两种类型的问题始终有助于在你的数据中发现新事物。你 可以大致地将这些问题表述为：\n\n我的变量中存在什么类型的变异？\n我的变量之间存在什么类型的协变？\n\n本章的其余部分将探讨这两个问题。我 们将解释什么是变异和协变，并向你展示几种回答问题的方法。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "EDA.html#变异",
    "href": "EDA.html#变异",
    "title": "10  探索性数据分析",
    "section": "10.3 变异",
    "text": "10.3 变异\n变异（variation）是指变量的值从一次测量到另一次测量时发生变化的趋势。在 现实生活中，你很容易看到变异；如果你对任何连续变量进行两次测量，你会得到两个不同的结果。即 使你测量的是像光速这样的常量，也是如此。你 的每次测量都会包含一定量的误差，这些误差会随着测量的不同而有所变化。变 量也可能因为测量对象的不同（例如，不同人的眼睛颜色）或时间的不同（例如，电子在不同时刻的能量水平）而发生变化。每 个变量都有自己特有的变异模式，这些模式可以揭示出关于该变量在同一观测值的不同测量之间以及不同观测值之间的有趣信息。理 解这种模式的最好方法是可视化变量的值分布，这是你在 章节 1 中已经学过的内容。\n我们将通过可视化diamonds数据集中约54,000颗钻石的重量（carat）分布来开始我们的探索。由 于carat是一个数值变量，我们可以使用直方图来表示。\n\nggplot(diamonds, aes(x = carat)) +\n  geom_histogram(binwidth = 0.5)\n\n\n\n\n\n\n\n\n既然你现在可以可视化变异了，你应该在你的图中寻找什么？你 应该提出什么类型的后续问题？我 们已经在下方列出了你在图形中最有用的信息类型，并为每种类型的信息提供了一些后续问题。提 出好的后续问题的关键在于依靠你的好奇心（你想更多了解什么？）和怀疑精神（这可能会误导人吗？）。\n\n10.3.1 典型值\n在条形图和直方图中，高的条形代表变量的常见值，较短的条形代表不太常见的值。没 有条形的地方表示在您的数据中未看到的值。为 了将这些信息转化为有用的问题，请寻找任何出乎意料的东西：\n\n哪些值是最常见的？为什么？\n哪些值是罕见的？为什么？这符合你的预期吗？\n你是否看到任何不寻常的模式？可能是什么原因导致的？\n\n让我们看一下较小钻石的carat分布。\n\nsmaller &lt;- diamonds |&gt; \n  filter(carat &lt; 3)\n\nggplot(smaller, aes(x = carat)) +\n  geom_histogram(binwidth = 0.01)\n\n\n\n\n\n\n\n\n这个直方图提出了几个有趣的问题：\n\n为什么整克拉和常见的小数克拉的钻石更多？\n为什么每个峰值右侧的钻石比左侧的稍微多一些？\n\n可视化图表还可以揭示集群，这表明你的数据中存在子组。为 了理解这些子组，请问：\n\n每个子组内的观测值如何相互相似？\n不同集群中的观测值如何相互不同？\n你如何解释或描述这些集群？\n为什么集群的出现可能会产生误导？\n\n其中一些问题可以用数据来回答，而一些问题则需要关于数据的领域专业知识。许 多问题将促使你探索变量之间的关系，例如，查看一个变量的值是否可以解释另一个变量的行为。我 们稍后会讲到这一点。\n\n\n10.3.2 异常值\n异常值是不寻常的观测值；它们是似乎不符合模式的数据点。有 时异常值是数据输入错误，有时它们只是在这组数据收集中偶然观察到的极端值，而其他时候它们可能暗示着重要的新发现。当 你拥有大量数据时，有时在直方图中很难看到异常值。例 如，查看钻石数据集中y变量的分布。异 常值存在的唯一证据是x轴上异常宽的界限。\n\nggplot(diamonds, aes(x = y)) + \n  geom_histogram(binwidth = 0.5)\n\n\n\n\n\n\n\n\n在常见的数值范围（箱子）中有许多观测值，这使得罕见的数值范围（箱子）非常短，因此很难看到它们（尽管也许如果你紧盯着 y 轴的 0 点仔细看，会发现点什么）。为 了更容易地看到异常值，我们需要使用coord_cartesian()函数将 y 轴缩放到较小的值域范围。\n\nggplot(diamonds, aes(x = y)) + \n  geom_histogram(binwidth = 0.5) +\n  coord_cartesian(ylim = c(0, 50))\n\n\n\n\n\n\n\n\ncoord_cartesian()还有一个xlim()参数，当你需要放大 x 轴时可以使用它。g gplot2同样有xlim()和ylim()函数，但它们的工作方式略有不同：它们会丢弃超出限制范围的数据。\n这使得我们能够看到有三个异常值：0，~30和~60。我 们使用dplyr将它们筛选出来。\n\nunusual &lt;- diamonds |&gt; \n  filter(y &lt; 3 | y &gt; 20) |&gt; \n  select(price, x, y, z) |&gt;\n  arrange(y)\nunusual\n#&gt; # A tibble: 9 × 4\n#&gt;   price     x     y     z\n#&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  5139  0      0    0   \n#&gt; 2  6381  0      0    0   \n#&gt; 3 12800  0      0    0   \n#&gt; 4 15686  0      0    0   \n#&gt; 5 18034  0      0    0   \n#&gt; 6  2130  0      0    0   \n#&gt; 7  2130  0      0    0   \n#&gt; 8  2075  5.15  31.8  5.12\n#&gt; 9 12210  8.09  58.9  8.06\n\ny 变量测量的是这些钻石的三个维度之一，单位为毫米。我 们知道钻石的宽度不可能为 0 毫米，所以这些值一定是错误的。通 过进行探索性数据分析（EDA），我们发现了被编码为 0 的缺失数据，而我们仅仅通过搜索 NAs 是无法发现这些数据的。接 下来，我们可能会选择将这些值重新编码为 NAs，以防止误导性的计算。我 们也可能怀疑 32 毫米和 59 毫米的测量值是不合理的：这些钻石的长度超过了一英寸，但价格并没有达到数万美元！\n一个好的做法是在包含和不包含异常值的情况下重复你的分析。如 果它们对结果的影响很小，而且你无法确定它们出现的原因，那么忽略它们并继续分析是合理的。然 而，如果它们对你的结果有重大影响，你不应该没有理由就删除它们。你 需要找出导致它们出现的原因（例如数据输入错误），并在你的报告中披露你已经删除了这些值。\n\n\n10.3.3 练习\n\n探索diamonds数据集中变量 x、y 和 z 的分布。你 发现了什么？想 象一下钻石，并思考你如何决定哪个维度是长度、宽度和深度。\n探索price的分布。你 是否发现了任何不寻常或令人惊讶的事情？（ 提示：仔细考虑binwidth，并确保你尝试了一系列不同的值。）\n0.99 克拉的钻石有多少颗？1 克拉的钻石有多少颗？你 认为这种差异的原因是什么？\n在直方图上放大时，比较coord_cartesian()和xlim()或ylim()的区别。如 果你没有设置binwidth会发生什么？如 果你尝试缩放到只显示半根柱子时会发生什么？",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "EDA.html#sec-unusual-values-eda",
    "href": "EDA.html#sec-unusual-values-eda",
    "title": "10  探索性数据分析",
    "section": "10.4 异常值",
    "text": "10.4 异常值\n如果你在数据集中遇到了异常值，并且只是想继续剩余分析，那么你有两个选择。\n\n删除包含异常值的整行：\n\ndiamonds2 &lt;- diamonds |&gt; \n  filter(between(y, 3, 20))\n\n我们不推荐这个选项，因为一个无效的值并不意味着该观测值的其他所有值也都是无效的。此 外，如果你的数据质量较低，当你将这种方法应用于每个变量时，你可能会发现你没有留下任何数据！\n相反，我们建议将异常值替换为缺失值。最 简单的方法是使用mutate()来替换变量的一个修改后的副本。你 可以使用if_else()函数将异常值替换为 NA：\n\ndiamonds2 &lt;- diamonds |&gt; \n  mutate(y = if_else(y &lt; 3 | y &gt; 20, NA, y))\n\n\n在图中绘制缺失值并不合理，因此ggplot2不会将它们包含在图中，但会发出警告，说明这些值已被移除：\n\nggplot(diamonds2, aes(x = x, y = y)) + \n  geom_point()\n#&gt; Warning: Removed 9 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n\n\n\n\n\n\n\n要阻止该警告，请设置 na.rm = TRUE:\n\nggplot(diamonds2, aes(x = x, y = y)) + \n  geom_point(na.rm = TRUE)\n\n有时你想了解包含缺失值的观测与包含记录值的观测之间有何不同。例 如，在nycflights13::flights1数据集中，dep_time变量中的缺失值表示航班被取消。 因此，你可能想要比较取消航班和未取消航班的计划起飞时间。 可以通过创建一个新变量来实现这一点，使用is.na()函数来检查dep_time是否缺失。\n\nnycflights13::flights |&gt; \n  mutate(\n    cancelled = is.na(dep_time),\n    sched_hour = sched_dep_time %/% 100,\n    sched_min = sched_dep_time %% 100,\n    sched_dep_time = sched_hour + (sched_min / 60)\n  ) |&gt; \n  ggplot(aes(x = sched_dep_time)) + \n  geom_freqpoly(aes(color = cancelled), binwidth = 1/4)\n\n\n\n\n\n\n\n\n然而这个图并不太好，因为未取消的航班比已取消的航班多得多。在 下一节中，我们将探索一些技术来改进这种比较。\n\n10.4.1 练习\n\n直方图中缺失值会发生什么？条 形图中缺失值会发生什么？为 什么直方图和条形图中缺失值的处理方式不同？\n在mean()和sum()函数中，na.rm = TRUE的作用是什么？\n重新创建按航班是否被取消着色的scheduled_dep_time的频数图。同 时根据cancelled变量进行分面。在 分面函数中尝试使用scales变量的不同值，以减轻未取消航班多于取消航班的影响。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "EDA.html#协变covariation",
    "href": "EDA.html#协变covariation",
    "title": "10  探索性数据分析",
    "section": "10.5 协变（covariation）",
    "text": "10.5 协变（covariation）\n如果变异描述了一个变量内部的行为，那么协变描述了变量之间的行为。协 变是两个或多个变量的值以相关的方式一起变化的趋势。发 现协变的最佳方法是可视化两个或多个变量之间的关系。\n\n10.5.1 一个分类变量和一个数值变量\n例如，使用geom_freqpoly()来探索钻石的价格如何随其质量(cut)的变化而变化:\n\nggplot(diamonds, aes(x = price)) + \n  geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)\n\n\n\n\n\n\n\n\n请注意，ggplot2为cut使用了有序的颜色刻度，因为它在数据中定义为有序因子变量。你 将在 小节 16.6 中学到更多关于它的知识。\ngeom_freqpoly()的默认外观在这里并不那么有用，因为由总计数确定的高度在各个cut之间差异很大，使得难以看出它们分布形状的差异。\n为了使比较更容易，我们需要交换 y 轴上的显示内容。我 们不显示计数，而是显示密度（density），密度是标准化的计数，使得每个频率多边形的面积都为1。\n\nggplot(diamonds, aes(x = price, y = after_stat(density))) + \n  geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)\n\n\n\n\n\n\n\n\n请注意，我们正在将density 映射到y轴上，但由于density 不是diamonds数据集中的变量，首先需要计算它。我 们使用after_stat()函数来完成这一操作。\n这个图有一个相当令人惊讶的地方——看起来质量一般的钻石（即最低质量）的平均价格最高！但 也许这是因为频数多边形图有点难以解读，这个图中有很多内容。\n探索这种关系的一种视觉上更简单的方法是使用并排箱线图。\n\nggplot(diamonds, aes(x = cut, y = price)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n关于分布的信息我们看到的要少得多，但箱线图更加紧凑，因此我们可以更容易地比较它们（并且可以在一个图上展示更多）。这 支持了一个反直觉的发现，即更高质量的钻石通常更便宜！在 练习中，你将面临的挑战是找出为什么。\ncut是一个有序因子：fair（一般）比 good（良好）差，good（良好）比 very good（很好）差，依此类推。许 多分类变量并没有这样的内在顺序，因此你可能希望重新排序它们以创建更具信息量的显示。一 种方法是使用fct_reorder()函数，你将在 小节 16.4 中了解该函数的更多信息，但因为我们觉得它非常有用，所以想在这里给你一个快速的预览。例 如，考虑mpg数据集中的class变量。你 可能想知道不同类别之间的公路里程是如何变化的：\n\nggplot(mpg, aes(x = class, y = hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n为了使趋势更容易看到，我们根据hwy的中位数对class重新排序:\n\nggplot(mpg, aes(x = fct_reorder(class, hwy, median), y = hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n如果你的变量名很长，那么将geom_boxplot()旋转 90° 将会更易于阅读。你 可以通过交换 x 和 y 的美学映射来实现这一点。\n\nggplot(mpg, aes(x = hwy, y = fct_reorder(class, hwy, median))) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n10.5.1.1 练习\n\n利用你学到的知识来改进取消航班与非取消航班起飞时间的可视化。\n基于EDA，diamonds数据集中哪个变量看起来对预测钻石的价格最重要？这 个变量与切割方式（cut）是如何相关的？为 什么这两个关系的组合会导致低质量的钻石更昂贵？\n不交换 x 和 y 变量，而是在垂直箱线图中添加coord_flip()作为新层来创建水平箱线图。这 与交换变量有何不同？\n箱线图的一个问题是它们在数据量较小的时期开发，往往会显示过多的“异常值”。一 种解决这个问题的方法是使用字母值图。安 装 lvplot 包，并尝试使用geom_lv()来显示price与cut的分布。你 学到了什么？你 如何解释这些图？\n使用geom_violin()创建钻石价格与钻石数据集中一个分类变量的可视化，然后使用分面的geom_histogram()，然后是着色的geom_freqpoly()，最后是着色的geom_density()。比 较和对比这四种图。根 据分类变量的水平可视化数值变量分布的每种方法各有什么优缺点？\n如果你有一个小型数据集，有时使用geom_jitter()来避免过度绘图是很有用的，这样可以更容易地看到连续变量和分类变量之间的关系。g gbeeswarm 包提供了多种与geom_jitter()类似的方法。列 出它们并简要描述每种方法的作用。\n\n\n\n\n10.5.2 两个分类变量\n为了可视化分类变量之间的协变关系，你需要计算这些分类变量每个水平组合的观察数。一 种方法是依赖内置的geom_count()函数：\n\nggplot(diamonds, aes(x = cut, y = color)) +\n  geom_count()\n\n\n\n\n\n\n\n\n图中的每个圆圈的大小显示了每个值组合出现了多少次观测。协 变将表现为特定x值和特定y值之间的强相关性。\n探索这些变量之间关系的另一种方法是使用dplyr来计算计数：\n\ndiamonds |&gt; \n  count(color, cut)\n#&gt; # A tibble: 35 × 3\n#&gt;   color cut           n\n#&gt;   &lt;ord&gt; &lt;ord&gt;     &lt;int&gt;\n#&gt; 1 D     Fair        163\n#&gt; 2 D     Good        662\n#&gt; 3 D     Very Good  1513\n#&gt; 4 D     Premium    1603\n#&gt; 5 D     Ideal      2834\n#&gt; 6 E     Fair        224\n#&gt; # ℹ 29 more rows\n\n然后使用geom_tile()和填充美学进行可视化:\n\ndiamonds |&gt; \n  count(color, cut) |&gt;  \n  ggplot(aes(x = color, y = cut)) +\n  geom_tile(aes(fill = n))\n\n\n\n\n\n\n\n\n如果分类变量是无序的，你可能想要使用seriation包来同时重新排序行和列，以便更清楚地揭示有趣的模式。对 于较大的图形，你可能想要尝试heatmaply包，它创建交互式图形。\n\n10.5.2.1 练习\n\n如何重新缩放上面的计数数据集，以更清楚地显示color中的cut分布，或cut中的color分布？\n如果color映射到x美学，cut映射到fill美学，使用分段条形图你能得到哪些不同的数据见解？计 算每个分段中的计数。\n使用geom_tile()结合dplyr来探索平均航班起飞延误如何因目的地和年份月份而异。这 个图为什么难以阅读？你 如何改进它？\n\n\n\n\n10.5.3 两个数值变量\n你已经看到了可视化两个数值变量之间协变关系的一种好方法：使用geom_point()绘制散点图。你 可以在点的模式中看到协变关系。例 如，你可以看到钻石的克拉大小与其价格之间的正相关关系：克拉数越多的钻石价格越高。这 种关系是呈指数型的。\n\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_point()\n\n\n\n\n\n\n\n\n(在本节中，我们将使用smaller数据集来重点关注克拉数小于3的钻石)\n随着数据集大小的增加，散点图变得不那么有用，因为点开始重叠并堆积成均匀的黑色区域，这使得难以判断二维空间中数据密度的差异，也难以发现趋势。你 已经看到了一种解决问题的方法：使用alpha美学属性来增加透明度。\n\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_point(alpha = 1 / 100)\n\n\n\n\n\n\n\n\n但是，对于非常大的数据集，使用透明度可能会很有挑战性。另 一种解决方案是使用分组（bin）。之 前您使用geom_histogram()和geom_freqpoly()在一维中进行分组。现 在您将学习如何使用geom_bin2d()和geom_hex()在二维中进行分组。\ngeom_bin2d()和geom_hex()将坐标平面划分为二维的分组（bins），然后使用填充颜色来表示每个分组中有多少点。g eom_bin2d()创建矩形的分组。g eom_hex()创建六边形的分组。要 使用geom_hex()，您需要安装hexbin包。\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_bin2d()\n\n# install.packages(\"hexbin\")\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_hex()\n\n\n\n\n\n\n\n\n\n\n另一种选择是将一个连续变量进行分组，使其表现得像一个分类变量。然 后，您可以使用您学过的用于可视化分类变量和连续变量组合的技术之一。例 如，您可以对carat 进行分组，然后为每个组显示一个箱线图：\n\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_boxplot(aes(group = cut_width(carat, 0.1)))\n\n\n\n\n\n\n\n\n上面使用cut_width(x, width)将 x 分成宽度为 width 的分组。默 认情况下，无论观测的数量如何，箱线图看起来大致相同（除了异常值的数量），因此很难看出每个箱线图汇总了不同数量的点。一 种表示这种差异的方法是让箱线图的宽度与点的数量成比例，这通过设置varwidth = TRUE来实现。\n\n10.5.3.1 练习\n\n除了使用箱线图来总结条件分布外，你还可以使用频数多边形。在 使用cut_width()和cut_number()时需要考虑什么？这 对可视化carat和price的二维分布有什么影响？\n可视化根据price划分的carat分布。\n非常大的钻石的价格分布与小钻石的价格分布相比如何？是 否符合你的预期，还是让你感到惊讶？\n结合你学过的两种技术来可视化cut、carat和price的联合分布。\n二维图可以揭示一维图中不可见的异常值。例 如，以下图中的某些点具有不寻常的 x 和 y 值组合，即使分别查看这些点的 x 和 y 值时看起来是正常的，也使得这些点成为异常值。为 什么在这种情况下散点图是比分组图更好的展示方式？\n\ndiamonds |&gt; \n  filter(x &gt;= 4) |&gt; \n  ggplot(aes(x = x, y = y)) +\n  geom_point() +\n  coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))\n\n使用cut_number()创建包含大致相等数量点的分组，而不是使用cut_width()创建等宽度的分组。这 种方法的优点和缺点是什么？\n\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_boxplot(aes(group = cut_number(carat, 20)))",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "EDA.html#模式与模型",
    "href": "EDA.html#模式与模型",
    "title": "10  探索性数据分析",
    "section": "10.6 模式与模型",
    "text": "10.6 模式与模型\n如果两个变量之间存在系统关系，它将在数据中呈现为一种模式。如 果你发现一个模式，问问自己：\n\n这个模式是否可能是巧合（即随机机会）？\n你如何描述这个模式所暗示的关系？\n这个模式所暗示的关系有多强？\n还有哪些其他变量可能会影响这种关系？\n如果你查看数据的各个子组，这种关系会发生变化吗？\n\n数据中的模式提供了关于关系的线索，即它们揭示了协变。如 果你把变化看作是一种产生不确定性的现象，那么协变就是一种减少这种不确定性的现象。如 果两个变量协变，你可以利用一个变量的值来更好地预测第二个变量的值。如 果协变是由因果关系（一个特殊情况）引起的，那么你可以用一个变量的值来控制第二个变量的值。\n模型是从数据中提取模式的工具。例 如，考虑钻石数据，很难理解切工和价格之间的关系，因为切工和克拉数，以及克拉数和价格之间存在紧密关系。我 们可以使用模型来消除价格和克拉数之间的非常强的关系，以便我们可以探索剩余的细微差别。以 下代码拟合了一个从carat预测price的模型，然后计算残差（预测值与实际值之间的差异）。一 旦去除了克拉数的影响，残差就给了我们钻石价格的一个视图。请 注意，我们不是直接使用price和carat的原始值，而是首先对它们进行对数转换，并对对数转换后的值拟合模型。然 后，我们对残差进行指数化，以将其重新放入原始价格的尺度上。\n\nlibrary(tidymodels)\n\ndiamonds &lt;- diamonds |&gt;\n  mutate(\n    log_price = log(price),\n    log_carat = log(carat)\n  )\n\ndiamonds_fit &lt;- linear_reg() |&gt;\n  fit(log_price ~ log_carat, data = diamonds)\n\ndiamonds_aug &lt;- augment(diamonds_fit, new_data = diamonds) |&gt;\n  mutate(.resid = exp(.resid))\n\nggplot(diamonds_aug, aes(x = carat, y = .resid)) + \n  geom_point()\n\n\n\n\n\n\n\n\n一旦消除了克拉数和价格之间的强关系，你就可以看到切工和价格之间的关系是你所预期的：相对于它们的大小，质量好的钻石更昂贵。\n\nggplot(diamonds_aug, aes(x = cut, y = .resid)) + \n  geom_boxplot()\n\n\n\n\n\n\n\n\n本书并未讨论建模，因为一旦你掌握了数据处理和编程的工具，理解模型是什么以及它们是如何工作的就会变得更加容易。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "EDA.html#小结",
    "href": "EDA.html#小结",
    "title": "10  探索性数据分析",
    "section": "10.7 小结",
    "text": "10.7 小结\n在这一章中，你学习了多种工具来帮助你理解数据中的变化。你 已经看到了针对单个变量和变量对的技术。如 果你的数据中有数十个或数百个变量，这些技术可能看起来非常有限，但它们是所有其他技术的基础。\n在下一章中，我们将专注于可以用来交流结果的工具。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "EDA.html#footnotes",
    "href": "EDA.html#footnotes",
    "title": "10  探索性数据分析",
    "section": "",
    "text": "记住，当我们需要明确指出一个函数（或数据集）来自哪个包时，我们会使用特殊的形式package::function()或package::dataset。↩︎",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "communication.html",
    "href": "communication.html",
    "title": "11  交流",
    "section": "",
    "text": "11.1 引言\n在 章节 10 中，你学习了如何将图形用作探索工具。当 你制作探索性图形时，你甚至在查看之前就知道图中将显示哪些变量。你 为了某个目的制作每个图形，可以快速查看它，然后移至下一个图形。在 大多数分析过程中，你会生成数十个或数百个图形，其中大多数会立即被丢弃。\n现在你理解了你的数据，你需要将你的理解与他人交流。你 的听众可能不具备你的背景知识，也不会对数据投入太多关注。为 了帮助其他人快速建立对数据的良好心理模型，你需要在使图形尽可能具有自解释性方面投入大量努力。在 本章中，你将学习ggplot2提供的一些工具来做到这一点。\n本章重点关注创建良好图形所需的工具。我 们假设你知道你想要什么，只是需要知道如何去做。因 此，我们强烈建议将本章与一本优秀的通用可视化书籍结合使用。我 们特别喜欢Albert Cairo的《The Truthful Art》。这 本书不教授创建可视化的机制，而是专注于你需要考虑的内容以创建有效的图形。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>交流</span>"
    ]
  },
  {
    "objectID": "communication.html#引言",
    "href": "communication.html#引言",
    "title": "11  交流",
    "section": "",
    "text": "11.1.1 必要条件\n在本章中我们将再次专注于ggplot2。我 们还将使用dplyr进行一些数据操作，使用scales来覆盖默认的刻度、标签、变换和调色板，以及一些ggplot2的扩展包，包括Kamil Slowikowski的ggrepel（https://ggrepel.slowkow.com）和Thomas Lin Pedersen的patchwork（https://patchwork.data-imaginist.com）。如 果你还没有这些包，别忘了使用install.packages()来安装它们。\n\nlibrary(tidyverse)\nlibrary(scales)\nlibrary(ggrepel)\nlibrary(patchwork)",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>交流</span>"
    ]
  },
  {
    "objectID": "communication.html#标签",
    "href": "communication.html#标签",
    "title": "11  交流",
    "section": "11.2 标签",
    "text": "11.2 标签\n将探索性图形转换为说明性图形的最简单起点是使用好的标签。你 可以使用labs()函数来添加标签。\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  labs(\n    x = \"Engine displacement (L)\",\n    y = \"Highway fuel economy (mpg)\",\n    color = \"Car type\",\n    title = \"Fuel efficiency generally decreases with engine size\",\n    subtitle = \"Two seaters (sports cars) are an exception because of their light weight\",\n    caption = \"Data from fueleconomy.gov\"\n  )\n\n\n\n\n\n\n\n\n图形的标题（title）是为了概括主要发现，避免仅描述图形内容的标题，例如“发动机排量和燃油经济性的散点图形”。\n如果你需要添加更多文本，还有另外两个有用的标签：副标题（subtitle）以较小的字体在标题下方添加更多细节，而图注（caption）在图形的右下角添加文本，通常用于描述数据的来源。你 还可以使用labs()函数来替换轴和图例的标题。通 常，最好将简短的变量名替换为更详细的描述，并包含单位。\n可以使用数学方程代替文本字符串。只 需将\"\"替换为quote()，并查阅?plotmath中关于可用选项的信息。\n\ndf &lt;- tibble(\n  x = 1:10,\n  y = cumsum(x^2)\n)\n\nggplot(df, aes(x, y)) +\n  geom_point() +\n  labs(\n    x = quote(x[i]),\n    y = quote(sum(x[i] ^ 2, i == 1, n))\n  )\n\n\n\n\n\n\n\n\n\n11.2.1 练习\n\n创建一个包含自定义标题、副标题、图注、x轴、y轴和颜色标签的关于燃油经济数据的图形。C reate one plot on the fuel economy data with customized title, subtitle, caption, x, y, and color labels.\n使用燃油经济数据重新创建以下图形。请 注意，点和形状的颜色根据传动系统的类型而变化。\n\n\n\n\n\n\n\n\n\n选择你在过去一个月内创建的一个探索性图形，并添加有信息量的标题，以便其他人更容易理解。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>交流</span>"
    ]
  },
  {
    "objectID": "communication.html#注释",
    "href": "communication.html#注释",
    "title": "11  交流",
    "section": "11.3 注释",
    "text": "11.3 注释\n除了标记图形的主要组件之外，标记单个观测或观测组通常也很有用。你 可以使用的第一个工具是geom_text()。g eom_text()类似于geom_point()，但它有一个额外的美学属性：label。这 使得在你的图形中添加文本标签成为可能。\n标签的来源有两种可能。首 先，你可能有一个提供标签的tibble。在 下面的图形中，我们提取了每种驱动类型中发动机尺寸最大的汽车，并将它们的信息保存为一个名为label_info的新数据框。\n\nlabel_info &lt;- mpg |&gt;\n  group_by(drv) |&gt;\n  arrange(desc(displ)) |&gt;\n  slice_head(n = 1) |&gt;\n  mutate(\n    drive_type = case_when(\n      drv == \"f\" ~ \"front-wheel drive\",\n      drv == \"r\" ~ \"rear-wheel drive\",\n      drv == \"4\" ~ \"4-wheel drive\"\n    )\n  ) |&gt;\n  select(displ, hwy, drv, drive_type)\n\nlabel_info\n#&gt; # A tibble: 3 × 4\n#&gt; # Groups:   drv [3]\n#&gt;   displ   hwy drv   drive_type       \n#&gt;   &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;            \n#&gt; 1   6.5    17 4     4-wheel drive    \n#&gt; 2   5.3    25 f     front-wheel drive\n#&gt; 3   7      24 r     rear-wheel drive\n\n然后，我们使用这个新的数据框直接标记这三个组，用直接放在图形上的标签替换图例。通 过使用fontface和size参数，我们可以自定义文本标签的外观。它 们比图形上其余文本的字体更大且加粗。（ theme(legend.position = \"none\" 会关闭所有图例，我们稍后会详细讨论它。）\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(se = FALSE) +\n  geom_text(\n    data = label_info, \n    aes(x = displ, y = hwy, label = drive_type),\n    fontface = \"bold\", size = 5, hjust = \"right\", vjust = \"bottom\"\n  ) +\n  theme(legend.position = \"none\")\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n请注意使用hjust（水平对齐）和vjust（垂直对齐）来控制标签的对齐方式。\n但是，我们上面制作的带有注释的图形很难阅读，因为标签相互重叠，并且与点重叠。我 们可以使用ggrepel包中的geom_label_repel()函数来解决这两个问题。这 个包会自动调整标签的位置，以避免它们重叠：\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(se = FALSE) +\n  geom_label_repel(\n    data = label_info, \n    aes(x = displ, y = hwy, label = drive_type),\n    fontface = \"bold\", size = 5, nudge_y = 2\n  ) +\n  theme(legend.position = \"none\")\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n你还可以使用相同的方法来突出显示ggrepel包中geom_text_repel()函数在图形上的某些点。请 注意这里使用的另一个实用的技巧：我们添加了一层大且空心的点作为第二层，以进一步突出显示带有标签的点。\n\npotential_outliers &lt;- mpg |&gt;\n  filter(hwy &gt; 40 | (hwy &gt; 20 & displ &gt; 5))\n  \nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_text_repel(data = potential_outliers, aes(label = model)) +\n  geom_point(data = potential_outliers, color = \"red\") +\n  geom_point(\n    data = potential_outliers,\n    color = \"red\", size = 3, shape = \"circle open\"\n  )\n\n\n\n\n\n\n\n\n请记住，除了geom_text()和geom_label()之外，ggplot2中还有许多其他geoms可用于帮助你注释你的图形。这 里有几个想法：\n\n使用geom_hline()和geom_vline()来添加参考线。我 们经常使它们加粗（linewidth = 2）和为白色（color = white），并在主要数据层下面绘制它们。这 使得它们易于查看，而不会分散对数据的注意力。\n使用geom_rect()在感兴趣的点上画一个矩形。矩 形的边界由美学属性xmin, xmax, ymin, ymax定义。另 外，请查看ggforce包，特别是geom_mark_hull()，它允许你使用凸包来注释点的子集。\n使用带有arrow参数的geom_segment()来用箭头吸引对某个点的注意。使 用美学属性x和y定义起始位置，使用xend和yend定义结束位置。\n\n另一个用于向图形添加注释的实用函数是annotate()。作 为一般规则，geoms通常用于突出显示数据的一个子集，而annotate()则用于向图形添加一个或少数几个注释元素。\n为了演示如何使用annotate()，让我们创建一些文本并将其添加到我们的图形中。文 本有点长，所以我们将使用stringr::str_wrap()来根据每行所需的字符数自动添加换行符：\n\ntrend_text &lt;- \"Larger engine sizes tend to have lower fuel economy.\" |&gt;\n  str_wrap(width = 30)\ntrend_text\n#&gt; [1] \"Larger engine sizes tend to\\nhave lower fuel economy.\"\n\n然后，我们添加两层注释：一层使用标签geom，另一层使用线段geom。两 者中的x和y美学属性定义了注释应该从哪里开始，而线段注释中的xend和yend美学属性定义了线段的结束位置。还 请注意，线段被设置为箭头的样式。\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  annotate(\n    geom = \"label\", x = 3.5, y = 38,\n    label = trend_text,\n    hjust = \"left\", color = \"red\"\n  ) +\n  annotate(\n    geom = \"segment\",\n    x = 3, y = 35, xend = 5, yend = 25, color = \"red\",\n    arrow = arrow(type = \"closed\")\n  )\n\n\n\n\n\n\n\n\n注释是一种强大的工具，用于交流你的可视化的主要内容和有趣特性。唯 一的限制是你的想象力（以及你耐心地调整注释位置以达到美观的耐心）！\n\n11.3.1 练习\n\n使用geom_text()并通过设置接近边界的坐标值来在图的四个角落放置文本。\n使用annotate()在最后一个图的中心添加一个点，而无需创建一个tibble。自 定义点的形状、大小或颜色。\ngeom_text()中的标签是如何与分面交互的？你 如何给单个分面添加一个标签？你 如何在每个分面中添加不同的标签？（ 提示：考虑传递给geom_text()的数据集）\ngeom_label()的哪些参数控制背景框的外观？\narrow()函数的四个参数是什么？它 们是如何工作的？创 建一系列图表来展示最重要的选项。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>交流</span>"
    ]
  },
  {
    "objectID": "communication.html#比例尺",
    "href": "communication.html#比例尺",
    "title": "11  交流",
    "section": "11.4 比例尺",
    "text": "11.4 比例尺\n使图形更易于传达信息的第三种方法是调整比例尺。比 例尺控制着美学映射如何以视觉形式展现。\n\n11.4.1 默认比例尺\n通常，ggplot2 会自动为你添加比例尺。例 如，当你输入：\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class))\n\nggplot2 在后台自动添加默认比例尺:\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  scale_x_continuous() +\n  scale_y_continuous() +\n  scale_color_discrete()\n\n请注意比例尺的命名方案：以scale_开头，后面是美学的名称，然后是_，再然后是比例尺的名称。默 认的比例尺是根据它们与之对齐的变量类型来命名的：连续、离散、日期时间或日期。s cale_x_continuous()将displ的数值以连续的数字线形式放在 x 轴上，scale_color_discrete()为每种车型类别选择颜色，等等。下 面将介绍许多非默认的比例尺。\n默认的比例尺已经被精心选择，以便为广泛的输入提供良好的工作效果。然 而，你可能想要出于两个原因覆盖默认值：\n\n你可能想要调整默认比例尺的一些参数。这允许你做一些事情，比如改变轴上的刻度或图例上的键标签。\n你可能想要完全替换比例尺，并使用完全不同的算法。通常，由于你更了解数据，所以你可以做得比默认值更好。\n\n轴刻度和图例键\n轴和图例统称为“指南”。轴 用于 x 和 y 美学；图例用于其他所有内容。\n有两个主要参数影响轴上的刻度和图例上的键的外观：breaks 和 labels。b reaks 控制刻度的位置或与键关联的值。l abels 控制与每个刻度/键关联的文本标签。b reaks 的最常见用法是覆盖默认选择：\n\n\n11.4.2 轴刻度和图例键\n轴和图例统称为“指南”。轴 用于 x 和 y 美学；图例用于其他所有内容。\n有两个主要参数影响轴上的刻度和图例上的键的外观：breaks和labels。b reaks控制刻度的位置或与键关联的值。l abels控制与每个刻度/键关联的文本标签。b reaks的最常见用法是覆盖默认选择：\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_y_continuous(breaks = seq(15, 40, by = 5)) \n\n\n\n\n\n\n\n\n你可以以相同的方式使用labels（一个与breaks相同长度的字符向量），但你也可以将其设置为NULL以完全抑制标签的显示。这 在地图或发布图表时非常有用，因为在这些情况下你可能无法分享绝对数值。你 还可以使用breaks和labels来控制图例的外观。对 于分类变量的离散比例尺，labels可以是一个命名列表，其中列出了现有水平名称以及为它们指定的标签。\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous(labels = NULL) +\n  scale_y_continuous(labels = NULL) +\n  scale_color_discrete(labels = c(\"4\" = \"4-wheel\", \"f\" = \"front\", \"r\" = \"rear\"))\n\n\n\n\n\n\n\n\nlabels参数 scales包中的标签函数结合使用，还可用于将数字格式化为货币、百分比等。左 边的图形显示了使用label_dollar()的默认标签，它添加了美元符号和千位分隔符逗号。右 边的图形通过进一步定制，将美元值除以1,000并添加后缀“K”（代表“千”），以及添加自定义刻度。请 注意，breaks是基于数据的原始尺度。\n# Left\nggplot(diamonds, aes(x = price, y = cut)) +\n  geom_boxplot(alpha = 0.05) +\n  scale_x_continuous(labels = label_dollar())\n\n# Right\nggplot(diamonds, aes(x = price, y = cut)) +\n  geom_boxplot(alpha = 0.05) +\n  scale_x_continuous(\n    labels = label_dollar(scale = 1/1000, suffix = \"K\"), \n    breaks = seq(1000, 19000, by = 6000)\n  )\n\n\n\n\n\n\n\n\n\n\n另一个方便的标签函数是 label_percent():\n\nggplot(diamonds, aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"fill\") +\n  scale_y_continuous(name = \"Percentage\", labels = label_percent())\n\n\n\n\n\n\n\n\nbreaks的另一个用途是当你的数据点相对较少，并且希望准确地突出显示观测发生的位置时。例 如，这张图显示了每位美国总统任期的开始和结束时间。\n\npresidential |&gt;\n  mutate(id = 33 + row_number()) |&gt;\n  ggplot(aes(x = start, y = id)) +\n  geom_point() +\n  geom_segment(aes(xend = end, yend = id)) +\n  scale_x_date(name = NULL, breaks = presidential$start, date_labels = \"'%y\")\n\n\n\n\n\n\n\n\n请注意，对于breaks参数我们提取了start变量作为一个向量，即presidential$start，因为我们不能为这个参数进行美学映射。另 外请注意，对于日期和日期时间比例尺的breaks和labels的指定略有不同：\n\ndate_labels 需要一个格式规范，其形式与parse_datetime()相同。\ndate_breaks （这里未展示）需要一个字符串，如 “2 days” 或 “1 month”。\n\n\n\n11.4.3 图例布局\n你通常会使用breaks和labels来调整坐标轴。虽 然它们也适用于图例，但还有一些你更可能使用的其他技术。\n要控制图例的整体位置，你需要使用theme()设置。我 们将在本章末尾再次回到主题设置上，但简而言之，它们控制图中非数据部分的内容。主 题设置legend.position控制图例的绘制位置：\nbase &lt;- ggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class))\n\nbase + theme(legend.position = \"right\") # the default\nbase + theme(legend.position = \"left\")\nbase + \n  theme(legend.position = \"top\") +\n  guides(color = guide_legend(nrow = 3))\nbase + \n  theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(nrow = 3))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n如果你的图是短而宽的，可以将图例放在顶部或底部；如果它是高而窄的，可以将图例放在左侧或右侧。你 还可以使用legend.position = \"none\"来完全抑制图例的显示。\n要控制单个图例的显示，请使用guides()搭配guide_legend()或guide_colorbar()。以 下示例展示了两个重要的设置：使用nrow控制图例使用的行数，以及通过覆盖其中一个美学属性来使点变得更大。这 在你在图上使用低透明度（alpha）来显示许多点时特别有用。\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(nrow = 2, override.aes = list(size = 4)))\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n注意，guides()中的参数名称与美学名称相匹配，就像labs()一样。\n\n\n11.4.4 替换比例尺\n除了微调一些细节之外，你还可以完全替换比例尺。有 两种类型的比例尺你可能最想要替换：连续位置比例尺和颜色比例尺。幸 运的是，其他美学属性的原理都是一样的，所以一旦你掌握了位置和颜色，你就能迅速掌握其他比例尺的替换。\n绘制变量的变换是非常有用的。例 如，如果我们对钻石的重量（carat）和价格（price）进行对数变换，就能更容易地看到它们之间的精确关系：\n# Left\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_bin2d()\n\n# Right\nggplot(diamonds, aes(x = log10(carat), y = log10(price))) +\n  geom_bin2d()\n\n\n\n\n\n\n\n\n\n\n然而，这种变换的缺点是坐标轴现在被标记为变换后的值，这使得很难解读该图。与 其在美学映射中进行变换，我们可以选择在刻度上进行变换。从 视觉上看，两者是相同的，只是坐标轴是按照原始数据的比例尺进行标记的。\n\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_bin2d() + \n  scale_x_log10() + \n  scale_y_log10()\n\n\n\n\n\n\n\n\n另一个经常需要自定义的比例尺是颜色。默 认的分类比例尺会选择在色轮上均匀分布的颜色。一 个有用的替代方案是 ColorBrewer 比例尺，它经过人工调整以更好地适应患有常见色盲类型的人。下 面两个图看起来相似，但红色和绿色的色调差异足够大，以至于右边的点即使对于患有红绿色盲的人也能区分开来1。\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv))\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  scale_color_brewer(palette = \"Set1\")\n\n\n\n\n\n\n\n\n\n\n不要忘记提高可访问性的更简单的技术。如 果只有几种颜色，你可以添加一个冗余的形状映射。这 也有助于确保你的图形在黑白模式下也能被解读。\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv, shape = drv)) +\n  scale_color_brewer(palette = \"Set1\")\n\n\n\n\n\n\n\n\nColorBrewer 比例尺的文档可以在线查看，网址为https://colorbrewer2.org/ ，并通过 Erich Neuwirth 的 RColorBrewer 包在 R 中提供。@ fig-brewer 显示了所有调色板的完整列表。如 果你的分类值是有序的，或者有一个“中间值”，那么顺序（顶部）和发散（底部）调色板就特别有用。这 通常发生在你使用cut()函数将连续变量转换为分类变量时。\n\n\n\n\n\n\n\n\n图 11.1: All colorBrewer scales.\n\n\n\n\n\n当你有一个预定义的值与颜色之间的映射时，使用scale_color_manual()。例 如，如果我们将总统党派映射到颜色，我们希望使用标准的红色代表共和党，蓝色代表民主党。为 这些颜色赋值的一种方法是使用十六进制颜色代码：\n\npresidential |&gt;\n  mutate(id = 33 + row_number()) |&gt;\n  ggplot(aes(x = start, y = id, color = party)) +\n  geom_point() +\n  geom_segment(aes(xend = end, yend = id)) +\n  scale_color_manual(values = c(Republican = \"#E81B23\", Democratic = \"#00AEF3\"))\n\n\n\n\n\n\n\n\n对于连续颜色，可以使用内置的scale_color_gradient()或scale_fill_gradient()。如 果有一个发散的比例尺，你可以使用scale_color_gradient2()。这 允许你可以给正数和负数分配不同的颜色。有 时，当你想区分高于或低于平均值的点时，这也很有用。\n另一个选项是使用 viridis 颜色比例尺。其 设计者 Nathaniel Smith 和 Stéfan van der Walt 精心制作了连续的颜色方案，这些方案对于患有各种形式色盲的人以及在彩色和黑白模式下都是感知均匀的。这 些比例尺在 ggplot2 中作为连续（c）、离散（d）和分箱（b）调色板提供。\ndf &lt;- tibble(\n  x = rnorm(10000),\n  y = rnorm(10000)\n)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed() +\n  labs(title = \"Default, continuous\", x = NULL, y = NULL)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed() +\n  scale_fill_viridis_c() +\n  labs(title = \"Viridis, continuous\", x = NULL, y = NULL)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed() +\n  scale_fill_viridis_b() +\n  labs(title = \"Viridis, binned\", x = NULL, y = NULL)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n请注意，所有的颜色比例尺都有两种类型：scale_color_*()和scale_fill_*()，分别用于颜色和填充的美学（color scales 在英国和美国的拼写中都是可用的）。\n\n\n11.4.5 缩放\n控制图形的界限有三种方法：\n\n调整要绘制的数据。\n在每个比例尺中设置界限。\n在coord_cartesian()中设置xlim和ylim。\n\n我们将在一系列图形中演示这些选项。左 侧的图形显示了发动机大小和燃油效率之间的关系，并按驱动类型着色。右 侧的图表显示了相同的变量，但仅绘制了部分数据。子 集数据已经影响了 x 和 y 比例尺以及平滑曲线。\n# Left\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  geom_smooth()\n\n# Right\nmpg |&gt;\n  filter(displ &gt;= 5 & displ &lt;= 6 & hwy &gt;= 10 & hwy &lt;= 25) |&gt;\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  geom_smooth()\n\n\n\n\n\n\n\n\n\n\n让我们比较下面两个图形，其中左侧的图形在单个比例尺上设置了界限，而右侧的图形在coord_cartesian()中设置了界限。我 们可以看到，减少界限的效果相当于对数据进行了子集选择。因 此，为了放大图中的某个区域，通常最好使用coord_cartesian()。\n# Left\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  geom_smooth() +\n  scale_x_continuous(limits = c(5, 6)) +\n  scale_y_continuous(limits = c(10, 25))\n\n# Right\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  geom_smooth() +\n  coord_cartesian(xlim = c(5, 6), ylim = c(10, 25))\n\n\n\n\n\n\n\n\n\n\n另一方面，如果你想扩展界限，比如在不同的图形之间匹配比例尺，那么在单个比例尺上设置limits通常更有用。例 如，如果我们提取两类汽车并分别绘制它们，则很难比较这些图形，因为三个比例尺（x轴、y轴和颜色美学）的范围都不相同。\nsuv &lt;- mpg |&gt; filter(class == \"suv\")\ncompact &lt;- mpg |&gt; filter(class == \"compact\")\n\n# Left\nggplot(suv, aes(x = displ, y = hwy, color = drv)) +\n  geom_point()\n\n# Right\nggplot(compact, aes(x = displ, y = hwy, color = drv)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\n解决这个问题的一种方法是在多个图之间共享比例尺，并使用整个数据的limits来训练这些比例尺。\nx_scale &lt;- scale_x_continuous(limits = range(mpg$displ))\ny_scale &lt;- scale_y_continuous(limits = range(mpg$hwy))\ncol_scale &lt;- scale_color_discrete(limits = unique(mpg$drv))\n\n# Left\nggplot(suv, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  x_scale +\n  y_scale +\n  col_scale\n\n# Right\nggplot(compact, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  x_scale +\n  y_scale +\n  col_scale\n\n\n\n\n\n\n\n\n\n\n在这种特定情况下，你可以简单地使用分面（faceting）来解决问题，但这种技术更具一般性，例如如果你想在报告的多个页面上分布图形，那么这种技术就很有用。\n\n\n11.4.6 练习\n\n为什么下面的代码不覆盖默认的比例尺?\n\ndf &lt;- tibble(\n  x = rnorm(10000),\n  y = rnorm(10000)\n)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  scale_color_gradient(low = \"white\", high = \"red\") +\n  coord_fixed()\n\n每个比例尺的第一个参数是什么？它 和labs()相比怎么样？\n通过以下方式更改总统任期的显示：\n\n结合自定义颜色和x轴刻度的两个变体。\n改进y轴的显示。\n为每个任期标上总统的名字。\n添加有信息量的图标签。\n每4年设置一个刻度。（这看起来简单但实际上有些棘手！）\n\n首先，创建以下图形。然 后，使用override.aes修改代码以使图例更容易查看。\n\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_point(aes(color = cut), alpha = 1/20)",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>交流</span>"
    ]
  },
  {
    "objectID": "communication.html#sec-themes",
    "href": "communication.html#sec-themes",
    "title": "11  交流",
    "section": "11.5 主题",
    "text": "11.5 主题\n最后，使用主题来定制图形中的非数据元素：\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  theme_bw()\n\n\n\n\n\n\n\n\nggplot2包含了 图 11.2 中所示的八种主题，其中theme_gray()是默认主题。在 像ggthemes（https://jrnold.github.io/ggthemes）这样的附加包中，Jeffrey Arnold 提供了更多的主题。如 果你试图匹配特定的公司或期刊风格，你还可以创建自己的主题。\n\n\n\n\n\n\n\n\n图 11.2: The eight themes built-in to ggplot2.\n\n\n\n\n\n同样可以控制每个主题的各个组件，比如用于y轴的字体大小和颜色。我 们已经知道legend.position控制图例绘制的位置。还 有许多其他方面的图例可以用theme()函数进行定制。例 如，在下面的图中，我们改变了图例的方向，并在其周围加上了黑色边框。请 注意，主题的图例框和图形标题元素的定制是通过element_*()函数完成的。这 些函数指定非数据组件的样式，例如，在element_text()的face参数中，标题文本被加粗，图例边框颜色在element_rect()的color参数中定义。控 制标题和标题位置的主题元素分别是plot.title.position和plot.caption.position。在 下面的图中，这些被设置为 “plot”，以表示这些元素与整个绘图区域对齐，而不是与绘图面板（默认值）对齐。其 他一些有用的theme()组件用于更改标题和标题文本格式的放置。\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  labs(\n    title = \"Larger engine sizes tend to have lower fuel economy\",\n    caption = \"Source: https://fueleconomy.gov.\"\n  ) +\n  theme(\n    legend.position = c(0.6, 0.7),\n    legend.direction = \"horizontal\",\n    legend.box.background = element_rect(color = \"black\"),\n    plot.title = element_text(face = \"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\",\n    plot.caption = element_text(hjust = 0)\n  )\n#&gt; Warning: A numeric `legend.position` argument in `theme()` was deprecated in ggplot2\n#&gt; 3.5.0.\n#&gt; ℹ Please use the `legend.position.inside` argument of `theme()` instead.\n\n\n\n\n\n\n\n\n要了解theme()函数的所有组件的概述，请查看?theme的帮助文档。g gplot2 book 也是了解主题化完整细节的好地方。\nFor an overview of all theme() components, see help with ?theme. The ggplot2 book is also a great place to go for the full details on theming.\n\n11.5.1 练习\n\n从ggthemes包中选择一个主题，并将其应用到你最后制作的图形上。\n将你的图形的轴标签设置为蓝色并加粗。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>交流</span>"
    ]
  },
  {
    "objectID": "communication.html#布局",
    "href": "communication.html#布局",
    "title": "11  交流",
    "section": "11.6 布局",
    "text": "11.6 布局\n到目前为止，我们讨论了如何创建和修改单个图形。但 是，如果你有多个图形，并希望以某种方式将它们排列在一起怎么办？p atchwork包允许你将单独的图形组合到同一个图形中。在 本章的前面部分，我们已经加载了这个包。\n要将两个图形并排放置，你只需将它们加在一起。请 注意，你首先需要创建图形并将它们保存为对象（在以下示例中，它们被称为p1和p2）。然 后，你使用+将它们并排放置。\n\np1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  labs(title = \"Plot 1\")\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + \n  geom_boxplot() + \n  labs(title = \"Plot 2\")\np1 + p2\n\n\n\n\n\n\n\n\n需要注意的是，在上面的代码块中，我们并没有使用patchwork包中的新函数。相 反，该包为+运算符添加了新的功能。\n你还可以使用patchwork创建复杂的图形布局。在 以下示例中，|将p1和p3并排放置，而/将p2移动到下一行。\n\np3 &lt;- ggplot(mpg, aes(x = cty, y = hwy)) + \n  geom_point() + \n  labs(title = \"Plot 3\")\n(p1 | p3) / p2\n\n\n\n\n\n\n\n\n此外，patchwork允许你将多个图形的图例收集到一个共同的图例中，自定义图例的位置以及图形的尺寸，并为你的图形添加共同的标题、副标题、说明等。下 面我们创建了5个图形。我 们关闭了箱形图和散点图的图例，并将密度图的图例收集到图表顶部，使用了& theme(legend.position = \"top\")。请 注意这里使用了&运算符而不是通常的+。这 是因为我们正在修改patchwork图形的主题，而不是单个的ggplot。图 例被放置在顶部的guide_area()内。最 后，我们还自定义了patchwork中各个组件的高度：指南的高度为1，箱形图的高度为3，密度图的高度为2，分面的散点图的高度为4。p atchwork使用这个比例来划分你为图形分配的区域，并相应地放置各个组件。\n\np1 &lt;- ggplot(mpg, aes(x = drv, y = cty, color = drv)) + \n  geom_boxplot(show.legend = FALSE) + \n  labs(title = \"Plot 1\")\n\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy, color = drv)) + \n  geom_boxplot(show.legend = FALSE) + \n  labs(title = \"Plot 2\")\n\np3 &lt;- ggplot(mpg, aes(x = cty, color = drv, fill = drv)) + \n  geom_density(alpha = 0.5) + \n  labs(title = \"Plot 3\")\n\np4 &lt;- ggplot(mpg, aes(x = hwy, color = drv, fill = drv)) + \n  geom_density(alpha = 0.5) + \n  labs(title = \"Plot 4\")\n\np5 &lt;- ggplot(mpg, aes(x = cty, y = hwy, color = drv)) + \n  geom_point(show.legend = FALSE) + \n  facet_wrap(~drv) +\n  labs(title = \"Plot 5\")\n\n(guide_area() / (p1 + p2) / (p3 + p4) / p5) +\n  plot_annotation(\n    title = \"City and highway mileage for cars with different drive trains\",\n    caption = \"Source: https://fueleconomy.gov.\"\n  ) +\n  plot_layout(\n    guides = \"collect\",\n    heights = c(1, 3, 2, 4)\n    ) &\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n如果你希望了解更多关于如何使用patchwork组合和布局多个图形的信息，我们推荐你浏览该包的官方网站上的指南：https://patchwork.data-imaginist.com。\n\n11.6.1 练习\n\n如果在下面的绘图布局中省略括号会发生什么？你 能解释一下为什么会这样吗？\n\np1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  labs(title = \"Plot 1\")\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + \n  geom_boxplot() + \n  labs(title = \"Plot 2\")\np3 &lt;- ggplot(mpg, aes(x = cty, y = hwy)) + \n  geom_point() + \n  labs(title = \"Plot 3\")\n\n(p1 | p2) / p3\n\n使用前面练习中的三个图，重新创建下面的patchwork。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>交流</span>"
    ]
  },
  {
    "objectID": "communication.html#小结",
    "href": "communication.html#小结",
    "title": "11  交流",
    "section": "11.7 小结",
    "text": "11.7 小结\n在本章中，你学习了如何添加图形标签，如标题、副标题、说明以及修改默认的轴标签，使用注释在图形中添加信息性文本或突出显示特定的数据点，自定义轴刻度，并更改图形的主题。你 还学习了如何使用简单和复杂的图形布局将多个图形组合成一个图形。\n虽然到目前为止，您已经学习了如何制作许多不同类型的图形以及如何使用各种技术来定制它们，但我们只是触及了使用 ggplot2 创建内容的冰山一角。如 果你想全面了解 ggplot2，我们推荐您阅读《ggplot2: Elegant Graphics for Data Analysis》这本书。其 他有用的资源还有 Winston Chang 的《R Graphics Cookbook》和 Claus Wilke 的《Fundamentals of Data Visualization 》。",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>交流</span>"
    ]
  },
  {
    "objectID": "communication.html#footnotes",
    "href": "communication.html#footnotes",
    "title": "11  交流",
    "section": "",
    "text": "您可以使用SimDaltonism之类的工具来模拟色盲来测试这些图像。↩︎",
    "crumbs": [
      "可视化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>交流</span>"
    ]
  },
  {
    "objectID": "logicals.html",
    "href": "logicals.html",
    "title": "12  逻辑向量",
    "section": "",
    "text": "12.1 引言\n在本章中，你将学习处理逻辑向量的工具。逻 辑向量是最简单的向量类型，因为每个元素只能是三个可能值之一：TRUE（真）、FALSE（假）和NA（缺失值）。在 原始数据中直接找到逻辑向量的情况相对较少，但在几乎每次分析的过程中，你都会创建和操作它们。\n我们将首先讨论创建逻辑向量的最常见方法：通过数值比较。然 后，你将学习如何使用布尔代数来组合不同的逻辑向量，以及一些有用的总结。最 后，我们将介绍if_else()和case_when()这两个由逻辑向量驱动的用于进行条件更改的有用函数。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "logicals.html#引言",
    "href": "logicals.html#引言",
    "title": "12  逻辑向量",
    "section": "",
    "text": "12.1.1 必要条件\n本章中你将学习的大部分函数都是由基础R提供的，因此我们不需要tidyverse，但我们仍然会加载它，以便我们可以使用mutate()、filter()等函数来处理数据框。我 们还将继续从nycflights13::flights数据集中提取示例。\n\nlibrary(tidyverse)\nlibrary(nycflights13)\n\n然而，随着我们开始介绍更多的工具，并不总是会有一个完美的真实示例。因 此，我们将开始使用c()创建一些虚拟数据:\n\nx &lt;- c(1, 2, 3, 5, 7, 11, 13)\nx * 2\n#&gt; [1]  2  4  6 10 14 22 26\n\n这样做使得解释单个函数变得更容易，但代价是使得它较难应用于你的数据问题。请 记住，我们对自由浮动的向量所做的任何操作，你都可以通过mutate()等函数对数据框中的变量执行相同的操作。\n\ndf &lt;- tibble(x)\ndf |&gt; \n  mutate(y = x * 2)\n#&gt; # A tibble: 7 × 2\n#&gt;       x     y\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n#&gt; 4     5    10\n#&gt; 5     7    14\n#&gt; 6    11    22\n#&gt; # ℹ 1 more row",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "logicals.html#比较",
    "href": "logicals.html#比较",
    "title": "12  逻辑向量",
    "section": "12.2 比较",
    "text": "12.2 比较\n创建逻辑向量的一个非常常见的方式是通过使用&lt;、&lt;=、&gt;、&gt;=、!=和==进行数值比较。到 目前为止，我们主要在filter()内部临时创建逻辑变量，它们被计算、使用，然后就被丢弃了。例 如，下面的filter()查找所有大致准时到达的日间航班：\n\nflights |&gt; \n  filter(dep_time &gt; 600 & dep_time &lt; 2000 & abs(arr_delay) &lt; 20)\n#&gt; # A tibble: 172,286 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      601            600         1      844            850\n#&gt; 2  2013     1     1      602            610        -8      812            820\n#&gt; 3  2013     1     1      602            605        -3      821            805\n#&gt; 4  2013     1     1      606            610        -4      858            910\n#&gt; 5  2013     1     1      606            610        -4      837            845\n#&gt; 6  2013     1     1      607            607         0      858            915\n#&gt; # ℹ 172,280 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n知道这是一种快捷方式，并且可以使用mutate()明确创建底层的逻辑变量是很有用的：\n\nflights |&gt; \n  mutate(\n    daytime = dep_time &gt; 600 & dep_time &lt; 2000,\n    approx_ontime = abs(arr_delay) &lt; 20,\n    .keep = \"used\"\n  )\n#&gt; # A tibble: 336,776 × 4\n#&gt;   dep_time arr_delay daytime approx_ontime\n#&gt;      &lt;int&gt;     &lt;dbl&gt; &lt;lgl&gt;   &lt;lgl&gt;        \n#&gt; 1      517        11 FALSE   TRUE         \n#&gt; 2      533        20 FALSE   FALSE        \n#&gt; 3      542        33 FALSE   FALSE        \n#&gt; 4      544       -18 FALSE   TRUE         \n#&gt; 5      554       -25 FALSE   FALSE        \n#&gt; 6      554        12 FALSE   TRUE         \n#&gt; # ℹ 336,770 more rows\n\n这在处理更复杂的逻辑时特别有用，因为命名中间步骤既可以让代码更易读，也更容易检查每个步骤是否正确计算。\n总的来说，最初的filter函数相当于：\n\nflights |&gt; \n  mutate(\n    daytime = dep_time &gt; 600 & dep_time &lt; 2000,\n    approx_ontime = abs(arr_delay) &lt; 20,\n  ) |&gt; \n  filter(daytime & approx_ontime)\n\n\n12.2.1 浮点数比较\n对数字慎用==。例 如，下面这个向量看起来包含数字1和2：\n\nx &lt;- c(1 / 49 * 49, sqrt(2) ^ 2)\nx\n#&gt; [1] 1 2\n\n但如果你测试它们是否相等，你得到 FALSE:\n\nx == c(1, 2)\n#&gt; [1] FALSE FALSE\n\n这是怎么回事呢？计 算机存储数字时只有固定的小数位数，因此无法精确表示1/49或sqrt(2)，随后的计算将略有偏差。我 们可以通过在print()函数中指定digits1 参数来查看精确值：\n\nprint(x, digits = 16)\n#&gt; [1] 0.9999999999999999 2.0000000000000004\n\n你可以看到为什么R默认会对这些数字进行四舍五入；它们确实非常接近你预期的值。\n既然你已经明白了为什么==会失败，那你能做什么呢？一 个选择是使用dplyr::near()函数，它会忽略微小的差异：\n\nnear(x, c(1, 2))\n#&gt; [1] TRUE TRUE\n\n\n\n12.2.2 缺失值\n缺失值代表未知，因此它们是“具有传染性的”：几乎任何涉及未知值的操作也将是未知的：\n\nNA &gt; 5\n#&gt; [1] NA\n10 == NA\n#&gt; [1] NA\n\n最令人困惑的结果是这一个：\n\nNA == NA\n#&gt; [1] NA\n\n如果我们人为地添加一些额外的上下文，将更容易理解为什么这是正确的：\n\n# We don't know how old Mary is\nage_mary &lt;- NA\n\n# We don't know how old John is\nage_john &lt;- NA\n\n# Are Mary and John the same age?\nage_mary == age_john\n#&gt; [1] NA\n# We don't know!\n\n所以，如果你想要找出所有dep_time缺失的航班，以下代码是不起作用的，因为dep_time == NA对于每一行都会返回NA，而filter()函数会自动丢弃缺失值：\n\nflights |&gt; \n  filter(dep_time == NA)\n#&gt; # A tibble: 0 × 19\n#&gt; # ℹ 19 variables: year &lt;int&gt;, month &lt;int&gt;, day &lt;int&gt;, dep_time &lt;int&gt;,\n#&gt; #   sched_dep_time &lt;int&gt;, dep_delay &lt;dbl&gt;, arr_time &lt;int&gt;, …\n\n相反，我们需要一个新工具: is.na().\n\n\n12.2.3 is.na()\nis.na(x)适用于任何类型的向量，对于缺失值返回 TRUE，对于其他所有值返回 FALSE。\n\nis.na(c(TRUE, NA, FALSE))\n#&gt; [1] FALSE  TRUE FALSE\nis.na(c(1, NA, 3))\n#&gt; [1] FALSE  TRUE FALSE\nis.na(c(\"a\", NA, \"b\"))\n#&gt; [1] FALSE  TRUE FALSE\n\n我们可以使用is.na()来找到所有缺失dep_time的行：\n\nflights |&gt; \n  filter(is.na(dep_time))\n#&gt; # A tibble: 8,255 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1       NA           1630        NA       NA           1815\n#&gt; 2  2013     1     1       NA           1935        NA       NA           2240\n#&gt; 3  2013     1     1       NA           1500        NA       NA           1825\n#&gt; 4  2013     1     1       NA            600        NA       NA            901\n#&gt; 5  2013     1     2       NA           1540        NA       NA           1747\n#&gt; 6  2013     1     2       NA           1620        NA       NA           1746\n#&gt; # ℹ 8,249 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nis.na()在arrange()函数中也非常有用。a rrange()通常将所有缺失值放在最后，但你可以通过首先根据is.na()进行排序来覆盖这个默认行为：\n\nflights |&gt; \n  filter(month == 1, day == 1) |&gt; \n  arrange(dep_time)\n#&gt; # A tibble: 842 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 836 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nflights |&gt; \n  filter(month == 1, day == 1) |&gt; \n  arrange(desc(is.na(dep_time)), dep_time)\n#&gt; # A tibble: 842 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1       NA           1630        NA       NA           1815\n#&gt; 2  2013     1     1       NA           1935        NA       NA           2240\n#&gt; 3  2013     1     1       NA           1500        NA       NA           1825\n#&gt; 4  2013     1     1       NA            600        NA       NA            901\n#&gt; 5  2013     1     1      517            515         2      830            819\n#&gt; 6  2013     1     1      533            529         4      850            830\n#&gt; # ℹ 836 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n我们将在 章节 18 更深入地讨论缺失值。\n\n\n12.2.4 练习\n\ndplyr::near() 是如何工作的？键入near以查看源代码。 sqrt(2)^2 与 2接近吗？\n结合使用mutate(),is.na(),和count()来描述dep_time、sched_dep_time和dep_delay中缺失值之间的联系。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "logicals.html#布尔代数",
    "href": "logicals.html#布尔代数",
    "title": "12  逻辑向量",
    "section": "12.3 布尔代数",
    "text": "12.3 布尔代数\n若你有了多个逻辑向量，可以使用布尔代数将它们组合在一起。在 R中，&是“和”，|是“或”，! 是“非”，而xor()是异或2。 例如，df %&gt;% filter(!is.na(x))查找所有x不缺失的行，而df %&gt;% filter(x &lt; -10 | x &gt; 0)查找所有x小于-10或大于0的行。 图 12.1 展示了完整的布尔操作集以及它们是如何工作的。\n\n\n\n\n\n\n\n\n图 12.1: The complete set of Boolean operations. x is the left-hand circle, y is the right-hand circle, and the shaded region show which parts each operator selects.\n\n\n\n\n\n除了&和|之外，R 还有&&和||。不 要在 dplyr 函数中使用它们！这 些被称为短路运算符，并且总是只返回一个 TRUE 或 FALSE。它 们对编程很重要，但对数据科学来说并不重要。\n\n12.3.1 缺失值\n布尔代数中缺失值的规则有点难解释，因为乍一看它们似乎不一致：\n\ndf &lt;- tibble(x = c(TRUE, FALSE, NA))\n\ndf |&gt; \n  mutate(\n    and = x & NA,\n    or = x | NA\n  )\n#&gt; # A tibble: 3 × 3\n#&gt;   x     and   or   \n#&gt;   &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt;\n#&gt; 1 TRUE  NA    TRUE \n#&gt; 2 FALSE FALSE NA   \n#&gt; 3 NA    NA    NA\n\n要理解其中的原因，可以考虑NA | TRUE（即NA或TRUE）。在 逻辑向量中，缺失值意味着该值可能是TRUE或FALSE。因 为至少有一个是TRUE，所以TRUE | TRUE和FALSE | TRUE 都是TRUE。N A | TRUE也必须是TRUE，因为NA可以是TRUE或FALSE。然 而，NA | FALSE是NA，因为我们不知道NA是TRUE还是FALSE。类 似的推理也适用于NA & FALSE。\n\n\n12.3.2 运算顺序\n请注意，操作的顺序并不与英语中的顺序相同。以 下代码用于查找所有在十一月或十二月出发的航班：\n\nflights |&gt; \n   filter(month == 11 | month == 12)\n\n你可能会想要像在英语中那样写： “Find all flights that departed in November or December.”:\n\nflights |&gt; \n   filter(month == 11 | 12)\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n这段代码没有报错，但看起来也没有正常工作。这 是怎么回事呢？在 这里，R 首先计算month == 11创建一个逻辑向量，我们称之为nov。然 后它计算nov | 12。当 你使用数字与逻辑运算符结合时，除了0以外的所有数字都会被转换为TRUE，因此这等价于nov | TRUE，而TRUE | TRUE总是TRUE，所以每一行都会被选中：\n\nflights |&gt; \n  mutate(\n    nov = month == 11,\n    final = nov | 12,\n    .keep = \"used\"\n  )\n#&gt; # A tibble: 336,776 × 3\n#&gt;   month nov   final\n#&gt;   &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt;\n#&gt; 1     1 FALSE TRUE \n#&gt; 2     1 FALSE TRUE \n#&gt; 3     1 FALSE TRUE \n#&gt; 4     1 FALSE TRUE \n#&gt; 5     1 FALSE TRUE \n#&gt; 6     1 FALSE TRUE \n#&gt; # ℹ 336,770 more rows\n\n\n\n12.3.3 %in%\n避免 ==s 和 |s 顺序错误的一个简单方法是使用%in%。x %in% y返回一个与x长度相同的逻辑向量，当x中的某个值在y中时，该逻辑向量的对应位置为TRUE。\n\n1:12 %in% c(1, 5, 11)\n#&gt;  [1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\nletters[1:10] %in% c(\"a\", \"e\", \"i\", \"o\", \"u\")\n#&gt;  [1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE\n\n因此，要查找11月和12月的所有航班，可以这样写:\n\nflights |&gt; \n  filter(month %in% c(11, 12))\n\n请注意，%in%对NA的处理规则与==不同，因为NA %in% NA是TRUE。\nNote that %in% obeys different rules for NA to ==, as NA %in% NA is TRUE.\n\nc(1, 2, NA) == NA\n#&gt; [1] NA NA NA\nc(1, 2, NA) %in% NA\n#&gt; [1] FALSE FALSE  TRUE\n\n这可以作为一个有用的快捷方式:\n\nflights |&gt; \n  filter(dep_time %in% c(NA, 0800))\n#&gt; # A tibble: 8,803 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      800            800         0     1022           1014\n#&gt; 2  2013     1     1      800            810       -10      949            955\n#&gt; 3  2013     1     1       NA           1630        NA       NA           1815\n#&gt; 4  2013     1     1       NA           1935        NA       NA           2240\n#&gt; 5  2013     1     1       NA           1500        NA       NA           1825\n#&gt; 6  2013     1     1       NA            600        NA       NA            901\n#&gt; # ℹ 8,797 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n\n\n12.3.4 练习\n\n找出所有到达延误（arr_delay）缺失但起飞延误（dep_delay）不缺失的航班。找出所有到达时间（arr_time）和计划到达时间（sched_arr_time）都不缺失，但到达延误（arr_delay）缺失的航班。\n有多少航班的起飞时间（dep_time）是缺失的？这些行中还缺失了哪些其他变量？这些行可能代表什么？\n假设缺失的起飞时间（dep_time）意味着航班被取消，查看每天取消的航班数量。是否存在某种模式？被取消航班的比例与非】未被取消航班的平均延误之间是否存在联系？",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "logicals.html#sec-logical-summaries",
    "href": "logicals.html#sec-logical-summaries",
    "title": "12  逻辑向量",
    "section": "12.4 小结",
    "text": "12.4 小结\n以下部分描述了一些用于总结逻辑向量的有用技术。除 了专门与逻辑向量一起工作的函数外，你还可以使用与数字向量一起工作的函数。\n\n12.4.1 逻辑汇总函数（logical summaries）\n有两个主要的逻辑汇总函数：any()和all()。a ny(x)相当于|，如果x中有任何TRUE值，它就会返回TRUE。a ll(x)相当于&，只有当x的所有值都是TRUE时，它才会返回TRUE。像 所有汇总函数一样，如果存在任何缺失值，它们将返回NA，并且你可以像往常一样使用na.rm = TRUE来让缺失值消失。\n例如，我们可以使用all()和any()来找出是否每个航班的起飞延误都不超过一个小时，或者是否有任何航班的到达延误了五个小时或更多。使 用group_by()可以让我们按天来执行这些操作：\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    all_delayed = all(dep_delay &lt;= 60, na.rm = TRUE),\n    any_long_delay = any(arr_delay &gt;= 300, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 × 5\n#&gt;    year month   day all_delayed any_long_delay\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt;       &lt;lgl&gt;         \n#&gt; 1  2013     1     1 FALSE       TRUE          \n#&gt; 2  2013     1     2 FALSE       TRUE          \n#&gt; 3  2013     1     3 FALSE       FALSE         \n#&gt; 4  2013     1     4 FALSE       FALSE         \n#&gt; 5  2013     1     5 FALSE       TRUE          \n#&gt; 6  2013     1     6 FALSE       FALSE         \n#&gt; # ℹ 359 more rows\n\n然而，在大多数情况下，any()和all()有点过于粗略，如果能够更详细地了解有多少值是TRUE或FALSE就好了。这 就引出了数值摘要（numeric summaries）。\n\n\n12.4.2 逻辑向量的数值汇总\n当你在数值上下文中使用逻辑向量时，TRUE 变成 1，FALSE 变成 0。这 使得sum()和mean()函数对逻辑向量非常有用，因为sum(x)给出 TRUE 的数量，而mean(x)给出 TRUE 的比例（因为mean()实际上就是sum()除以length()）。\n例如，我们可以查看起飞延误最多一小时的航班的比例，以及到达延误五小时或更多的航班的数量：\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    proportion_delayed = mean(dep_delay &lt;= 60, na.rm = TRUE),\n    count_long_delay = sum(arr_delay &gt;= 300, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 × 5\n#&gt;    year month   day proportion_delayed count_long_delay\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;              &lt;dbl&gt;            &lt;int&gt;\n#&gt; 1  2013     1     1              0.939                3\n#&gt; 2  2013     1     2              0.914                3\n#&gt; 3  2013     1     3              0.941                0\n#&gt; 4  2013     1     4              0.953                0\n#&gt; 5  2013     1     5              0.964                1\n#&gt; 6  2013     1     6              0.959                0\n#&gt; # ℹ 359 more rows\n\n\n\n12.4.3 逻辑子集（logical subsetting）\n逻辑向量在汇总中的最后一个用途是：你可以使用逻辑向量来筛选单个变量到感兴趣的子集。这 利用了基本的子集操作符[（发音为“subset”），你将在 小节 27.2 中学到更多关于它的内容。\n我们想要查看实际上有延误的航班的平均延误时间。一 种方法是先筛选航班，然后计算平均延误时间：\n\nflights |&gt; \n  filter(arr_delay &gt; 0) |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    behind = mean(arr_delay),\n    n = n(),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 × 5\n#&gt;    year month   day behind     n\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt; &lt;int&gt;\n#&gt; 1  2013     1     1   32.5   461\n#&gt; 2  2013     1     2   32.0   535\n#&gt; 3  2013     1     3   27.7   460\n#&gt; 4  2013     1     4   28.3   297\n#&gt; 5  2013     1     5   22.6   238\n#&gt; 6  2013     1     6   24.4   381\n#&gt; # ℹ 359 more rows\n\n这样做是可以的，但如果我们还想计算提前到达的航班的平均延误时间呢？我 们需要执行一个单独的筛选步骤，然后考虑如何将两个数据框合并在一起。相 反，你可以使用[来执行内联筛选：arr_delay[arr_delay &gt; 0]将仅返回正的到达延误时间。\n由此引出：\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    behind = mean(arr_delay[arr_delay &gt; 0], na.rm = TRUE),\n    ahead = mean(arr_delay[arr_delay &lt; 0], na.rm = TRUE),\n    n = n(),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 × 6\n#&gt;    year month   day behind ahead     n\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1  2013     1     1   32.5 -12.5   842\n#&gt; 2  2013     1     2   32.0 -14.3   943\n#&gt; 3  2013     1     3   27.7 -18.2   914\n#&gt; 4  2013     1     4   28.3 -17.0   915\n#&gt; 5  2013     1     5   22.6 -14.0   720\n#&gt; 6  2013     1     6   24.4 -13.6   832\n#&gt; # ℹ 359 more rows\n\n同时也要注意组大小的差异：在第一部分中，n()给出的是每天延误航班的数量；在第二部分中，n()给出的是总航班数量。\n\n\n12.4.4 练习\n\nsum(is.na(x)) 会告诉你什么信息？ mean(is.na(x))呢？\n当应用于逻辑向量时，prod()返回什么？它等于什么逻辑汇总函数？当应用于逻辑向量时min()返回什么？它等于什么逻辑汇总函数？阅读文档并进行一些实验。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "logicals.html#条件转换",
    "href": "logicals.html#条件转换",
    "title": "12  逻辑向量",
    "section": "12.5 条件转换",
    "text": "12.5 条件转换\n逻辑向量最强大的功能之一是用于条件转换，即当满足条件x时执行一个操作，当满足条件y时执行另一个操作。有 两个重要的工具可以实现这一功能：if_else()和case_when()。\n\n12.5.1 if_else()\n如果你想要在一个条件为TRUE时使用一个值，而在条件为FALSE时使用另一个值，你可以使用dplyr::if_else()。你 总是会用到if_else()的前三个参数。第 一个参数condition，是一个逻辑向量；第二个参数true，给出当条件为真时的输出；第三个参数false，给出当条件为假时的输出。\n让我们从一个简单的例子开始，将一个数值向量标记为“+ve”（正）或“-ve”（负）：\n\nx &lt;- c(-3:3, NA)\nif_else(x &gt; 0, \"+ve\", \"-ve\")\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"-ve\" \"+ve\" \"+ve\" \"+ve\" NA\n\n还有一个可选的第四个参数，如果输入是NA，则会使用missing:\n\nif_else(x &gt; 0, \"+ve\", \"-ve\", \"???\")\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"-ve\" \"+ve\" \"+ve\" \"+ve\" \"???\"\n\n你还可以使用向量作为true和false参数。例 如，这允许我们创建一个abs()函数的简化实现：\n\nif_else(x &lt; 0, -x, x)\n#&gt; [1]  3  2  1  0  1  2  3 NA\n\n到目前为止，所有的参数都使用了相同的向量，当然你也可以混合和匹配。例 如，你可以像这样实现coalesce()函数的简单版本：\n\nx1 &lt;- c(NA, 1, 2, NA)\ny1 &lt;- c(3, NA, 4, 6)\nif_else(is.na(x1), y1, x1)\n#&gt; [1] 3 1 2 6\n\n你可能已经注意到我们上面标记示例中的一个小瑕疵：零既不是正数也不是负数。我 们可以通过添加另一个if_else()来解决这个问题：\n\nif_else(x == 0, \"0\", if_else(x &lt; 0, \"-ve\", \"+ve\"), \"???\")\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"0\"   \"+ve\" \"+ve\" \"+ve\" \"???\"\n\n这已经有点难以阅读了，你可以想象如果有更多的条件，它只会变得更难。相 反，你可以切换到dplyr::case_when()。\n\n\n12.5.2 case_when()\ndplyr的case_when()是受SQL的CASE语句启发，为不同条件执行不同计算提供了灵活的方法。它 有一个特殊的语法，不过这个语法看起来与tidyverse中将要使用的任何其他内容都不相似。它 接受形如condition ~ output的组合，condition必须是一个逻辑向量，当它为TRUE时，将使用output。\n这意味着我们可以将之前嵌套的if_else()重新创建如下：\n\nx &lt;- c(-3:3, NA)\ncase_when(\n  x == 0   ~ \"0\",\n  x &lt; 0    ~ \"-ve\", \n  x &gt; 0    ~ \"+ve\",\n  is.na(x) ~ \"???\"\n)\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"0\"   \"+ve\" \"+ve\" \"+ve\" \"???\"\n\n虽然代码更多，但它也更清晰。\n为了解释case_when()是如何工作的，让我们探索一些更简单的案例。如 果没有任何情况匹配，则输出为NA：\n\ncase_when(\n  x &lt; 0 ~ \"-ve\",\n  x &gt; 0 ~ \"+ve\"\n)\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" NA    \"+ve\" \"+ve\" \"+ve\" NA\n\n如果你想为未匹配到任何条件的情况设置一个“默认”的值，可以使用.default：\n\ncase_when(\n  x &lt; 0 ~ \"-ve\",\n  x &gt; 0 ~ \"+ve\",\n  .default = \"???\"\n)\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"???\" \"+ve\" \"+ve\" \"+ve\" \"???\"\n\n注意，如果多个条件匹配，只会使用第一个条件:\n\ncase_when(\n  x &gt; 0 ~ \"+ve\",\n  x &gt; 2 ~ \"big\"\n)\n#&gt; [1] NA    NA    NA    NA    \"+ve\" \"+ve\" \"+ve\" NA\n\n就像使用if_else()一样，你可以在~的两边使用变量，并且可以根据需要混合和匹配变量来解决你的问题。例 如，我们可以使用case_when()为到达延误提供一些人们可读的标签：\n\nflights |&gt; \n  mutate(\n    status = case_when(\n      is.na(arr_delay)      ~ \"cancelled\",\n      arr_delay &lt; -30       ~ \"very early\",\n      arr_delay &lt; -15       ~ \"early\",\n      abs(arr_delay) &lt;= 15  ~ \"on time\",\n      arr_delay &lt; 60        ~ \"late\",\n      arr_delay &lt; Inf       ~ \"very late\",\n    ),\n    .keep = \"used\"\n  )\n#&gt; # A tibble: 336,776 × 2\n#&gt;   arr_delay status \n#&gt;       &lt;dbl&gt; &lt;chr&gt;  \n#&gt; 1        11 on time\n#&gt; 2        20 late   \n#&gt; 3        33 late   \n#&gt; 4       -18 early  \n#&gt; 5       -25 early  \n#&gt; 6        12 on time\n#&gt; # ℹ 336,770 more rows\n\n在编写这种复杂的case_when()语句时要小心；我最初的两次尝试混合使用了&lt;和&gt;，结果不小心创建了重叠的条件。\n\n\n12.5.3 兼容类型（compatible types）\n请注意，if_else()和case_when()都要求输出具有兼容的类型。如 果它们不兼容，你会看到类似这样的错误：\n\nif_else(TRUE, \"a\", 1)\n#&gt; Error in `if_else()`:\n#&gt; ! Can't combine `true` &lt;character&gt; and `false` &lt;double&gt;.\n\ncase_when(\n  x &lt; -1 ~ TRUE,  \n  x &gt; 0  ~ now()\n)\n#&gt; Error in `case_when()`:\n#&gt; ! Can't combine `..1 (right)` &lt;logical&gt; and `..2 (right)` &lt;datetime&lt;local&gt;&gt;.\n\n总体来说，兼容的类型是相对较少的，因为自动将一个类型的向量转换为另一个类型的向量是常见的错误来源。以 下是一些最重要的兼容情况：\n\n数字和逻辑向量是兼容的，正如我们在@sec-numeric-summaries-of-logicals 讨论的那样。\n字符串和因子（章节 16） 是兼容的，因为可以将因子视为一组具有固定值的字符串。\n日期和日期-时间，我们将在 章节 17 部分讨论，它们是兼容的，因为你可以将日期视为日期-时间的一个特例。\nNA, 从技术上讲是逻辑向量，与所有类型都兼容，因为每个向量都有表示缺失值的方式。\n\n我们不要求你记住这些规则，但随着时间的推移，它们应该变得自然而然，因为它们在整个tidyverse中都被一致地应用。\n\n\n12.5.4 练习\n\n如果一个数能被2整除，那么它就是偶数。在 R中，你可以通过x %% 2 == 0来判断一个数是否为偶数。利 用这个事实和if_else()函数来确定0到20之间的每个数是偶数还是奇数。\n给定一个天数向量，如x &lt;- c(\"Monday\", \"Saturday\", \"Wednesday\")，使用if_else()语句将它们标记为周末或工作日。\n使用if_else()函数计算一个名为x的数值向量的绝对值。\n编写一个case_when()语句，利用flights数据集中的month和day列来标记一些重要的美国节假日（例如，新年、7月4日、感恩节和圣诞节）。首 先创建一个逻辑列，其值为TRUE或FALSE，然后创建一个字符列，该列要么给出节假日的名称，要么是NA。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "logicals.html#小结",
    "href": "logicals.html#小结",
    "title": "12  逻辑向量",
    "section": "12.6 小结",
    "text": "12.6 小结\n逻辑向量的定义很简单，因为每个值都必须是TRUE、FALSE或NA。但 逻辑向量提供了巨大的功能。在 本章中，你学习了如何使用&gt;、&lt;、&lt;=、&gt;=、==、!=和is.na()创建逻辑向量，如何使用!、&和|组合它们，以及如何使用any()、all()、sum()和mean()对它们进行汇总。你 还学习了强大的if_else()和case_when()函数，这些函数允许你根据逻辑向量的值返回值。\n在接下来的章节中，我们将一次又一次地看到逻辑向量。例 如，在@sec-strings ，你将学习str_detect(x, pattern)，它返回一个逻辑向量，对于x中匹配模式的元素，该向量的值为TRUE；在@sec-dates-and-times ，你将通过比较日期和时间来创建逻辑向量。但 现在，我们将转向下一个最重要的向量类型：数值向量。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "logicals.html#footnotes",
    "href": "logicals.html#footnotes",
    "title": "12  逻辑向量",
    "section": "",
    "text": "R 通常会自动为你调用print函数（即x是print(x)的简写），但如果你想要提供其他参数，显式调用print函数会很有用。↩︎\n也就是说，如果x为真，或y为真，但两者不同时为真，那么xor(x, y)就为真。这 通常是我们在英语中使用“或”的方式。“ 两者都”通常不是对“你想要冰淇淋还是蛋糕？” 这个问题的可接受答案。↩︎",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "numbers.html",
    "href": "numbers.html",
    "title": "13  数值",
    "section": "",
    "text": "13.1 引言\n数值向量是数据科学的基石，你在本书的前面部分已经多次使用过它们。现 在是系统地审视你在R中可以对它们做什么的时候了，确保你能够很好地应对任何涉及数值向量的未来问题。\n我们将首先为你提供几个工具，以便在你有字符串时生成数字，然后更详细地介绍count()函数。然 后，我们将深入探讨与mutate()搭配使用的各种数值转换，包括可以应用于其他类型向量的更一般的转换，但通常与数值向量一起使用。最 后，我们将介绍与summarize()搭配使用的汇总函数，并向你展示它们也可以与mutate()一起使用。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值</span>"
    ]
  },
  {
    "objectID": "numbers.html#引言",
    "href": "numbers.html#引言",
    "title": "13  数值",
    "section": "",
    "text": "13.1.1 必要条件\n本章主要使用来自基础R的函数，这些函数无需加载任何包即可使用。但 我们仍然需要tidyverse，因为我们将在tidyverse的函数（如mutate()和filter()）内部使用这些基础R函数。和 上一章一样，我们将使用nycflights13数据集的真实示例，以及使用c()和tribble()创建的玩具示例。\n\nlibrary(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值</span>"
    ]
  },
  {
    "objectID": "numbers.html#数字化",
    "href": "numbers.html#数字化",
    "title": "13  数值",
    "section": "13.2 数字化",
    "text": "13.2 数字化\n在大多数情况下，你会获得R的数字类型之一的整数或双精度数字。然 而，在某些情况下你可能会遇到以字符串形式出现的数字，可能是因为从列标题中转换得到它们，或者是因为在数据导入过程中出现了某些问题。\nreadr包提供了两个有用的函数来将字符串解析为数字：parse_double()和parse_number()。当 你遇到以字符串形式写入的数字时，可以使用parse_double()。\n\nx &lt;- c(\"1.2\", \"5.6\", \"1e3\")\nparse_double(x)\n#&gt; [1]    1.2    5.6 1000.0\n\n当字符串中包含你想要忽略的非数字文本时，使用parse_number()。这 对于货币数据和百分比特别有用：\n\nx &lt;- c(\"$1,234\", \"USD 3,513\", \"59%\")\nparse_number(x)\n#&gt; [1] 1234 3513   59",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-counts",
    "href": "numbers.html#sec-counts",
    "title": "13  数值",
    "section": "13.3 计数",
    "text": "13.3 计数\n令人惊讶的是，仅仅通过计数和一些基本的算术运算你就能够完成不少数据科学工作，因此dplyr致力于通过count()函数使计数尽可能简单。这 个函数非常适合在分析过程中进行快速探索和检查：\n\nflights |&gt; count(dest)\n#&gt; # A tibble: 105 × 2\n#&gt;   dest      n\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 ABQ     254\n#&gt; 2 ACK     265\n#&gt; 3 ALB     439\n#&gt; 4 ANC       8\n#&gt; 5 ATL   17215\n#&gt; 6 AUS    2439\n#&gt; # ℹ 99 more rows\n\n尽管在 章节 4 给出了建议，但我们通常还是将count()放在单独的一行，因为它通常在控制台中用于快速检查计算是否按预期工作。\n如果你想看到最常见的值，添加 sort = TRUE:\n\nflights |&gt; count(dest, sort = TRUE)\n#&gt; # A tibble: 105 × 2\n#&gt;   dest      n\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 ORD   17283\n#&gt; 2 ATL   17215\n#&gt; 3 LAX   16174\n#&gt; 4 BOS   15508\n#&gt; 5 MCO   14082\n#&gt; 6 CLT   14064\n#&gt; # ℹ 99 more rows\n\n请记住，如果希望查看所有值，可以使用|&gt; View()或|&gt; print(n = Inf)。\n你可以通过group_by()、summarize()和n()“手动”执行相同的计算。这 是有用的，因为它允许你同时计算其他汇总统计量：\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(\n    n = n(),\n    delay = mean(arr_delay, na.rm = TRUE)\n  )\n#&gt; # A tibble: 105 × 3\n#&gt;   dest      n delay\n#&gt;   &lt;chr&gt; &lt;int&gt; &lt;dbl&gt;\n#&gt; 1 ABQ     254  4.38\n#&gt; 2 ACK     265  4.85\n#&gt; 3 ALB     439 14.4 \n#&gt; 4 ANC       8 -2.5 \n#&gt; 5 ATL   17215 11.3 \n#&gt; 6 AUS    2439  6.02\n#&gt; # ℹ 99 more rows\n\nn()是一个特殊的汇总函数，它不接受任何参数，而是访问关于“当前”组的信息。这 意味着它只能在dplyr的函数内部使用：\n\nn()\n#&gt; Error in `n()`:\n#&gt; ! Must only be used inside data-masking verbs like `mutate()`,\n#&gt;   `filter()`, and `group_by()`.\n\nn()和count()有几个变体，你可能会觉得它们有用：\n\nn_distinct(x)计算一个或多个变量的不同（唯一）值的数量。例 如，我们可以找出哪些目的地有最多的航空公司提供服务：\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(carriers = n_distinct(carrier)) |&gt; \n  arrange(desc(carriers))\n#&gt; # A tibble: 105 × 2\n#&gt;   dest  carriers\n#&gt;   &lt;chr&gt;    &lt;int&gt;\n#&gt; 1 ATL          7\n#&gt; 2 BOS          7\n#&gt; 3 CLT          7\n#&gt; 4 ORD          7\n#&gt; 5 TPA          7\n#&gt; 6 AUS          6\n#&gt; # ℹ 99 more rows\n\n加权计数是求和。例 如你可以“计数”每架飞机飞行的英里数：\n\nflights |&gt; \n  group_by(tailnum) |&gt; \n  summarize(miles = sum(distance))\n#&gt; # A tibble: 4,044 × 2\n#&gt;   tailnum  miles\n#&gt;   &lt;chr&gt;    &lt;dbl&gt;\n#&gt; 1 D942DN    3418\n#&gt; 2 N0EGMQ  250866\n#&gt; 3 N10156  115966\n#&gt; 4 N102UW   25722\n#&gt; 5 N103US   24619\n#&gt; 6 N104UW   25157\n#&gt; # ℹ 4,038 more rows\n\n加权计数是一个常见的问题，所以count()函数有一个wt参数来实现同样的功能：\n\nflights |&gt; count(tailnum, wt = distance)\n\n可以通过结合sum()和is.na()来计数缺失值。在 flights数据集中，这表示被取消的航班：\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(n_cancelled = sum(is.na(dep_time))) \n#&gt; # A tibble: 105 × 2\n#&gt;   dest  n_cancelled\n#&gt;   &lt;chr&gt;       &lt;int&gt;\n#&gt; 1 ABQ             0\n#&gt; 2 ACK             0\n#&gt; 3 ALB            20\n#&gt; 4 ANC             0\n#&gt; 5 ATL           317\n#&gt; 6 AUS            21\n#&gt; # ℹ 99 more rows\n\n\n\n13.3.1 练习\n\n如何使用count()来计算给定变量中缺失值的行数？\n将以下对count()的调用扩展为使用group_by()、summarize()和arrange():\n\nflights |&gt; count(dest, sort = TRUE)\nflights |&gt; count(tailnum, wt = distance)",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值</span>"
    ]
  },
  {
    "objectID": "numbers.html#数值转换",
    "href": "numbers.html#数值转换",
    "title": "13  数值",
    "section": "13.4 数值转换",
    "text": "13.4 数值转换\n转换函数与mutate()配合得很好，因为它们的输出长度与输入相同。绝 大多数转换函数已经内置在R的基本包中。列 出所有函数是不切实际的，所以本节将展示一些最有用的。例 如，虽然R提供了你可能梦寐以求的所有三角函数，但我们在这里没有列出它们，因为它们在数据科学中很少需要。\n\n13.4.1 算术和循环规则\n在 章节 2 ，我们介绍了算术运算（+, -, *, /, ^）的基础知识，并在此之后多次使用了它们。这 些函数不需要过多的解释，因为它们执行的是你在小学就学过的运算。但 是，我们需要简短地讨论一下循环规则（recycling rules），这些规则决定了当左侧和右侧的长度不同时会发生什么。这 对于像flights |&gt; mutate(air_time = air_time / 60)这样的操作很重要，因为在/的左侧有336,776个数字，而右侧只有一个。\nR通过循环或重复较短的向量来处理长度不匹配的情况。如 果我们在数据框之外创建一些向量，就能更容易地看到这个操作过程：\n\nx &lt;- c(1, 2, 10, 20)\nx / 5\n#&gt; [1] 0.2 0.4 2.0 4.0\n# is shorthand for\nx / c(5, 5, 5, 5)\n#&gt; [1] 0.2 0.4 2.0 4.0\n\n通常，你只想循环单个数字（即长度为1的向量），但R会循环任何较短的向量。如 果较长的向量不是较短的向量的倍数，R通常会（但不总是）给出警告：\n\nx * c(1, 2)\n#&gt; [1]  1  4 10 40\nx * c(1, 2, 3)\n#&gt; Warning in x * c(1, 2, 3): longer object length is not a multiple of shorter\n#&gt; object length\n#&gt; [1]  1  4 30 20\n\n这些循环规则也适用于逻辑比较（==, &lt;, &lt;=, &gt;, &gt;=, !=），如果你不小心使用了==而不是%in%，并且数据框的行数不巧地匹配了这些规则，可能会导致一个令人惊讶的结果。例 如，考虑以下代码，它试图找出1月和2月的所有航班：\n\nflights |&gt; \n  filter(month == c(1, 2))\n#&gt; # A tibble: 25,977 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      542            540         2      923            850\n#&gt; 3  2013     1     1      554            600        -6      812            837\n#&gt; 4  2013     1     1      555            600        -5      913            854\n#&gt; 5  2013     1     1      557            600        -3      838            846\n#&gt; 6  2013     1     1      558            600        -2      849            851\n#&gt; # ℹ 25,971 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n代码运行无误，但它没有返回你想要的结果。由 于循环规则，它找到了在奇数行出发的1月航班和在偶数行出发的2月航班。不 幸的是，由于flights的行数是偶数所以没有给出警告。\n为了防止这种静默失败的情况，tidyverse的大多数函数使用了一种更严格的循环形式，即仅循环单个值。不 幸的是，这在当前情况下或许多其他情况下并不起作用，因为关键的计算是由基础R函数==执行的，而不是filter()。\n\n\n13.4.2 最小值和最大值\n算术函数对变量对进行操作。两 个紧密相关的函数是pmin()和pmax()，当给定两个或更多变量时，它们将返回每行中的最小或最大值：\n\ndf &lt;- tribble(\n  ~x, ~y,\n  1,  3,\n  5,  2,\n  7, NA,\n)\n\ndf |&gt; \n  mutate(\n    min = pmin(x, y, na.rm = TRUE),\n    max = pmax(x, y, na.rm = TRUE)\n  )\n#&gt; # A tibble: 3 × 4\n#&gt;       x     y   min   max\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     3     1     3\n#&gt; 2     5     2     2     5\n#&gt; 3     7    NA     7     7\n\n请注意，这些函数与min()和max()这样的汇总函数是不同的，后者接受多个观测值并返回一个单一的值。当 发现所有的最小值和所有的最大值都相同时，你可以判断你可能使用了错误的形式。\n\ndf |&gt; \n  mutate(\n    min = min(x, y, na.rm = TRUE),\n    max = max(x, y, na.rm = TRUE)\n  )\n#&gt; # A tibble: 3 × 4\n#&gt;       x     y   min   max\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     3     1     7\n#&gt; 2     5     2     1     7\n#&gt; 3     7    NA     1     7\n\n\n\n13.4.3 模运算\n模运算（modular arithmetic）是你在学习十进制之前所做的数学运算的技术名称，即除法产生一个整数商和一个余数。在 R中，%/%执行整数除法，而%%计算余数。\n\n1:10 %/% 3\n#&gt;  [1] 0 0 1 1 1 2 2 2 3 3\n1:10 %% 3\n#&gt;  [1] 1 2 0 1 2 0 1 2 0 1\n\n模运算对于flights数据集来说很有用，因为我们可以使用它来将sched_dep_time变量分解为hour和minute。\n\nflights |&gt; \n  mutate(\n    hour = sched_dep_time %/% 100,\n    minute = sched_dep_time %% 100,\n    .keep = \"used\"\n  )\n#&gt; # A tibble: 336,776 × 3\n#&gt;   sched_dep_time  hour minute\n#&gt;            &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1            515     5     15\n#&gt; 2            529     5     29\n#&gt; 3            540     5     40\n#&gt; 4            545     5     45\n#&gt; 5            600     6      0\n#&gt; 6            558     5     58\n#&gt; # ℹ 336,770 more rows\n\n我们可以将上述方法与来自 小节 12.4 的mean(is.na(x))技巧结合起来查看取消航班的比例在一天中的变化情况。结 果如图 图 13.1 所示。\n\nflights |&gt; \n  group_by(hour = sched_dep_time %/% 100) |&gt; \n  summarize(prop_cancelled = mean(is.na(dep_time)), n = n()) |&gt; \n  filter(hour &gt; 1) |&gt; \n  ggplot(aes(x = hour, y = prop_cancelled)) +\n  geom_line(color = \"grey50\") + \n  geom_point(aes(size = n))\n\n\n\n\n\n\n\n图 13.1: A line plot with scheduled departure hour on the x-axis, and proportion of cancelled flights on the y-axis. Cancellations seem to accumulate over the course of the day until 8pm, very late flights are much less likely to be cancelled.\n\n\n\n\n\n\n\n13.4.4 对数\n对数在处理跨越多个数量级的数据以及将指数增长转换为线性增长时是非常有用的转换方法。在 R中，你可以选择三种对数：log()（自然对数，底为e）、log2()（底为2）和log10()（底为10）。我 们推荐使用log2()或log10()。l og2()易于解释，因为在对数尺度上相差1对应于原始尺度上的加倍，相差-1对应于减半；而log10()易于反向转换，因为（例如）3 是 10 的 3 次方，即 1000。l og()的反函数是exp()；要计算log2()或log10()的反函数，你需要使用2^或10^。\n\n\n13.4.5 四舍五入\n使用round(x)将一个数字四舍五入到最接近的整数:\n\nround(123.456)\n#&gt; [1] 123\n\n你可以使用第二个参数digits来控制四舍五入的精度。round(x, digits)会将x四舍五入到最近的 10^-n，所以digits = 2会将x四舍五入到最近的 0.01。这 个定义很有用，因为它意味着round(x, -3)会将x四舍五入到最近的千位，而它确实是这样做的：\n\nround(123.456, 2)  # two digits\n#&gt; [1] 123.46\nround(123.456, 1)  # one digit\n#&gt; [1] 123.5\nround(123.456, -1) # round to nearest ten\n#&gt; [1] 120\nround(123.456, -2) # round to nearest hundred\n#&gt; [1] 100\n\nround()有一个看起来有些奇怪的特性，第一眼看上去这可能会让人吃惊：\n\nround(c(1.5, 2.5))\n#&gt; [1] 2 2\n\nround()使用的是所谓的“向偶数舍入”或“银行家舍入”方法：如果一个数字正好在两个整数之间，那么它会被舍入到偶数整数。这 是一个很好的策略，因为它使得舍入是无偏的：一半的 0.5 被向上舍入，而另一半被向下舍入。\nround()与floor()和ceiling()相对应。floor()总是向下舍入，而ceiling()总是向上舍入。\n\nx &lt;- 123.456\n\nfloor(x)\n#&gt; [1] 123\nceiling(x)\n#&gt; [1] 124\n\n这些函数（floor()和ceiling()）没有digits参数，所以你可以先将数字缩小比例，然后四舍五入，最后再扩大回原来的比例：\n\n# Round down to nearest two digits\nfloor(x / 0.01) * 0.01\n#&gt; [1] 123.45\n# Round up to nearest two digits\nceiling(x / 0.01) * 0.01\n#&gt; [1] 123.46\n\n如果你想要将round()舍入到某个数的倍数，你可以使用相同的技巧：\n\n# Round to nearest multiple of 4\nround(x / 4) * 4\n#&gt; [1] 124\n\n# Round to nearest 0.25\nround(x / 0.25) * 0.25\n#&gt; [1] 123.5\n\n\n\n13.4.6 将数字切分成区间\n使用cut()1函数可以将一个数值向量拆分（也称为分箱或分组）成离散的区间：\n\nx &lt;- c(1, 2, 5, 10, 15, 20)\ncut(x, breaks = c(0, 5, 10, 15, 20))\n#&gt; [1] (0,5]   (0,5]   (0,5]   (5,10]  (10,15] (15,20]\n#&gt; Levels: (0,5] (5,10] (10,15] (15,20]\n\nbreaks不需要是等距的：\n\ncut(x, breaks = c(0, 5, 10, 100))\n#&gt; [1] (0,5]    (0,5]    (0,5]    (5,10]   (10,100] (10,100]\n#&gt; Levels: (0,5] (5,10] (10,100]\n\n你可以选择性地提供你自己的labels。请 注意，labels的数量应该比breaks少一个。\n\ncut(x, \n  breaks = c(0, 5, 10, 15, 20), \n  labels = c(\"sm\", \"md\", \"lg\", \"xl\")\n)\n#&gt; [1] sm sm sm md lg xl\n#&gt; Levels: sm md lg xl\n\n任何超出breaks范围的值都会变成NA：\n\ny &lt;- c(NA, -10, 5, 10, 30)\ncut(y, breaks = c(0, 5, 10, 15, 20))\n#&gt; [1] &lt;NA&gt;   &lt;NA&gt;   (0,5]  (5,10] &lt;NA&gt;  \n#&gt; Levels: (0,5] (5,10] (10,15] (15,20]\n\n查看文档以了解其他有用的参数，如right和include.lowest，这些参数控制区间是[a, b)还是 (a, b]，以及是否应将最低区间设为[a, b]。\n\n\n13.4.7 累积和滚动聚合\n基础 R 提供了cumsum(),cumprod(),cummin(),cummax()函数，用于计算连续或累积的和、积、最小值和最大值。d plyr 包提供了cummean()函数用于计算累积平均值。在 实践中，累积和是最常遇到的：\n\nx &lt;- 1:10\ncumsum(x)\n#&gt;  [1]  1  3  6 10 15 21 28 36 45 55\n\n如果你需要更复杂的滚动或滑动聚合，可以尝试使用slider包。\n\n\n13.4.8 练习\n\n用文字解释用于生成@fig-prop-cancelled 的每一行代码的作用。\nR提供了什么三角函数？猜 测一些名字并查找文档。这 些函数用度数还是弧度？\n目前，dep_time和sched_dep_time看起来很方便，但是难以用于计算，因为它们并不是真正的连续数字。你 可以通过运行下面的代码来看到基本问题：每小时之间都存在间隙。\n\nflights |&gt; \n  filter(month == 1, day == 1) |&gt; \n  ggplot(aes(x = sched_dep_time, y = dep_delay)) +\n  geom_point()\n\n将它们转换为更真实的时间表示（可以是自午夜起的小时数（以小数形式）或分钟数）。\n将dep_time和arr_time四舍五入到最近的五分钟。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值</span>"
    ]
  },
  {
    "objectID": "numbers.html#通用转换",
    "href": "numbers.html#通用转换",
    "title": "13  数值",
    "section": "13.5 通用转换",
    "text": "13.5 通用转换\n以下部分描述了一些通常与数值向量一起使用的通用转换，但它们也可以应用于所有其他列类型。\n\n13.5.1 秩（Ranks）\ndplyr 提供了一系列受 SQL 启发的排秩函数，但你应该始终从dplyr::min_rank()开始。它 使用了处理并列名次（相持）的标准方法，例如，第1名、第2名、第2名、第4名。\n\nx &lt;- c(1, 2, 2, 3, 4, NA)\nmin_rank(x)\n#&gt; [1]  1  2  2  4  5 NA\n\n请注意，最小的值获得最小的秩；利用desc(x)可以让最大的值获得最小的秩：\n\nmin_rank(desc(x))\n#&gt; [1]  5  3  3  2  1 NA\n\n如果min_rank()不符合你的需求，请查看它的变体函数dplyr::row_number()、dplyr::dense_rank()、dplyr::percent_rank()和dplyr::cume_dist()。查 看文档以获取详细信息。\n\ndf &lt;- tibble(x = x)\ndf |&gt; \n  mutate(\n    row_number = row_number(x),\n    dense_rank = dense_rank(x),\n    percent_rank = percent_rank(x),\n    cume_dist = cume_dist(x)\n  )\n#&gt; # A tibble: 6 × 5\n#&gt;       x row_number dense_rank percent_rank cume_dist\n#&gt;   &lt;dbl&gt;      &lt;int&gt;      &lt;int&gt;        &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1     1          1          1         0          0.2\n#&gt; 2     2          2          2         0.25       0.6\n#&gt; 3     2          3          2         0.25       0.6\n#&gt; 4     3          4          3         0.75       0.8\n#&gt; 5     4          5          4         1          1  \n#&gt; 6    NA         NA         NA        NA         NA\n\n你可以通过选择适当的ties.method参数来使用 R 的基础函数rank()来达到许多相同的结果；你也可能希望通过设置na.last = \"keep\"将 NAs 值保留为 NA。\nrow_number()在 dplyr 的函数内部使用时也可以不带任何参数。在 这种情况下它会给出“当前”行的编号。当 与%%或%/%结合使用时，它可以成为将数据划分为大小相似的组的有用工具：\n\ndf &lt;- tibble(id = 1:10)\n\ndf |&gt; \n  mutate(\n    row0 = row_number() - 1,\n    three_groups = row0 %% 3,\n    three_in_each_group = row0 %/% 3\n  )\n#&gt; # A tibble: 10 × 4\n#&gt;      id  row0 three_groups three_in_each_group\n#&gt;   &lt;int&gt; &lt;dbl&gt;        &lt;dbl&gt;               &lt;dbl&gt;\n#&gt; 1     1     0            0                   0\n#&gt; 2     2     1            1                   0\n#&gt; 3     3     2            2                   0\n#&gt; 4     4     3            0                   1\n#&gt; 5     5     4            1                   1\n#&gt; 6     6     5            2                   1\n#&gt; # ℹ 4 more rows\n\n\n\n13.5.2 偏移量（Offsets）\ndplyr::lead()和dplyr::lag()允许你引用“当前”值之前或之后的值。它 们会返回一个与输入长度相同的向量，并在开始或结束时用 NAs 填充：\n\nx &lt;- c(2, 5, 11, 11, 19, 35)\nlag(x)\n#&gt; [1] NA  2  5 11 11 19\nlead(x)\n#&gt; [1]  5 11 11 19 35 NA\n\n\nx - lag(x) 给出当前值和前一个值之间的差值。\n\nx - lag(x)\n#&gt; [1] NA  3  6  0  8 16\n\nx == lag(x) 告诉你当前值何时发生改变。\n\nx == lag(x)\n#&gt; [1]    NA FALSE FALSE  TRUE FALSE FALSE\n\n\n你可以通过使用第二个参数n来实现超过一个位置的向前或向后取值。\n\n\n13.5.3 连续标识符\n有时，每当某个事件发生时你都希望开始一个新组。例 如在查看网站数据时，你通常会希望将事件划分为不同会话（sessions），即当距离上次活动超过 x 分钟时你会开始一个新会话。比 如，想象你有某人访问网站的时间记录：\n\nevents &lt;- tibble(\n  time = c(0, 1, 2, 3, 5, 10, 12, 15, 17, 19, 20, 27, 28, 30)\n)\n\n并且你已经计算了每个事件之间的时间间隔，并判断了是否存在足够大的间隔以符合标准：\n\nevents &lt;- events |&gt; \n  mutate(\n    diff = time - lag(time, default = first(time)),\n    has_gap = diff &gt;= 5\n  )\nevents\n#&gt; # A tibble: 14 × 3\n#&gt;    time  diff has_gap\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;  \n#&gt; 1     0     0 FALSE  \n#&gt; 2     1     1 FALSE  \n#&gt; 3     2     1 FALSE  \n#&gt; 4     3     1 FALSE  \n#&gt; 5     5     2 FALSE  \n#&gt; 6    10     5 TRUE   \n#&gt; # ℹ 8 more rows\n\n但是，我们如何从逻辑向量转换为可以使用group_by()进行分组的东西呢？c umsum()函数（来自 小节 13.4.7 ）此时就派上了用场，当存在间隔（即has_gap为TRUE）时，它会增加分组编号（来自@sec-numeric-summaries-of-logicals ）：\n\nevents |&gt; mutate(\n  group = cumsum(has_gap)\n)\n#&gt; # A tibble: 14 × 4\n#&gt;    time  diff has_gap group\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;   &lt;int&gt;\n#&gt; 1     0     0 FALSE       0\n#&gt; 2     1     1 FALSE       0\n#&gt; 3     2     1 FALSE       0\n#&gt; 4     3     1 FALSE       0\n#&gt; 5     5     2 FALSE       0\n#&gt; 6    10     5 TRUE        1\n#&gt; # ℹ 8 more rows\n\n创建分组变量的另一种方法是consecutive_id()，它会在其参数之一发生变化时开始一个新组。例 如，受到this stackoverflow question的启发，假设你有一个包含许多重复值的数据框：\n\ndf &lt;- tibble(\n  x = c(\"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"d\", \"e\", \"a\", \"a\", \"b\", \"b\"),\n  y = c(1, 2, 3, 2, 4, 1, 3, 9, 4, 8, 10, 199)\n)\n\n如果你想要保留每个重复值x的第一行，你可以使用group_by()、consecutive_id()和slice_head()。\n\ndf |&gt; \n  group_by(id = consecutive_id(x)) |&gt; \n  slice_head(n = 1)\n#&gt; # A tibble: 7 × 3\n#&gt; # Groups:   id [7]\n#&gt;   x         y    id\n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 a         1     1\n#&gt; 2 b         2     2\n#&gt; 3 c         4     3\n#&gt; 4 d         3     4\n#&gt; 5 e         9     5\n#&gt; 6 a         4     6\n#&gt; # ℹ 1 more row\n\n\n\n13.5.4 练习\n\n使用排秩函数找出延误时间最长的10个航班。如 果出现并列的情况，你打算如何处理？请 仔细阅读min_rank()函数的文档。\n哪架飞机（tailnum）的准时记录最差？\n如果你想尽可能避免延误，你应该在一天中的哪个时间段飞行？\nflights |&gt; group_by(dest) |&gt; filter(row_number() &lt; 4)这段代码做了什么？f lights |&gt; group_by(dest) |&gt; filter(row_number(dep_delay) &lt; 4)这段代码又做了什么？\n对于每个目的地，计算延误的总分钟数；对于每个航班，计算其目的地延误总时间中所占的比例。\n延误通常是时间相关的：即使导致初始延误的问题已经解决，后续的航班仍然会延误以允许前面的航班起飞。使 用lag()函数，探索某小时的平均航班延误与前一小时的平均延误之间的关系。\n\nflights |&gt; \n  mutate(hour = dep_time %/% 100) |&gt; \n  group_by(year, month, day, hour) |&gt; \n  summarize(\n    dep_delay = mean(dep_delay, na.rm = TRUE),\n    n = n(),\n    .groups = \"drop\"\n  ) |&gt; \n  filter(n &gt; 5)\n\n查看每个目的地，你能找到那些可疑的快速航班（即可能存在数据录入错误的航班）吗？计 算某航班的空中飞行时间与该目的地最短飞行时间的相对值。哪 些航班在空中延误最严重？\n找出至少由两家航空公司运营的所有目的地。使 用这些目的地，根据同一目的地的表现，对航空公司进行相对排名。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值</span>"
    ]
  },
  {
    "objectID": "numbers.html#数值汇总",
    "href": "numbers.html#数值汇总",
    "title": "13  数值",
    "section": "13.6 数值汇总",
    "text": "13.6 数值汇总\n仅使用我们已经介绍过的counts、means和sums就可以让你走得很远，但R提供了许多其他有用的汇总函数。以 下是可能会有用的一些函数。\n\n13.6.1 中心\n到目前为止，我们主要使用mean()来汇总数值向量的中心。正 如在@sec-sample-size 看到的，由于均数是总和除以总数得到的，因此即使对几个异常高或异常低的值它也很敏感。一 种替代方法是使用median()，它会找到一个位于向量“中间”的值，即50%的值高于它，50%的值低于它。根 据你感兴趣的变量的分布形状，选取均数或者中位数作为合适的中心度量标准。例 如对于对称分布我们通常报告均数，而对于偏态分布则报告中位数。\n图 13.2 比较了每个目的地的起飞延误均数与中位数（以分钟为单位）。延 误中位数总是小于延误均数，因为航班有时会延误数小时，但永远不会提前数小时起飞。\n\nflights |&gt;\n  group_by(year, month, day) |&gt;\n  summarize(\n    mean = mean(dep_delay, na.rm = TRUE),\n    median = median(dep_delay, na.rm = TRUE),\n    n = n(),\n    .groups = \"drop\"\n  ) |&gt; \n  ggplot(aes(x = mean, y = median)) + \n  geom_abline(slope = 1, intercept = 0, color = \"white\", linewidth = 2) +\n  geom_point()\n\n\n\n\n\n\n\n图 13.2: A scatterplot showing the differences of summarizing daily departure delay with median instead of mean.\n\n\n\n\n\n你可能还想知道众数（mode），也就是最常见的值。这 是一种仅在非常简单的情况下才有效的汇总统计量（这就是为什么你可能在高中学过它），但它在许多真实数据集上并不适用。如 果数据是离散的，可能存在多个最常见的值，而如果数据是连续的，则可能没有最常见的值，因为每个值都略有不同。由 于这些原因，统计学家往往不使用众数，并且在R的基础包中也没有包含计算众数2的函数。\n\n\n13.6.2 最小值、最大值和分位数\n如果你对中心位置以外的其他位置感兴趣怎么办？m in()和max()会给你最大值和最小值。另 一个强大的工具是quantile()，它是中位数的泛化：quantile(x, 0.25)会找到大于 25% 的x的值，quantile(x, 0.5)相当于中位数，而quantile(x, 0.95)会找到大于 95% 的x的值。\n对于flights数据，你可能想查看延误的 95% 分位数而不是最大值，因为它会忽略延误最严重的 5% 航班，这部分航班可能非常极端。\n\nflights |&gt;\n  group_by(year, month, day) |&gt;\n  summarize(\n    max = max(dep_delay, na.rm = TRUE),\n    q95 = quantile(dep_delay, 0.95, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 × 5\n#&gt;    year month   day   max   q95\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  2013     1     1   853  70.1\n#&gt; 2  2013     1     2   379  85  \n#&gt; 3  2013     1     3   291  68  \n#&gt; 4  2013     1     4   288  60  \n#&gt; 5  2013     1     5   327  41  \n#&gt; 6  2013     1     6   202  51  \n#&gt; # ℹ 359 more rows\n\n\n\n13.6.3 离散性（Spread）\n有时你并不是那么关心大部分数据所在的位置，而是关心它的离散程度。两 个常用的汇总统计量是标准差sd(x)和四分位距IQR()。我 们在这里不会解释sd()，因为你可能已经很熟悉了，但IQR()可能比较新颖，它等于quantile(x, 0.75) - quantile(x, 0.25)，给出了包含中间 50% 数据的范围。\n我们可以利用这个方法来揭示flights数据中的一个小异常。你 可能会认为，由于机场总是在固定的位置，所以起点和终点之间距离的离散性应该是零。但 是下面的代码揭示了机场 EGE 的一个数据异常：\n\nflights |&gt; \n  group_by(origin, dest) |&gt; \n  summarize(\n    distance_iqr = IQR(distance), \n    n = n(),\n    .groups = \"drop\"\n  ) |&gt; \n  filter(distance_iqr &gt; 0)\n#&gt; # A tibble: 2 × 4\n#&gt;   origin dest  distance_iqr     n\n#&gt;   &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 EWR    EGE              1   110\n#&gt; 2 JFK    EGE              1   103\n\n\n\n13.6.4 分布\n值得记住的是，上述所有描述的汇总统计量都是将分布简化为单个数字的一种方式。这 意味着它们本质上是简化的，如果你选择了错误的汇总方式，很容易忽略各组之间的重要差异。因 此，在确定汇总统计量之前，先对数据进行可视化始终是个好主意。\n图 13.3 显示了出发延误的整体分布。这 个分布是如此偏斜，以至于我们必须放大才能看到大部分数据。这 表明均数可能不是一个好的汇总方式，我们可能更喜欢使用中位数。\n\n\n\n\n\n\n\n\n图 13.3: (Left) The histogram of the full data is extremely skewed making it hard to get any details. (Right) Zooming into delays of less than two hours makes it possible to see what’s happening with the bulk of the observations.\n\n\n\n\n\n同样，检查子组的分布是否与整体相似也是一个好主意。在 下面的图中，dep_delay的365个频数多边形图（frequency polygons）被叠加在一起，每天一个。这 些分布似乎遵循一个共同的模式，这表明每天使用相同的汇总方式是合适的。\n\nflights |&gt;\n  filter(dep_delay &lt; 120) |&gt; \n  ggplot(aes(x = dep_delay, group = interaction(day, month))) + \n  geom_freqpoly(binwidth = 5, alpha = 1/5)\n\n\n\n\n\n\n\n\n不要害怕探讨针对你正在处理的数据自定义的汇总方法。在 这种情况下，这可能意味着分别汇总提前起飞的航班和晚起飞的航班的分布，或者鉴于这些值严重偏斜，你可能还需尝试进行对数转换。最 后，不要忘记在@sec-sample-size 中学到的内容：每当创建数值汇总时，最好包括每个组的观测数。\n\n\n13.6.5 位置\n对于数值向量，还有最后一种类型的汇总统计量非常有用，它也适用于其他类型的值：提取特定位置的值：first(x)、last(x) 和 nth(x, n)。\n例如，我们可以找到每天第一次、第五次和最后一次的出发时间：\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    first_dep = first(dep_time, na_rm = TRUE), \n    fifth_dep = nth(dep_time, 5, na_rm = TRUE),\n    last_dep = last(dep_time, na_rm = TRUE)\n  )\n#&gt; `summarise()` has grouped output by 'year', 'month'. You can override using\n#&gt; the `.groups` argument.\n#&gt; # A tibble: 365 × 6\n#&gt; # Groups:   year, month [12]\n#&gt;    year month   day first_dep fifth_dep last_dep\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;    &lt;int&gt;\n#&gt; 1  2013     1     1       517       554     2356\n#&gt; 2  2013     1     2        42       535     2354\n#&gt; 3  2013     1     3        32       520     2349\n#&gt; 4  2013     1     4        25       531     2358\n#&gt; 5  2013     1     5        14       534     2357\n#&gt; 6  2013     1     6        16       555     2355\n#&gt; # ℹ 359 more rows\n\n(注意：因为dplyr函数使用_来分隔函数名和参数名的组件，所以这些函数使用na_rm而不是na.rm）\n如果你熟悉[操作符，我们将在@sec-subset-many 中再次讨论它，你可能会想是否需要这些函数。有 三个原因：默认参数允许你在指定的位置不存在时提供一个默认值，order_by参数允许你局部覆盖行的顺序，而na_rm参数允许你删除缺失值。\n按位置提取值是对按秩筛选的补充。筛 选操作会返回所有变量，每个观测都在单独的一行中：\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  mutate(r = min_rank(sched_dep_time)) |&gt; \n  filter(r %in% c(1, max(r)))\n#&gt; # A tibble: 1,195 × 20\n#&gt; # Groups:   year, month, day [365]\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1     2353           2359        -6      425            445\n#&gt; 3  2013     1     1     2353           2359        -6      418            442\n#&gt; 4  2013     1     1     2356           2359        -3      425            437\n#&gt; 5  2013     1     2       42           2359        43      518            442\n#&gt; 6  2013     1     2      458            500        -2      703            650\n#&gt; # ℹ 1,189 more rows\n#&gt; # ℹ 12 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n\n\n13.6.6 利用 mutate()\n顾名思义，汇总函数通常与summarize()一起使用。但 是，因为我们在@sec-recycling 中讨论的循环规则，它们也可以与mutate()一起使用，特别是当你想进行某种分组标准化时。例 如：\n\nx / sum(x) 计算了x中每个元素占总和的比例；\n(x - mean(x)) / sd(x) 计算Z-score（将x标准化为均数为0，标准差为1）；\n(x - min(x)) / (max(x) - min(x)) 将x标准化到范围[0, 1]；\nx / first(x) 基于第一个观测值计算一个指数。\n\n\n\n13.6.7 练习\n\n头脑风暴至少5种不同的方法来评估一组航班的典型延误特性。什 么时候用mean()？什 么时候用median()？什 么情况下你可能想使用其他方法？你 应该使用到达延误还是起飞延误？为 什么你可能想使用来自planes的数据？\n哪些目的地的航速变化最大？\n创建一个图来进一步探索EGE的冒险经历。 你能找到机场变换位置的任何证据吗？你 能找到可解释这种差异的另一个变量吗？",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值</span>"
    ]
  },
  {
    "objectID": "numbers.html#小结",
    "href": "numbers.html#小结",
    "title": "13  数值",
    "section": "13.7 小结",
    "text": "13.7 小结\n你已经熟悉了许多用于数字处理的工具，在阅读本章之后也知道了如何在R中使用它们。你 还学习了一些有用的通用转换方法，这些方法通常（但不仅限于）应用于数字向量，如秩和偏移量。最 后，通过一些数字汇总进行了实践，并讨论了几个你应该考虑的统计学挑战。\n在接下来的两章中，我们将使用stringr包深入研究字符串的处理。字 符串是一个很大的主题，因此它们被分为两章，一章关于字符串的基础知识，另一章关于正则表达式。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值</span>"
    ]
  },
  {
    "objectID": "numbers.html#footnotes",
    "href": "numbers.html#footnotes",
    "title": "13  数值",
    "section": "",
    "text": "ggplot2提供了一些辅助函数来处理cut_interval(),cut_number()和cut_width()中的常见情况。虽 然ggplot2是这些函数存放的一个稍显奇怪的地方，但它们作为直方图计算的一部分非常有用，并且在 tidyverse 的其他部分出现之前就已经被编写出来了。↩︎\nmode() 函数做的是完全不同的事情!↩︎",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值</span>"
    ]
  },
  {
    "objectID": "strings.html",
    "href": "strings.html",
    "title": "14  字符串",
    "section": "",
    "text": "14.1 引言\n到目前为止，你已经使用了一堆字符串，但对它们的细节了解并不多，现在是时候深入了解它们了。学 习字符串的工作原理，并掌握一些可以使用的字符串操作工具。\n我们将从创建字符串和字符向量的细节开始。然 后，你将深入了解如何从数据中创建字符串，然后是从数据中提取字符串。接 着，我们将讨论处理单个字母的工具。本 章最后介绍了一些处理单个字母的函数，并简要讨论了在使用其他语言时，你对英语的预期可能会引导你误入歧途的情况。\n在下一章中，我们将继续使用字符串，届时你将深入了解正则表达式的强大功能。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串</span>"
    ]
  },
  {
    "objectID": "strings.html#引言",
    "href": "strings.html#引言",
    "title": "14  字符串",
    "section": "",
    "text": "14.1.1 必要条件\n在本章中，我们将使用stringr包中的函数，stringr是tidyverse的一部分。我 们还将使用babynames数据，因为它提供了一些有趣的字符串供操作。\n\nlibrary(tidyverse)\nlibrary(babynames)\n\n当你使用 stringr 函数时，你可以很容易地识别出来，因为所有的 stringr 函数都以str_开头。如 果你使用 RStudio，这尤其有用，因为输入str_会触发自动补全功能，帮助你回忆起可用的函数。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串</span>"
    ]
  },
  {
    "objectID": "strings.html#生成一个字符串",
    "href": "strings.html#生成一个字符串",
    "title": "14  字符串",
    "section": "14.2 生成一个字符串",
    "text": "14.2 生成一个字符串\n在本书的前面部分，我们曾经创建过字符串，但没有讨论细节。首 先，你可以使用单引号（'）或双引号（\"）来创建字符串。两 者在行为上没有区别，因此，为了保持一致性，tidyverse 风格指南 建议使用双引号（\"），除非字符串中包含多个\"。\n\nstring1 &lt;- \"This is a string\"\nstring2 &lt;- 'If I want to include a \"quote\" inside a string, I use single quotes'\n\n如果你漏写了结束引号，你会看到+，这是继续提示符：\n&gt; \"This is a string without a closing quote\n+ \n+ \n+ HELP I'M STUCK IN A STRING\n如果碰到了这种情况，而你又不知道漏写了哪个引号，可以按 Esc 键取消并重新尝试。\n\n14.2.1 转义符（Escapes）\n要在字符串中包含单引号或双引号，您可以使用\\ 来“转义”它：\n\ndouble_quote &lt;- \"\\\"\" # or '\"'\nsingle_quote &lt;- '\\'' # or \"'\"\n\n所以如果你想在字符串中包含一个反斜杠，你需要转义它:\"\\\\\":\n\nbackslash &lt;- \"\\\\\"\n\n请注意，字符串的输出形式与字符串本身并不相同，因为输出形式会显示转义符（换句话说，当你输出一个字符串时，你可以复制并粘贴输出来重新创建该字符串）。要 查看字符串的原始内容，请使用str_view()1：\n\nx &lt;- c(single_quote, double_quote, backslash)\nx\n#&gt; [1] \"'\"  \"\\\"\" \"\\\\\"\n\nstr_view(x)\n#&gt; [1] │ '\n#&gt; [2] │ \"\n#&gt; [3] │ \\\n\n\n\n14.2.2 原始字符串\n使用多个引号或反斜杠创建字符串很快就会让人困惑。为 了说明这个问题，我们创建一个字符串，其中包含定义double_quote和single_quote变量的代码块的内容：\n\ntricky &lt;- \"double_quote &lt;- \\\"\\\\\\\"\\\" # or '\\\"'\nsingle_quote &lt;- '\\\\'' # or \\\"'\\\"\"\nstr_view(tricky)\n#&gt; [1] │ double_quote &lt;- \"\\\"\" # or '\"'\n#&gt;     │ single_quote &lt;- '\\'' # or \"'\"\n\n这么多反斜杠!( 这有时被称为斜杠综合症)为了消除转义，你可以使用原始字符串2:\n\ntricky &lt;- r\"(double_quote &lt;- \"\\\"\" # or '\"'\nsingle_quote &lt;- '\\'' # or \"'\")\"\nstr_view(tricky)\n#&gt; [1] │ double_quote &lt;- \"\\\"\" # or '\"'\n#&gt;     │ single_quote &lt;- '\\'' # or \"'\"\n\n原始字符串通常以r\"(开头并以)\"结尾。但 是，如果你的字符串包含)\"，你可以改用r\"[]\"或r\"{}\"，如果这还不够，你可以插入任意数量的短横线来使开闭对变得唯一，例如r\"--()--\"、r\"---()---\"等。原始字符串足够灵活，可以处理任何文本。\n\n\n14.2.3 其他特殊字符\n除了\\\"、\\'和\\\\之外，还有其他一些可能有用的特殊字符。最常见的是\\n（换行）和\\t（制表符）。有时你还会看到包含以\\u或\\U 开头的 Unicode 转义序列的字符串。这是一种在所有系统上都能工作的非英文字符的写法。你可以在?Quotes中查看其他特殊字符的完整列表。\n\nx &lt;- c(\"one\\ntwo\", \"one\\ttwo\", \"\\u00b5\", \"\\U0001f604\")\nx\n#&gt; [1] \"one\\ntwo\" \"one\\ttwo\" \"µ\"        \"😄\"\nstr_view(x)\n#&gt; [1] │ one\n#&gt;     │ two\n#&gt; [2] │ one{\\t}two\n#&gt; [3] │ µ\n#&gt; [4] │ 😄\n\n请注意，str_view()使用花括号来表示制表符，以便更容易地发现它们3。 处理文本时的一个挑战是文本中可能存在多种不同形式的空白字符，因此了解这种背景知识有助于你识别是否发生了异常情况。\n\n\n14.2.4 练习\n\n创建包含以下值的字符串:\n\nHe said \"That's amazing!\"\n\\a\\b\\c\\d\n\\\\\\\\\\\\\n\n在R会话中创建字符串并输出它。特 殊字符“\\u00a0”发生了什么？s tr_view()是如何显示它的？你 能在谷歌上查一下这个特殊字符是什么吗？\n\nx &lt;- \"This\\u00a0is\\u00a0tricky\"",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串</span>"
    ]
  },
  {
    "objectID": "strings.html#从数据中创建许多字符串",
    "href": "strings.html#从数据中创建许多字符串",
    "title": "14  字符串",
    "section": "14.3 从数据中创建许多字符串",
    "text": "14.3 从数据中创建许多字符串\n既然你已经学会了“手动”创建一两个字符串的基础知识，接下来我们将详细讨论如何从其他字符串中创建字符串。这 将帮助你解决一个常见问题，即当你有一些自己写的文本并希望将其与数据框中的字符串结合时。例 如，你可能想要将“Hello”与一个名字变量结合起来创建一个问候语。我 们将向你展示如何使用str_c()和str_glue()函数来完成这个任务，以及如何在mutate()函数中使用它们。这 自然会引出一个问题，即你可能在summarize()函数中使用哪些stringr函数，因此我们将以讨论str_flatten()函数来结束这一节，它是一个用于字符串的汇总函数。\n\n14.3.1 str_c()\nstr_c() 可以接受任意数量的向量作为参数并返回一个字符向量:\n\nstr_c(\"x\", \"y\")\n#&gt; [1] \"xy\"\nstr_c(\"x\", \"y\", \"z\")\n#&gt; [1] \"xyz\"\nstr_c(\"Hello \", c(\"John\", \"Susan\"))\n#&gt; [1] \"Hello John\"  \"Hello Susan\"\n\nstr_c()的功能类似于基础R的paste0()，但它是为了与mutate()一起使用而设计的，它遵守 tidyverse 中关于循环（recycling）和缺失值传播（propagating missing values）的惯常规则。\n\ndf &lt;- tibble(name = c(\"Flora\", \"David\", \"Terra\", NA))\ndf |&gt; mutate(greeting = str_c(\"Hi \", name, \"!\"))\n#&gt; # A tibble: 4 × 2\n#&gt;   name  greeting \n#&gt;   &lt;chr&gt; &lt;chr&gt;    \n#&gt; 1 Flora Hi Flora!\n#&gt; 2 David Hi David!\n#&gt; 3 Terra Hi Terra!\n#&gt; 4 &lt;NA&gt;  &lt;NA&gt;\n\n如果你想以另一种方式显示缺失值，可以使用coalesce()函数来替换它们。根 据你的需求，可以在str_c()函数内部或外部使用coalesce()。\n\ndf |&gt; \n  mutate(\n    greeting1 = str_c(\"Hi \", coalesce(name, \"you\"), \"!\"),\n    greeting2 = coalesce(str_c(\"Hi \", name, \"!\"), \"Hi!\")\n  )\n#&gt; # A tibble: 4 × 3\n#&gt;   name  greeting1 greeting2\n#&gt;   &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;    \n#&gt; 1 Flora Hi Flora! Hi Flora!\n#&gt; 2 David Hi David! Hi David!\n#&gt; 3 Terra Hi Terra! Hi Terra!\n#&gt; 4 &lt;NA&gt;  Hi you!   Hi!\n\n\n\n14.3.2 str_glue()\n如果在使用str_c()时混合了很多固定的和可变的字符串，你会发现需要输入很多\"s，这使得很难看清代码的总体目标。为此，glue包提供了一个替代方法，即str_glue()4函数。你只需给它一个具有特殊功能的单一字符串：{}内的任何内容都会像在引号外部一样被评估。\n\ndf |&gt; mutate(greeting = str_glue(\"Hi {name}!\"))\n#&gt; # A tibble: 4 × 2\n#&gt;   name  greeting \n#&gt;   &lt;chr&gt; &lt;glue&gt;   \n#&gt; 1 Flora Hi Flora!\n#&gt; 2 David Hi David!\n#&gt; 3 Terra Hi Terra!\n#&gt; 4 &lt;NA&gt;  Hi NA!\n\n正如你所看到的，str_glue()目前将缺失值转换为字符串 “NA”，不幸的是这与str_c()的处理方式不一致。\n你也可能会想，如果需要在字符串中包含常规的{或}符号时应该怎么办。如 果你猜测需要以某种方式转义它，那么你的思路是正确的。窍 门在于glue使用了一种略有不同的转义技术：不是使用像\\这样的特殊字符作为前缀，而是将特殊字符重复两次：\n\ndf |&gt; mutate(greeting = str_glue(\"{{Hi {name}!}}\"))\n#&gt; # A tibble: 4 × 2\n#&gt;   name  greeting   \n#&gt;   &lt;chr&gt; &lt;glue&gt;     \n#&gt; 1 Flora {Hi Flora!}\n#&gt; 2 David {Hi David!}\n#&gt; 3 Terra {Hi Terra!}\n#&gt; 4 &lt;NA&gt;  {Hi NA!}\n\n\n\n14.3.3 str_flatten()\nstr_c()和str_glue()在与mutate()一起使用时效果很好，因为它们的输出与输入具有相同的长度。但 是，如果你想要一个与summarize()配合良好的函数，即一个总是返回一个单独字符串的函数，那么str_flatten()5就是为此而设计的：它接受一个字符向量，并将向量的每个元素组合成一个单独的字符串。\n\nstr_flatten(c(\"x\", \"y\", \"z\"))\n#&gt; [1] \"xyz\"\nstr_flatten(c(\"x\", \"y\", \"z\"), \", \")\n#&gt; [1] \"x, y, z\"\nstr_flatten(c(\"x\", \"y\", \"z\"), \", \", last = \", and \")\n#&gt; [1] \"x, y, and z\"\n\n这使得它可以很好地与 summarize() 一起工作：\n\ndf &lt;- tribble(\n  ~ name, ~ fruit,\n  \"Carmen\", \"banana\",\n  \"Carmen\", \"apple\",\n  \"Marvin\", \"nectarine\",\n  \"Terence\", \"cantaloupe\",\n  \"Terence\", \"papaya\",\n  \"Terence\", \"mandarin\"\n)\ndf |&gt;\n  group_by(name) |&gt; \n  summarize(fruits = str_flatten(fruit, \", \"))\n#&gt; # A tibble: 3 × 2\n#&gt;   name    fruits                      \n#&gt;   &lt;chr&gt;   &lt;chr&gt;                       \n#&gt; 1 Carmen  banana, apple               \n#&gt; 2 Marvin  nectarine                   \n#&gt; 3 Terence cantaloupe, papaya, mandarin\n\n\n\n14.3.4 练习\n\n比较和对比paste0()和str_c()对于以下输入的结果:\n\nstr_c(\"hi \", NA)\nstr_c(letters[1:2], letters[1:3])\n\npaste()和paste0()有什么区别？如 何用str_c()重建与paste()等效的功能？\n将以下表达式从str_c()转换为str_glue()，反之亦然:\n\nstr_c(\"The price of \", food, \" is \", price)\nstr_glue(\"I'm {age} years old and live in {country}\")\nstr_c(\"\\\\section{\", title, \"}\")",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串</span>"
    ]
  },
  {
    "objectID": "strings.html#从字符串提取数据",
    "href": "strings.html#从字符串提取数据",
    "title": "14  字符串",
    "section": "14.4 从字符串提取数据",
    "text": "14.4 从字符串提取数据\n将多个变量压缩到单个字符串中是很常见的。在 本节中，你将学习如何使用四个tidyr函数来提取它们：\n\ndf |&gt; separate_longer_delim(col, delim)\ndf |&gt; separate_longer_position(col, width)\ndf |&gt; separate_wider_delim(col, delim, names)\ndf |&gt; separate_wider_position(col, widths)\n\n如果仔细观察，就会发现这里有一个共同的模式：首先separate_，然后longer 或 wider，接着_，最后通过分隔符或位置来进一步处理。这 是因为这四个函数是由两个更简单的原语组成的：\n\n正如pivot_longer()和pivot_wider()一样，以_longer结尾的函数通过创建新的行来使输入的数据框变长，而以_wider结尾的函数则通过生成新的列来使输入的数据框变宽。\ndelim使用像\", \"”或 \" \"这样的分隔符来拆分字符串；而position则按照指定的宽度进行拆分，如c(3, 5, 2)。\n\n我们将在@sec-regular-expressions 中再次回到这个家族中的最后一个成员separate_wider_regex()。它 是这些wider函数中最灵活的，但你需要对正则表达式有所了解才能使用它。\n接下来的两个部分将向你介绍这些拆分函数背后的基本思想，首先是按行拆分（这稍微简单一些），然后是按列拆分。最 后，将讨论wider函数提供的用于诊断问题的工具。\n\n14.4.1 拆分成行\n当字符串中组件的数量在每行之间变化时，将字符串拆分成行往往是最有用的。最 常见的情况是，需要separate_longer_delim()基于分隔符进行拆分：\n\ndf1 &lt;- tibble(x = c(\"a,b,c\", \"d,e\", \"f\"))\ndf1 |&gt; \n  separate_longer_delim(x, delim = \",\")\n#&gt; # A tibble: 6 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 a    \n#&gt; 2 b    \n#&gt; 3 c    \n#&gt; 4 d    \n#&gt; 5 e    \n#&gt; 6 f\n\n在实际情况中，separate_longer_position()的使用较少见，但一些较旧的数据集确实使用了非常紧凑的格式，其中每个字符都用于记录一个值：\n\ndf2 &lt;- tibble(x = c(\"1211\", \"131\", \"21\"))\ndf2 |&gt; \n  separate_longer_position(x, width = 1)\n#&gt; # A tibble: 9 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 1    \n#&gt; 2 2    \n#&gt; 3 1    \n#&gt; 4 1    \n#&gt; 5 1    \n#&gt; 6 3    \n#&gt; # ℹ 3 more rows\n\n\n\n14.4.2 拆分成列\n当每个字符串中组件数量固定，并且希望将它们分散到列中时，将字符串拆分成列往往是最有用的。它 们比其longer对等项稍微复杂一些，因为你需要为列命名。例 如，在以下数据集中，x由代码、版号和年份组成，它们之间由\".\"分隔。要 使用separate_wider_delim()，我们需要在两个参数中提供分隔符和列名：\n\ndf3 &lt;- tibble(x = c(\"a10.1.2022\", \"b10.2.2011\", \"e15.1.2015\"))\ndf3 |&gt; \n  separate_wider_delim(\n    x,\n    delim = \".\",\n    names = c(\"code\", \"edition\", \"year\")\n  )\n#&gt; # A tibble: 3 × 3\n#&gt;   code  edition year \n#&gt;   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;\n#&gt; 1 a10   1       2022 \n#&gt; 2 b10   2       2011 \n#&gt; 3 e15   1       2015\n\n如果某个特定部分没有用，你可以使用NA作为列名来在结果中省略它：\n\ndf3 |&gt; \n  separate_wider_delim(\n    x,\n    delim = \".\",\n    names = c(\"code\", NA, \"year\")\n  )\n#&gt; # A tibble: 3 × 2\n#&gt;   code  year \n#&gt;   &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 a10   2022 \n#&gt; 2 b10   2011 \n#&gt; 3 e15   2015\n\nseparate_wider_position()的工作方式略有不同，因为你通常需要指定每个列的宽度。因 此，你给它一个命名的整数向量，其中名称给出新列的名称，而值是它所占据的字符数。你 可以通过不命名某些值来从输出中省略它们：\n\ndf4 &lt;- tibble(x = c(\"202215TX\", \"202122LA\", \"202325CA\")) \ndf4 |&gt; \n  separate_wider_position(\n    x,\n    widths = c(year = 4, age = 2, state = 2)\n  )\n#&gt; # A tibble: 3 × 3\n#&gt;   year  age   state\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 2022  15    TX   \n#&gt; 2 2021  22    LA   \n#&gt; 3 2023  25    CA\n\n\n\n14.4.3 诊断扩展问题\nseparate_wider_delim()6 需要一个固定且已知数量的列。 如果某些行没有预期数量的组件怎么办？ 可能存在两种问题，即组件太少或太多，因此separate_wider_delim()提供了too_few和too_many两个参数来帮助处理这些问题。 首先，让我们使用以下示例数据集来查看too_few的情况：\n\ndf &lt;- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3\", \"1-3-2\", \"1\"))\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\")\n  )\n#&gt; Error in `separate_wider_delim()`:\n#&gt; ! Expected 3 pieces in each element of `x`.\n#&gt; ! 2 values were too short.\n#&gt; ℹ Use `too_few = \"debug\"` to diagnose the problem.\n#&gt; ℹ Use `too_few = \"align_start\"/\"align_end\"` to silence this message.\n\n你会得到一个错误提示，但错误消息给出了一些关于如何继续进行的建议。让 我们开始调试这个问题：\n\ndebug &lt;- df |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_few = \"debug\"\n  )\n#&gt; Warning: Debug mode activated: adding variables `x_ok`, `x_pieces`, and\n#&gt; `x_remainder`.\ndebug\n#&gt; # A tibble: 5 × 6\n#&gt;   x     y     z     x_ok  x_pieces x_remainder\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;      \n#&gt; 1 1-1-1 1     1     TRUE         3 \"\"         \n#&gt; 2 1-1-2 1     2     TRUE         3 \"\"         \n#&gt; 3 1-3   3     &lt;NA&gt;  FALSE        2 \"\"         \n#&gt; 4 1-3-2 3     2     TRUE         3 \"\"         \n#&gt; 5 1     &lt;NA&gt;  &lt;NA&gt;  FALSE        1 \"\"\n\n当使用调试模式时，你会在输出中看到添加了三个额外的列：x_ok、x_pieces和x_remainder（如果你使用不同名称的变量进行拆分，你会得到一个不同的前缀）。在 这里，x_ok允许你快速找到那些失败的输入：\n\ndebug |&gt; filter(!x_ok)\n#&gt; # A tibble: 2 × 6\n#&gt;   x     y     z     x_ok  x_pieces x_remainder\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;      \n#&gt; 1 1-3   3     &lt;NA&gt;  FALSE        2 \"\"         \n#&gt; 2 1     &lt;NA&gt;  &lt;NA&gt;  FALSE        1 \"\"\n\nx_pieces告诉我们找到了多少组件。与 预期的 3 个（names的长度）相比，当得到的组件数量少于预期时，x_remainder并不太有用，但稍后我们会再次看到它。\n有时查看这些调试信息会发现你的分隔符策略有问题，或者建议你在拆分之前需要进行更多的预处理。在 这种情况下，解决上游问题并确保移除too_few = \"debug\"以确保新问题变成错误。\n在其他情况下，你可能想用 NAs填充缺失的组件并继续。这 就是too_few = \"align_start\"和too_few = \"align_end\"的作用，它们允许你控制 NAs应该放在哪里：\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_few = \"align_start\"\n  )\n#&gt; # A tibble: 5 × 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     1     1    \n#&gt; 2 1     1     2    \n#&gt; 3 1     3     &lt;NA&gt; \n#&gt; 4 1     3     2    \n#&gt; 5 1     &lt;NA&gt;  &lt;NA&gt;\n\n如果你有太多的组件，同样的原则也适用:\n\ndf &lt;- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3-5-6\", \"1-3-2\", \"1-3-5-7-9\"))\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\")\n  )\n#&gt; Error in `separate_wider_delim()`:\n#&gt; ! Expected 3 pieces in each element of `x`.\n#&gt; ! 2 values were too long.\n#&gt; ℹ Use `too_many = \"debug\"` to diagnose the problem.\n#&gt; ℹ Use `too_many = \"drop\"/\"merge\"` to silence this message.\n\n但是现在，当我们调试结果时，你可以看到 x_remainder 的目的：\n\ndebug &lt;- df |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"debug\"\n  )\n#&gt; Warning: Debug mode activated: adding variables `x_ok`, `x_pieces`, and\n#&gt; `x_remainder`.\ndebug |&gt; filter(!x_ok)\n#&gt; # A tibble: 2 × 6\n#&gt;   x         y     z     x_ok  x_pieces x_remainder\n#&gt;   &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;      \n#&gt; 1 1-3-5-6   3     5     FALSE        4 -6         \n#&gt; 2 1-3-5-7-9 3     5     FALSE        5 -7-9\n\n处理过多组件时，会有一些稍微不同的选项：你可以选择静默地“删除”任何额外的组件，或者将它们全部“合并”到最后一列：\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"drop\"\n  )\n#&gt; # A tibble: 5 × 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     1     1    \n#&gt; 2 1     1     2    \n#&gt; 3 1     3     5    \n#&gt; 4 1     3     2    \n#&gt; 5 1     3     5\n\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"merge\"\n  )\n#&gt; # A tibble: 5 × 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     1     1    \n#&gt; 2 1     1     2    \n#&gt; 3 1     3     5-6  \n#&gt; 4 1     3     2    \n#&gt; 5 1     3     5-7-9",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串</span>"
    ]
  },
  {
    "objectID": "strings.html#字母",
    "href": "strings.html#字母",
    "title": "14  字符串",
    "section": "14.5 字母",
    "text": "14.5 字母\n在本节中，我们将介绍一些函数，这些函数允许你处理字符串中的单个字母。你 将学习如何查找字符串的长度、提取子字符串以及在图和表中处理长字符串。\n\n14.5.1 长度\nstr_length()告诉你字符串中字母的数量:\n\nstr_length(c(\"a\", \"R for data science\", NA))\n#&gt; [1]  1 18 NA\n\n你可以使用count()来查找美国婴儿名字长度的分布情况，然后使用filter()来查看最长的名字，这些名字恰好有 15 个字母7。\n\nbabynames |&gt;\n  count(length = str_length(name), wt = n)\n#&gt; # A tibble: 14 × 2\n#&gt;   length        n\n#&gt;    &lt;int&gt;    &lt;int&gt;\n#&gt; 1      2   338150\n#&gt; 2      3  8589596\n#&gt; 3      4 48506739\n#&gt; 4      5 87011607\n#&gt; 5      6 90749404\n#&gt; 6      7 72120767\n#&gt; # ℹ 8 more rows\n\nbabynames |&gt; \n  filter(str_length(name) == 15) |&gt; \n  count(name, wt = n, sort = TRUE)\n#&gt; # A tibble: 34 × 2\n#&gt;   name                n\n#&gt;   &lt;chr&gt;           &lt;int&gt;\n#&gt; 1 Franciscojavier   123\n#&gt; 2 Christopherjohn   118\n#&gt; 3 Johnchristopher   118\n#&gt; 4 Christopherjame   108\n#&gt; 5 Christophermich    52\n#&gt; 6 Ryanchristopher    45\n#&gt; # ℹ 28 more rows\n\n\n\n14.5.2 提取子集\n你可以使用str_sub(string, start, end)来提取字符串的一部分，其中start和end是子字符串开始和结束的位置。s tart和end参数是包含性的，因此返回的字符串的长度将是end - start + 1。\n\nx &lt;- c(\"Apple\", \"Banana\", \"Pear\")\nstr_sub(x, 1, 3)\n#&gt; [1] \"App\" \"Ban\" \"Pea\"\n\n你也可以使用负值来从字符串的末尾开始计数：-1 是最后一个字符，-2 是倒数第二个字符，依此类推。\n\nstr_sub(x, -3, -1)\n#&gt; [1] \"ple\" \"ana\" \"ear\"\n\n请注意，如果字符串太短，str_sub()不会失败，它将返回尽可能多的字符：\n\nstr_sub(\"a\", 1, 5)\n#&gt; [1] \"a\"\n\n我们可以使用str_sub()与mutate()来找到每个名字的首字母和末字母：\n\nbabynames |&gt; \n  mutate(\n    first = str_sub(name, 1, 1),\n    last = str_sub(name, -1, -1)\n  )\n#&gt; # A tibble: 1,924,665 × 7\n#&gt;    year sex   name          n   prop first last \n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;int&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1  1880 F     Mary       7065 0.0724 M     y    \n#&gt; 2  1880 F     Anna       2604 0.0267 A     a    \n#&gt; 3  1880 F     Emma       2003 0.0205 E     a    \n#&gt; 4  1880 F     Elizabeth  1939 0.0199 E     h    \n#&gt; 5  1880 F     Minnie     1746 0.0179 M     e    \n#&gt; 6  1880 F     Margaret   1578 0.0162 M     t    \n#&gt; # ℹ 1,924,659 more rows\n\n\n\n14.5.3 练习\n\n在计算婴儿名字长度的分布时，为什么我们使用 wt = n？\n使用str_length()和str_sub()从每个婴儿的名字中提取中间的字母。如果字符串有偶数个字符，你会怎么做？\n随着时间的推移，babynames的长度有什么主要趋势吗？首字母和尾字母的流行程度如何？",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串</span>"
    ]
  },
  {
    "objectID": "strings.html#sec-other-languages",
    "href": "strings.html#sec-other-languages",
    "title": "14  字符串",
    "section": "14.6 非英语文本",
    "text": "14.6 非英语文本\n到目前为止，我们主要关注英文文本，这是因为两个原因使其特别易于处理。首 先，英文字母表相对简单：只有26个字母。其 次（也许是更重要的），我们今天使用的计算基础设施主要是由英语使用者设计的。不 幸的是，我们没有篇幅全面介绍非英语语言。不 过，我们还是想提醒你们注意可能会遇到的一些最大挑战：编码、字母变化和依赖于地区的函数。\n\n14.6.1 编码\n在处理非英文文本时，第一个挑战通常是编码。为 了了解正在发生的事情，我们需要深入了解计算机如何表示字符串。在 R中，我们可以使用charToRaw()来获取字符串的底层表示：\n\ncharToRaw(\"Hadley\")\n#&gt; [1] 48 61 64 6c 65 79\n\n这六个十六进制数字中的每一个都代表一个字母：48 是 H，61 是 a，以此类推。从 十六进制数字到字符的映射称为编码，在这种情况下，这种编码称为 ASCII。A SCII 在表示英文字符方面做得很好，因为它是美国信息交换标准代码（American Standard Code for Information Interchange）。\n对于非英文语言来说，事情就没那么简单了。在 计算机发展的早期，有许多相互竞争的标准用于编码非英文字符。例 如，欧洲有两种不同的编码：Latin1（也称为 ISO-8859-1）用于西欧语言，而 Latin2（也称为 ISO-8859-2）用于中欧语言。在 Latin1 中，字节 b1 是“±”，但在 Latin2 中，它是“ą”！幸 运的是，今天几乎在所有地方都支持一个标准：UTF-8。U TF-8 可以编码今天人类使用的几乎所有字符，以及许多额外的符号，如表情符号。\nreadr在所有地方都使用 UTF-8。这 是一个很好的默认设置，但对于不使用 UTF-8 的旧系统生成的数据将会失败。如 果发生这种情况，当你输出字符串时，它们看起来会很奇怪。有 时只是一个或两个字符可能会出错；在其他时候，你会得到完全乱码。例 如，以下是两个具有异常编码的内联 CSV8：\n\nx1 &lt;- \"text\\nEl Ni\\xf1o was particularly bad this year\"\nread_csv(x1)$text\n#&gt; [1] \"El Ni\\xf1o was particularly bad this year\"\n\nx2 &lt;- \"text\\n\\x82\\xb1\\x82\\xf1\\x82\\xc9\\x82\\xbf\\x82\\xcd\"\nread_csv(x2)$text\n#&gt; [1] \"\\x82\\xb1\\x82\\xf1\\x82ɂ\\xbf\\x82\\xcd\"\n\n要正确读取这些，您可以通过locale 参数指定编码:\n\nread_csv(x1, locale = locale(encoding = \"Latin1\"))$text\n#&gt; [1] \"El Niño was particularly bad this year\"\n\nread_csv(x2, locale = locale(encoding = \"Shift-JIS\"))$text\n#&gt; [1] \"こんにちは\"\n\n如何找到正确的编码？如 果你很幸运，它可能会在数据文档中的某个地方被提及。不 幸的是，这种情况很少见，所以readr提供了guess_encoding()来帮助你找出它。这 并不是万无一失的，并且在有大量文本时（与这里不同）效果会更好，但这是一个合理的起点。预 计在你找到正确的编码之前，需要尝试几种不同的编码。\n编码是一个丰富且复杂的话题；我们在这里只是触及了皮毛。如 果你想了解更多，我们推荐阅读 http://kunststube.net/encoding/上的详细解释。\n\n\n14.6.2 字母变体\n在使用带有重音的语言时，确定字母的位置（例如使用str_length()和str_sub()）会面临重大挑战，因为重音字母可能会被编码为一个单独的字符（例如，ü）或者通过将不带重音的字母（例如，u）与变音符号（例如，¨）组合成两个字符来表示。例 如，以下代码展示了两种看起来相同的表示 ü 的方式：\n\nu &lt;- c(\"\\u00fc\", \"u\\u0308\")\nstr_view(u)\n#&gt; [1] │ ü\n#&gt; [2] │ ü\n\n但是两个字符串的长度不同，它们的第一个字符也不同:\n\nstr_length(u)\n#&gt; [1] 1 2\nstr_sub(u, 1, 1)\n#&gt; [1] \"ü\" \"u\"\n\n最后，请注意，使用==来比较这些字符串时，它们会被解释为不同的字符串，而stringr包中的str_equal()函数则会识别出两者具有相同的外观。\n\nu[[1]] == u[[2]]\n#&gt; [1] FALSE\n\nstr_equal(u[[1]], u[[2]])\n#&gt; [1] TRUE\n\n\n\n14.6.3 区域依赖函数\n最后，有一些stringr函数的行为取决于你的区域（locale）。区 域类似于一种语言，但包括一个可选的区域标识符来处理语言内的地区差异。区 域由小写语言缩写指定，后面可以选择性地跟上一个下划线和一个大写区域标识符。例 如，“en”代表英语，“en_GB”代表英国英语，而“en_US”代表美国英语。如 果你还不知道你的语言的代码，维基百科有一个很好的列表，你可以通过查看stringi::stri_locale_list()来查看stringr支持哪些区域。\n基础R的字符串函数会自动使用你的操作系统设置的区域。这 意味着基础R的字符串函数会按照你期望的方式处理你的语言，但如果你与来自不同国家的人分享你的代码，代码的行为可能会有所不同。为 了避免这个问题，stringr默认使用“en”区域（即英语规则），并要求你指定locale 参数来覆盖它。幸 运的是，只有两组函数在处理时需要考虑区域：改变大小写和排序。\n改变大小写的规则在不同语言之间有所不同。例 如，土耳其语有两种i：带点和不带点。由 于它们是两个不同的字母，所以它们的大写形式也不同：\n\nstr_to_upper(c(\"i\", \"ı\"))\n#&gt; [1] \"I\" \"I\"\nstr_to_upper(c(\"i\", \"ı\"), locale = \"tr\")\n#&gt; [1] \"İ\" \"I\"\n\n字符串排序依赖于字母表的顺序，而字母表的顺序并不是每种语言都相同的9！ 举个例子：在捷克语中，“ch”是一个复合字母，它在字母表中出现在字母h之后。\n\nstr_sort(c(\"a\", \"c\", \"ch\", \"h\", \"z\"))\n#&gt; [1] \"a\"  \"c\"  \"ch\" \"h\"  \"z\"\nstr_sort(c(\"a\", \"c\", \"ch\", \"h\", \"z\"), locale = \"cs\")\n#&gt; [1] \"a\"  \"c\"  \"h\"  \"ch\" \"z\"\n\nThis also comes up when sorting strings with dplyr::arrange(), which is why it also has a locale argument.",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串</span>"
    ]
  },
  {
    "objectID": "strings.html#小结",
    "href": "strings.html#小结",
    "title": "14  字符串",
    "section": "14.7 小结",
    "text": "14.7 小结\n在本章中，你已经了解了stringr包的一些强大功能：如何创建、组合和提取字符串，以及在使用非英文字符串时可能遇到的一些挑战。现 在是时候学习处理字符串的最重要和强大的工具之一：正则表达式了。正 则表达式是一种非常简洁但非常富有表现力的语言，用于描述字符串中的模式，其是下一章讨论的主题。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串</span>"
    ]
  },
  {
    "objectID": "strings.html#footnotes",
    "href": "strings.html#footnotes",
    "title": "14  字符串",
    "section": "",
    "text": "或使用基础R函数 writeLines().↩︎\n在R 4.0.0及更高版本中可用。↩︎\nstr_view() 也使用颜色来引起你对制表符、空格、匹配等的注意。这 些颜色目前不会在书中显示，但在交互式运行代码时你会注意到它们。↩︎\n如果不使用stringr，你也可以用glue::glue()直接访问它。↩︎\nThe base R equivalent is paste() used with the collapse argument.↩︎\n同样的原则也适用于 separate_wider_position() 和 separate_wider_regex()。↩︎\n看看这些条目，我们猜测babynames数据会省略空格或连字符，并在15个字母之后截断。↩︎\n这里我使用特殊的\\x将二进制数据直接编码为字符串。↩︎\n在没有字母表的语言中排序，比如中文，就更加复杂了。↩︎",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串</span>"
    ]
  },
  {
    "objectID": "regexps.html",
    "href": "regexps.html",
    "title": "15  正则表达式",
    "section": "",
    "text": "15.1 引言\n在 章节 14 部分，你学习了一系列用于处理字符串的有用函数。本 章将重点介绍使用正则表达式的函数，正则表达式（regular expression）是一种简洁而强大的语言，用于描述字符串中的模式。术 语“正则表达式”有点长，所以大多数人将其缩写为“regex”1或“regexp”。\n本章首先介绍正则表达式的基础知识以及数据分析中最有用的stringr函数。然 后，我们将扩展你对模式的了解，并介绍七个重要的新主题（转义、锚定、字符类、简写类、量词、优先级和分组）。接 下来，我们将讨论stringr函数可以处理的其他类型的模式，以及允许你调整正则表达式操作的各种“标志”。最 后，我们将概述tidyverse和base R中可能会使用正则表达式的其他地方。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "regexps.html#引言",
    "href": "regexps.html#引言",
    "title": "15  正则表达式",
    "section": "",
    "text": "15.1.1 必要条件\n在本章中，我们将使用tidyverse的核心成员stringr和tidyr中的正则表达式函数，以及babynames包中的数据。\n\nlibrary(tidyverse)\nlibrary(babynames)\n\n在本章中，我们将使用非常简单的内联示例的混合方式，以便你能够理解基本概念，还会使用babynames数据集中的数据，以及来自stringr的三个字符向量：\n\nfruit 包含了80种水果的名称。\nwords 包含了980个常见的英语单词。\nsentences 包含了720个短句。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "regexps.html#sec-reg-basics",
    "href": "regexps.html#sec-reg-basics",
    "title": "15  正则表达式",
    "section": "15.2 模式的基础",
    "text": "15.2 模式的基础\n我们将使用str_view()来学习正则表达式模式是如何工作的。在 上一章中，我们使用str_view()来更好地理解字符串与其输出表示之间的区别，现在我们将使用它的第二个参数，即正则表达式。当 提供这个参数时，str_view()将仅显示字符串向量中匹配的部分，将每个匹配项用&lt; &gt;括起来，并在可能的情况下将匹配项以蓝色高亮显示。\n最简单的模式由字母和数字组成，它们会精确匹配这些字符：\n\nstr_view(fruit, \"berry\")\n#&gt;  [6] │ bil&lt;berry&gt;\n#&gt;  [7] │ black&lt;berry&gt;\n#&gt; [10] │ blue&lt;berry&gt;\n#&gt; [11] │ boysen&lt;berry&gt;\n#&gt; [19] │ cloud&lt;berry&gt;\n#&gt; [21] │ cran&lt;berry&gt;\n#&gt; ... and 8 more\n\n字母和数字进行精确匹配，被称为字面字符（literal characters）。大 多数标点符号字符，如.、+、*、[、]和? 具有特殊含义2，被称为元字符（metacharacters）。 例如，.将匹配任何字符3，所以 \"a.\" 将匹配任何包含 “a” 后面跟着另一个字符的字符串 ：\n\nstr_view(c(\"a\", \"ab\", \"ae\", \"bd\", \"ea\", \"eab\"), \"a.\")\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;ae&gt;\n#&gt; [6] │ e&lt;ab&gt;\n\n或者，我们可以找到所有包含“a”，后跟三个字母，再后跟“e”的水果：\n\nstr_view(fruit, \"a...e\")\n#&gt;  [1] │ &lt;apple&gt;\n#&gt;  [7] │ bl&lt;ackbe&gt;rry\n#&gt; [48] │ mand&lt;arine&gt;\n#&gt; [51] │ nect&lt;arine&gt;\n#&gt; [62] │ pine&lt;apple&gt;\n#&gt; [64] │ pomegr&lt;anate&gt;\n#&gt; ... and 2 more\n\n量词（Quantifiers） 控制模式可以匹配的次数：\n\n? 使得一个模式变为可选的（即它匹配0次或1次）\n+ 允许一个模式重复（即它至少匹配一次）\n* 允许一个模式变为可选的或重复（即它匹配任意次数，包括0次）\n\n\n# ab? matches an \"a\", optionally followed by a \"b\".\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab?\")\n#&gt; [1] │ &lt;a&gt;\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;ab&gt;b\n\n# ab+ matches an \"a\", followed by at least one \"b\".\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab+\")\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;abb&gt;\n\n# ab* matches an \"a\", followed by any number of \"b\"s.\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab*\")\n#&gt; [1] │ &lt;a&gt;\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;abb&gt;\n\n字符类（Character classes）由[]定义，允许你匹配一组字符，例如，[abcd]匹配“a”、“b”、“c”或“d”。你 也可以通过在开头使用^来反转匹配：[^abcd]匹配除“a”、“b”、“c”或“d”之外的任何字符。我 们可以利用这个思路来查找被元音字母包围的“x”，或者被辅音字母包围的“y”。\n\nstr_view(words, \"[aeiou]x[aeiou]\")\n#&gt; [284] │ &lt;exa&gt;ct\n#&gt; [285] │ &lt;exa&gt;mple\n#&gt; [288] │ &lt;exe&gt;rcise\n#&gt; [289] │ &lt;exi&gt;st\nstr_view(words, \"[^aeiou]y[^aeiou]\")\n#&gt; [836] │ &lt;sys&gt;tem\n#&gt; [901] │ &lt;typ&gt;e\n\n你可以使用分隔符（alternation）| 在一个或多个备选模式中进行选择。例 如，下面的模式会查找包含“apple”、“melon”或“nut”，或者一个重复元音字母的水果。\n\nstr_view(fruit, \"apple|melon|nut\")\n#&gt;  [1] │ &lt;apple&gt;\n#&gt; [13] │ canary &lt;melon&gt;\n#&gt; [20] │ coco&lt;nut&gt;\n#&gt; [52] │ &lt;nut&gt;\n#&gt; [62] │ pine&lt;apple&gt;\n#&gt; [72] │ rock &lt;melon&gt;\n#&gt; ... and 1 more\nstr_view(fruit, \"aa|ee|ii|oo|uu\")\n#&gt;  [9] │ bl&lt;oo&gt;d orange\n#&gt; [33] │ g&lt;oo&gt;seberry\n#&gt; [47] │ lych&lt;ee&gt;\n#&gt; [66] │ purple mangost&lt;ee&gt;n\n\n正则表达式非常紧凑，使用了大量标点符号字符，所以一开始可能会显得让人难以理解和难以阅读。不 过不用担心，随着不断实践，你会越来越熟练，简单的模式很快就会变得驾轻就熟。让 我们通过练习一些有用的stringr函数来开始这个过程吧。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "regexps.html#sec-stringr-regex-funs",
    "href": "regexps.html#sec-stringr-regex-funs",
    "title": "15  正则表达式",
    "section": "15.3 关键函数",
    "text": "15.3 关键函数\n既然你已经掌握了正则表达式的基础知识，接下来就让我们使用stringr和tidyr函数来应用它们吧。在 以下部分，你将学习如何检测匹配项是否存在，如何计算匹配项的数量，如何用固定文本替换匹配项，以及如何使用模式来提取文本。\n\n15.3.1 检测匹配项\nstr_detect() 函数返回一个逻辑向量，如果模式与字符向量中的某个元素匹配，则返回TRUE，否则返回FALSE：\n\nstr_detect(c(\"a\", \"b\", \"c\"), \"[aeiou]\")\n#&gt; [1]  TRUE FALSE FALSE\n\n由于str_detect()返回一个与初始向量长度相同的逻辑向量，因此能与filter()搭配很好。例 如，这段代码用于查找所有包含小写字母”x”的最受欢迎的名字：\n\nbabynames |&gt; \n  filter(str_detect(name, \"x\")) |&gt; \n  count(name, wt = n, sort = TRUE)\n#&gt; # A tibble: 974 × 2\n#&gt;   name           n\n#&gt;   &lt;chr&gt;      &lt;int&gt;\n#&gt; 1 Alexander 665492\n#&gt; 2 Alexis    399551\n#&gt; 3 Alex      278705\n#&gt; 4 Alexandra 232223\n#&gt; 5 Max       148787\n#&gt; 6 Alexa     123032\n#&gt; # ℹ 968 more rows\n\n还可以通过将str_detect()与summarize()结合，并搭配sum()或mean()来使用。s um(str_detect(x, pattern))告诉你匹配的观测的数量，而mean(str_detect(x, pattern))告诉你匹配的比例。例 如，以下代码段计算和可视化了按年份划分的婴儿名字4 包含”x”的比例。 看来最近它们的受欢迎程度大幅增加了！\n\nbabynames |&gt; \n  group_by(year) |&gt; \n  summarize(prop_x = mean(str_detect(name, \"x\"))) |&gt; \n  ggplot(aes(x = year, y = prop_x)) + \n  geom_line()\n\n\n\n\n\n\n\n\n与str_detect()密切相关的两个函数是str_subset()和str_which()。s tr_subset()返回一个只包含匹配字符串的字符向量；str_which()返回一个给出匹配字符串位置的整数向量。\n\n\n15.3.2 匹配次数\n从复杂度来看，比str_detect()更进一步的是str_count()：它不仅仅告诉你匹配与否，还会告诉你每个字符串中有多少匹配项。\n\nx &lt;- c(\"apple\", \"banana\", \"pear\")\nstr_count(x, \"p\")\n#&gt; [1] 2 0 1\n\n请注意，每个匹配都从上一个匹配的末尾开始，即正则表达式匹配永远不会重叠。例 如，在\"abababa\"中，\"aba\"模式将匹配多少次？正 则表达式说是两次，而不是三次：\n\nstr_count(\"abababa\", \"aba\")\n#&gt; [1] 2\nstr_view(\"abababa\", \"aba\")\n#&gt; [1] │ &lt;aba&gt;b&lt;aba&gt;\n\nstr_count()与mutate()结合使用是很自然的。下 面的示例使用str_count()与字符类来计算每个名字中的元音和辅音字母的数量。\n\nbabynames |&gt; \n  count(name) |&gt; \n  mutate(\n    vowels = str_count(name, \"[aeiou]\"),\n    consonants = str_count(name, \"[^aeiou]\")\n  )\n#&gt; # A tibble: 97,310 × 4\n#&gt;   name          n vowels consonants\n#&gt;   &lt;chr&gt;     &lt;int&gt;  &lt;int&gt;      &lt;int&gt;\n#&gt; 1 Aaban        10      2          3\n#&gt; 2 Aabha         5      2          3\n#&gt; 3 Aabid         2      2          3\n#&gt; 4 Aabir         1      2          3\n#&gt; 5 Aabriella     5      4          5\n#&gt; 6 Aada          1      2          2\n#&gt; # ℹ 97,304 more rows\n\n如果仔细观察，你会注意到我们的计算有些问题：“Aaban” 包含三个 “a”，但我们的汇总报告只显示了两个元音字母。这 是因为正则表达式是区分大小写的。有 三种方法可以修复这个问题：\n\n将大写元音字母添加到字符类中：\nstr_count(name, \"[aeiouAEIOU]\")。\n告诉正则表达式忽略大小写：\nstr_count(name, regex(\"[aeiou]\", ignore_case = TRUE))。\n我们将在 小节 15.5.1 讨论更多内容。\n使用str_to_lower()将名字转换为小写：\nstr_count(str_to_lower(name), \"[aeiou]\")。\n\n在处理字符串时，这种多样化的方法是非常典型的——通常有多种方式可以达到你的目标，要么是通过使你的模式更复杂，要么是对你的字符串进行一些预处理。如 果你在使用一种方法时遇到困难，从另一个角度解决问题往往是有用的。\n在这种情况下，由于我们对名字应用了两个函数，我认为先转换它更容易：\n\nbabynames |&gt; \n  count(name) |&gt; \n  mutate(\n    name = str_to_lower(name),\n    vowels = str_count(name, \"[aeiou]\"),\n    consonants = str_count(name, \"[^aeiou]\")\n  )\n#&gt; # A tibble: 97,310 × 4\n#&gt;   name          n vowels consonants\n#&gt;   &lt;chr&gt;     &lt;int&gt;  &lt;int&gt;      &lt;int&gt;\n#&gt; 1 aaban        10      3          2\n#&gt; 2 aabha         5      3          2\n#&gt; 3 aabid         2      3          2\n#&gt; 4 aabir         1      3          2\n#&gt; 5 aabriella     5      5          4\n#&gt; 6 aada          1      3          1\n#&gt; # ℹ 97,304 more rows\n\n\n\n15.3.3 替换值\n除了检测和计算匹配项之外，我们还可以使用str_replace()和str_replace_all()来修改它们。s tr_replace()替换第一个匹配项，如其名所示；str_replace_all()则会替换所有匹配项。\n\nx &lt;- c(\"apple\", \"pear\", \"banana\")\nstr_replace_all(x, \"[aeiou]\", \"-\")\n#&gt; [1] \"-ppl-\"  \"p--r\"   \"b-n-n-\"\n\nstr_remove() and str_remove_all() are handy shortcuts for str_replace(x, pattern, \"\"):\n\nx &lt;- c(\"apple\", \"pear\", \"banana\")\nstr_remove_all(x, \"[aeiou]\")\n#&gt; [1] \"ppl\" \"pr\"  \"bnn\"\n\n在进行数据清洗时，这些函数通常会与mutate()一起使用，并且你会经常反复应用它们来消除不一致格式的多层结构。\n\n\n15.3.4 提取变量\n我们要讨论的最后一个函数separate_wider_regex()使用正则表达式将数据从一个列提取到一个或多个新列中。它 与你在 小节 14.4.2 中了解的separate_wider_position()和separate_wider_delim()是同类函数。这 些函数存在于tidyr中，因为它们操作的是数据框（的列），而不是单独的向量。\n让我们创建一个简单的数据集来展示它的工作原理。这 里我们有一些从babynames派生的数据，其中包含了一些人的名字、性别和年龄，但这些数据的格式相当奇怪的5：\n\ndf &lt;- tribble(\n  ~str,\n  \"&lt;Sheryl&gt;-F_34\",\n  \"&lt;Kisha&gt;-F_45\", \n  \"&lt;Brandon&gt;-N_33\",\n  \"&lt;Sharon&gt;-F_38\", \n  \"&lt;Penny&gt;-F_58\",\n  \"&lt;Justin&gt;-M_41\", \n  \"&lt;Patricia&gt;-F_84\", \n)\n\n要使用separate_wider_regex()提取这些数据，我们只需要构建一系列与每个部分匹配的正则表达式。如 果希望该部分内容出现在输出中，给它指定一个名称：\n\ndf |&gt; \n  separate_wider_regex(\n    str,\n    patterns = c(\n      \"&lt;\", \n      name = \"[A-Za-z]+\", \n      \"&gt;-\", \n      gender = \".\",\n      \"_\",\n      age = \"[0-9]+\"\n    )\n  )\n#&gt; # A tibble: 7 × 3\n#&gt;   name    gender age  \n#&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;\n#&gt; 1 Sheryl  F      34   \n#&gt; 2 Kisha   F      45   \n#&gt; 3 Brandon N      33   \n#&gt; 4 Sharon  F      38   \n#&gt; 5 Penny   F      58   \n#&gt; 6 Justin  M      41   \n#&gt; # ℹ 1 more row\n\n如果匹配失败，你可以使用too_few = \"debug\"来找出问题所在，就像separate_wider_delim()和separate_wider_position()一样。\n\n\n15.3.5 练习\n\n哪个婴儿名字中含有的元音字母最多？哪 个名字的元音字母比例最高？（ 提示：分母是什么？）\n将 \"a/b/c/d/e\" 中的所有正斜杠（/）替换为反斜杠（\\）。如 果 试图通过将所有反斜杠替换为正斜杠来撤销这个转换会发生什么？（ 我们很快就会讨论这个问题。）\n使用str_replace_all()实现一个简单的str_to_lower()版本。\n创建一个正则表达式，用来匹配你所在国家常见的电话号码书写方式。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "regexps.html#模式的细节",
    "href": "regexps.html#模式的细节",
    "title": "15  正则表达式",
    "section": "15.4 模式的细节",
    "text": "15.4 模式的细节\n现在你已经了解了模式语言的基础知识，以及如何将其与一些stringr和tidyr函数一起使用，现在是时候深入了解更多细节了。首 先，我们将从转义（escaping）开始，它允许你匹配通常会被特殊处理的元字符。接 下来，你将学习锚点（anchors），它允许你匹配字符串的开始或结束。然 后，你将更深入地了解字符类（character classes）和它们的快捷方式，它们允许你匹配集合中的任何字符。接 着，你将学习量词（quantifiers）的最后一些细节，它们控制模式可以匹配多少次。之 后，我们必须覆盖重要（但复杂）的主题，即运算符优先级（operator precedence）和括号。最 后，我们将以模式分组（grouping）组件的一些细节结束。\n我们在这里使用的术语是每个组件的技术名称。它 们并不总是最能体现其目的，但如果你以后想在网上搜索更多细节，知道正确的术语会很有帮助。\n\n15.4.1 转义\n为了匹配字面上的.，你需要一个转义符，它告诉正则表达式要从字面上匹配元字符6。 和字符串一样，正则表达式使用反斜杠进行转义。 因此，要匹配.，正则表达式为\\.。不幸的是这会造成一个问题。 我们使用字符串来表示正则表达式，而\\也在字符串中用作转义符。 因此，要创建正则表达式\\.，我们需要字符串\"\\\\.\"，如下例所示。\n\n# To create the regular expression \\., we need to use \\\\.\ndot &lt;- \"\\\\.\"\n\n# But the expression itself only contains one \\\nstr_view(dot)\n#&gt; [1] │ \\.\n\n# And this tells R to look for an explicit .\nstr_view(c(\"abc\", \"a.c\", \"bef\"), \"a\\\\.c\")\n#&gt; [2] │ &lt;a.c&gt;\n\n在这本书中，我们通常会在没有引号的情况下编写正则表达式，比如\\.。如 果我们需要强调实际输入的内容，我们会用引号将其括起来并添加额外的转义字符，比如\"\\\\.\"。\n如果\\在正则表达式中被用作转义字符，那么如何匹配一个实际的\\呢？你 需要对它进行转义，创建正则表达式\\\\。为 了创建这个正则表达式，你需要使用字符串，而字符串本身也需要对\\进行转义。这 意味着要匹配一个实际的\\，你需要写\"\\\\\\\\\"——你需要四个反斜杠来匹配一个！\n\nx &lt;- \"a\\\\b\"\nstr_view(x)\n#&gt; [1] │ a\\b\nstr_view(x, \"\\\\\\\\\")\n#&gt; [1] │ a&lt;\\&gt;b\n\n或者，你可能发现使用 小节 14.2.2 中学到的原始字符串会更加简单。这 样可以让你避免一层的转义：\n\nstr_view(x, r\"{\\\\}\")\n#&gt; [1] │ a&lt;\\&gt;b\n\n如果你试图匹配一个字面上的.、$、|、*、+、?、{、}、(或)，除了使用反斜杠转义之外还有一个替代方案：你可以使用字符类：.、$、|、… 都匹配其字面值。\n\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \"a[.]c\")\n#&gt; [2] │ &lt;a.c&gt;\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \".[*]c\")\n#&gt; [3] │ &lt;a*c&gt;\n\n\n\n15.4.2 锚点\n默认情况下，正则表达式会匹配字符串的任何部分。如 果你想在开头或结尾处进行匹配，你需要使用^来锚定正则表达式的开始，或者使用$来锚定正则表达式的结束：\n\nstr_view(fruit, \"^a\")\n#&gt; [1] │ &lt;a&gt;pple\n#&gt; [2] │ &lt;a&gt;pricot\n#&gt; [3] │ &lt;a&gt;vocado\nstr_view(fruit, \"a$\")\n#&gt;  [4] │ banan&lt;a&gt;\n#&gt; [15] │ cherimoy&lt;a&gt;\n#&gt; [30] │ feijo&lt;a&gt;\n#&gt; [36] │ guav&lt;a&gt;\n#&gt; [56] │ papay&lt;a&gt;\n#&gt; [74] │ satsum&lt;a&gt;\n\n可能会让人误以为$应该匹配字符串的开始，因为我们常常这样写金额，但这并不是正则表达式所期望的。\n要强制正则表达式仅匹配整个字符串，需要用^和$同时进行锚定：\n\nstr_view(fruit, \"apple\")\n#&gt;  [1] │ &lt;apple&gt;\n#&gt; [62] │ pine&lt;apple&gt;\nstr_view(fruit, \"^apple$\")\n#&gt; [1] │ &lt;apple&gt;\n\n你也可以使用\\b来匹配单词之间的边界（即单词的开始或结束）。这 在使用 RStudio 的查找和替换工具时特别有用。例 如，如果你想查找所有sum()的用法，你可以搜索\\bsum\\b来避免匹配到summarize、summary、rowsum等单词：\n\nx &lt;- c(\"summary(x)\", \"summarize(df)\", \"rowsum(x)\", \"sum(x)\")\nstr_view(x, \"sum\")\n#&gt; [1] │ &lt;sum&gt;mary(x)\n#&gt; [2] │ &lt;sum&gt;marize(df)\n#&gt; [3] │ row&lt;sum&gt;(x)\n#&gt; [4] │ &lt;sum&gt;(x)\nstr_view(x, \"\\\\bsum\\\\b\")\n#&gt; [4] │ &lt;sum&gt;(x)\n\n当单独使用时，锚点会产生一个零宽度的匹配：\n\nstr_view(\"abc\", c(\"$\", \"^\", \"\\\\b\"))\n#&gt; [1] │ abc&lt;&gt;\n#&gt; [2] │ &lt;&gt;abc\n#&gt; [3] │ &lt;&gt;abc&lt;&gt;\n\n这有助于你理解当替换一个单独的锚点时会发生什么：\n\nstr_replace_all(\"abc\", c(\"$\", \"^\", \"\\\\b\"), \"--\")\n#&gt; [1] \"abc--\"   \"--abc\"   \"--abc--\"\n\n\n\n15.4.3 字符类\n字符类（或字符集）允许你匹配集合中的任何字符。如 上所述，你可以使用[]来构建自己的集合，其中[abc]匹配 “a”、“b” 或 “c”，而[^abc]匹配除了 “a”、“b” 或 “c” 之外的任何字符。除 了^之外，[]内还有两个字符具有特殊含义：\n\n- 定义了一个范围，例如，[a-z] 匹配任何小写字母，而 [0-9] 匹配任何数字。\n\\ 用于转义特殊字符，因此[\\^\\-\\]]匹配字符^、-或]。\n\n这里有几个例子\n\nx &lt;- \"abcd ABCD 12345 -!@#%.\"\nstr_view(x, \"[abc]+\")\n#&gt; [1] │ &lt;abc&gt;d ABCD 12345 -!@#%.\nstr_view(x, \"[a-z]+\")\n#&gt; [1] │ &lt;abcd&gt; ABCD 12345 -!@#%.\nstr_view(x, \"[^a-z0-9]+\")\n#&gt; [1] │ abcd&lt; ABCD &gt;12345&lt; -!@#%.&gt;\n\n# You need an escape to match characters that are otherwise\n# special inside of []\nstr_view(\"a-b-c\", \"[a-c]\")\n#&gt; [1] │ &lt;a&gt;-&lt;b&gt;-&lt;c&gt;\nstr_view(\"a-b-c\", \"[a\\\\-c]\")\n#&gt; [1] │ &lt;a&gt;&lt;-&gt;b&lt;-&gt;&lt;c&gt;\n\n一些字符类由于使用得非常频繁，因此它们有自己的快捷方式。你 已经见过.，它匹配除了换行符之外的任何字符。这 里还有另外三对特别有用的快捷方式7：\n\n\\d 匹配任何数字；\n\\D 匹配任何不是数字的字符；\n\\s 匹配任何空白字符（如，空格、制表符、换行符）；\n\\S 匹配任何不是空白字符的字符；\n\\w 匹配任何“单词”字符，即字母和数字；\n\\W 匹配任何“非单词”字符。\n\n以下代码通过选择字母、数字和标点符号字符来演示这六个快捷方式。\n\nx &lt;- \"abcd ABCD 12345 -!@#%.\"\nstr_view(x, \"\\\\d+\")\n#&gt; [1] │ abcd ABCD &lt;12345&gt; -!@#%.\nstr_view(x, \"\\\\D+\")\n#&gt; [1] │ &lt;abcd ABCD &gt;12345&lt; -!@#%.&gt;\nstr_view(x, \"\\\\s+\")\n#&gt; [1] │ abcd&lt; &gt;ABCD&lt; &gt;12345&lt; &gt;-!@#%.\nstr_view(x, \"\\\\S+\")\n#&gt; [1] │ &lt;abcd&gt; &lt;ABCD&gt; &lt;12345&gt; &lt;-!@#%.&gt;\nstr_view(x, \"\\\\w+\")\n#&gt; [1] │ &lt;abcd&gt; &lt;ABCD&gt; &lt;12345&gt; -!@#%.\nstr_view(x, \"\\\\W+\")\n#&gt; [1] │ abcd&lt; &gt;ABCD&lt; &gt;12345&lt; -!@#%.&gt;\n\n\n\n15.4.4 量词\n量词（Quantifiers）控制模式匹配的次数。在 小节 15.2 中学习了 ?（匹配0次或1次）、+（匹配1次或多次）和*（匹配0次或多次）。例 如，colou?r 将匹配美式或英式拼写，\\d+ 将匹配一个或多个数字，而 \\s? 将可选地匹配一个空白字符。你 还可以使用 {} 来精确指定匹配次数：\n\n{n} 恰好匹配 n 次；\n{n,} 匹配至少 n 次；\n{n,m} 匹配 n 到 m 次。\n\n\n\n15.4.5 运算符优先级和括号\nab+ 匹配什么？是 匹配“a”后面跟着一个或多个“b”，还是匹配“ab”重复任意次数？^ a|b$ 匹配什么？是 匹配完整的字符串“a”或完整的字符串“b”，还是匹配以“a”开头的字符串或以“b”结尾的字符串？\n这些问题的答案由运算符优先级确定，类似于你在学校可能学过的 PEMDAS 或 BEDMAS 规则。你 知道 a + b * c 相当于 a + (b * c) 而不是 (a + b) * c，因为 * 的优先级高于 +，先计算 * 再计算 +。\n类似地，正则表达式也有自己的优先级规则：量词的优先级高，而替换的优先级低，这意味着 ab+ 相当于 a(b+)，而 ^a|b$相当于(^a)|(b$)。就 像代数一样，你可以使用括号来覆盖通常的顺序。但 与代数不同，你不太可能记住正则表达式的优先级规则，所以请随意使用括号。\n\n\n15.4.6 分组和捕获\n除了覆盖运算符优先级外，括号还有另一个重要作用：创建捕获组（capturing groups），捕获组允许你使用匹配的子组件。\n使用捕获组的第一种方法是在匹配内部使用反向引用（back reference）引用它：\\1 引用第一个括号中的匹配项，\\2 引用第二个括号中的匹配项，依此类推。例 如，以下模式查找具有重复字母对的所有水果：\n\nstr_view(fruit, \"(..)\\\\1\")\n#&gt;  [4] │ b&lt;anan&gt;a\n#&gt; [20] │ &lt;coco&gt;nut\n#&gt; [22] │ &lt;cucu&gt;mber\n#&gt; [41] │ &lt;juju&gt;be\n#&gt; [56] │ &lt;papa&gt;ya\n#&gt; [73] │ s&lt;alal&gt; berry\n\n这个正则表达式会找到所有以相同字母对开头和结尾的单词：\n\nstr_view(words, \"^(..).*\\\\1$\")\n#&gt; [152] │ &lt;church&gt;\n#&gt; [217] │ &lt;decide&gt;\n#&gt; [617] │ &lt;photograph&gt;\n#&gt; [699] │ &lt;require&gt;\n#&gt; [739] │ &lt;sense&gt;\n\n你也可以在str_replace()中使用反向引用。例 如，以下代码会交换sentences中第二个和第三个单词的顺序：\n\nsentences |&gt; \n  str_replace(\"(\\\\w+) (\\\\w+) (\\\\w+)\", \"\\\\1 \\\\3 \\\\2\") |&gt; \n  str_view()\n#&gt; [1] │ The canoe birch slid on the smooth planks.\n#&gt; [2] │ Glue sheet the to the dark blue background.\n#&gt; [3] │ It's to easy tell the depth of a well.\n#&gt; [4] │ These a days chicken leg is a rare dish.\n#&gt; [5] │ Rice often is served in round bowls.\n#&gt; [6] │ The of juice lemons makes fine punch.\n#&gt; ... and 714 more\n\n如果想提取每个组的匹配项，可以使用str_match()。但 str_match()返回一个矩阵，因此使用起来不是特别方便8：\n\nsentences |&gt; \n  str_match(\"the (\\\\w+) (\\\\w+)\") |&gt; \n  head()\n#&gt;      [,1]                [,2]     [,3]    \n#&gt; [1,] \"the smooth planks\" \"smooth\" \"planks\"\n#&gt; [2,] \"the sheet to\"      \"sheet\"  \"to\"    \n#&gt; [3,] \"the depth of\"      \"depth\"  \"of\"    \n#&gt; [4,] NA                  NA       NA      \n#&gt; [5,] NA                  NA       NA      \n#&gt; [6,] NA                  NA       NA\n\n你可以将其转换为 tibble 并给列命名：\n\nsentences |&gt; \n  str_match(\"the (\\\\w+) (\\\\w+)\") |&gt; \n  as_tibble(.name_repair = \"minimal\") |&gt; \n  set_names(\"match\", \"word1\", \"word2\")\n#&gt; # A tibble: 720 × 3\n#&gt;   match             word1  word2 \n#&gt;   &lt;chr&gt;             &lt;chr&gt;  &lt;chr&gt; \n#&gt; 1 the smooth planks smooth planks\n#&gt; 2 the sheet to      sheet  to    \n#&gt; 3 the depth of      depth  of    \n#&gt; 4 &lt;NA&gt;              &lt;NA&gt;   &lt;NA&gt;  \n#&gt; 5 &lt;NA&gt;              &lt;NA&gt;   &lt;NA&gt;  \n#&gt; 6 &lt;NA&gt;              &lt;NA&gt;   &lt;NA&gt;  \n#&gt; # ℹ 714 more rows\n\n但是，你基本上已经重新创建了自己的separate_wider_regex()版本。实 际上，在幕后，separate_wider_regex()将你的模式向量转换为一个使用分组来捕获命名组件的单一正则表达式。\n偶尔，你会想要使用括号而不创建匹配组。你 可以使用(?:)来创建一个非捕获组。\n\nx &lt;- c(\"a gray cat\", \"a grey dog\")\nstr_match(x, \"gr(e|a)y\")\n#&gt;      [,1]   [,2]\n#&gt; [1,] \"gray\" \"a\" \n#&gt; [2,] \"grey\" \"e\"\nstr_match(x, \"gr(?:e|a)y\")\n#&gt;      [,1]  \n#&gt; [1,] \"gray\"\n#&gt; [2,] \"grey\"\n\n\n\n15.4.7 练习\n\n如何匹配字面字符串\"'\\？那么 \"$^$\" 呢？\n为什么 \"\\\", \"\\\\\", \"\\\\\\\"这些模式都不匹配反斜杠\\？\n给定stringr::words中的常用词汇库，创建正则表达式以查找所有满足以下条件的单词：\n\n以 “y” 开头；\n不以 “y” 开头；\n以 “x” 结尾；\n恰好三个字母长（不要通过使用str_length()来作弊！)\n有七个或更多字母；\n包含元音-辅音对；\n在一行中至少包含两个元音-辅音对；\n仅由重复的元音-辅音对组成。\n\n创建11个正则表达式，每个表达式都匹配以下单词的英式或美式拼写：airplane/aeroplane, aluminum/aluminium, analog/analogue, ass/arse, center/centre, defense/defence, donut/doughnut, gray/grey, modeling/modelling, skeptic/sceptic, summarize/summarise。尝 试编写尽可能短的正则表达式！\n交换words中的首尾字母，哪些字符串仍然是words？\n用文字描述这些正则表达式匹配什么内容:（仔细阅读以确定每个条目是正则表达式还是定义正则表达式的字符串）\n\n^.*$\n\"\\\\{.+\\\\}\"\n\\d{4}-\\d{2}-\\d{2}\n\"\\\\\\\\{4}\"\n\\..\\..\\..\n(.)\\1\\1\n\"(..)\\\\1\"\n\n完成位于https://regexcrossword.com/challenges/beginner的正则表达式初学者填字游戏。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "regexps.html#模式控制",
    "href": "regexps.html#模式控制",
    "title": "15  正则表达式",
    "section": "15.5 模式控制",
    "text": "15.5 模式控制\n通过使用模式对象而不是仅使用字符串，可以对匹配的细节进行额外的控制。这 允许你控制所谓的正则表达式标志，并匹配各种类型的固定字符串，如下所述。\n\n15.5.1 Regex 标志\n有一些设置可以用来控制正则表达式的细节，这些设置在其他编程语言中通常被称为标志（flags）。在 stringr 中，你可以通过将模式封装在函数regex()的调用中来使用这些设置。最 有用的标志可能是 ignore_case = TRUE，因为它允许字符与其大写或小写形式匹配：\n\nbananas &lt;- c(\"banana\", \"Banana\", \"BANANA\")\nstr_view(bananas, \"banana\")\n#&gt; [1] │ &lt;banana&gt;\nstr_view(bananas, regex(\"banana\", ignore_case = TRUE))\n#&gt; [1] │ &lt;banana&gt;\n#&gt; [2] │ &lt;Banana&gt;\n#&gt; [3] │ &lt;BANANA&gt;\n\n如果你经常处理多行字符串（即包含\\n的字符串），dotall和multiline也可能是有用的：\n\ndotall = TRUE 允许.匹配包括\\n在内的所有字符：\n\nx &lt;- \"Line 1\\nLine 2\\nLine 3\"\nstr_view(x, \".Line\")\nstr_view(x, regex(\".Line\", dotall = TRUE))\n#&gt; [1] │ Line 1&lt;\n#&gt;     │ Line&gt; 2&lt;\n#&gt;     │ Line&gt; 3\n\nmultiline = TRUE 使得 ^ 和 $ 分别匹配每行的开始和结束，而不是整个字符串的开始和结束：\n\nx &lt;- \"Line 1\\nLine 2\\nLine 3\"\nstr_view(x, \"^Line\")\n#&gt; [1] │ &lt;Line&gt; 1\n#&gt;     │ Line 2\n#&gt;     │ Line 3\nstr_view(x, regex(\"^Line\", multiline = TRUE))\n#&gt; [1] │ &lt;Line&gt; 1\n#&gt;     │ &lt;Line&gt; 2\n#&gt;     │ &lt;Line&gt; 3\n\n\n最后，如果你正在编写一个复杂的正则表达式，并担心将来可能不理解它，你可以尝试使用comments = TRUE。这 会修改模式语言以忽略空格和换行符，以及#之后的所有内容。这 允许你使用注释和空格来使复杂的正则表达式更易于理解，如下例所示：\n\nphone &lt;- regex(\n  r\"(\n    \\(?     # optional opening parens\n    (\\d{3}) # area code\n    [)\\-]?  # optional closing parens or dash\n    \\ ?     # optional space\n    (\\d{3}) # another three numbers\n    [\\ -]?  # optional space or dash\n    (\\d{4}) # four more numbers\n  )\", \n  comments = TRUE\n)\n\nstr_extract(c(\"514-791-8141\", \"(123) 456 7890\", \"123456\"), phone)\n#&gt; [1] \"514-791-8141\"   \"(123) 456 7890\" NA\n\n如果你在使用注释并且想要匹配空格、换行符或 #，你需要使用\\对其进行转义。\n\n\n15.5.2 固定匹配（Fixed matches）\n你可以通过使用fixed()来选择不遵循正则表达式规则：\n\nstr_view(c(\"\", \"a\", \".\"), fixed(\".\"))\n#&gt; [3] │ &lt;.&gt;\n\nfixed() 还允许你忽略大小写：\n\nstr_view(\"x X\", \"X\")\n#&gt; [1] │ x &lt;X&gt;\nstr_view(\"x X\", fixed(\"X\", ignore_case = TRUE))\n#&gt; [1] │ &lt;x&gt; &lt;X&gt;\n\n如果你在处理非英文文本，你可能会使用coll()而不是fixed()，因为coll()实现了所指定区域使用的全部大小写规则。关 于区域的更多细节，请参见 小节 14.6 。\n\nstr_view(\"i İ ı I\", fixed(\"İ\", ignore_case = TRUE))\n#&gt; [1] │ i &lt;İ&gt; ı I\nstr_view(\"i İ ı I\", coll(\"İ\", ignore_case = TRUE, locale = \"tr\"))\n#&gt; [1] │ &lt;i&gt; &lt;İ&gt; ı I",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "regexps.html#实践",
    "href": "regexps.html#实践",
    "title": "15  正则表达式",
    "section": "15.6 实践",
    "text": "15.6 实践\n为了将这些想法付诸实践，接下来我们将解决一些半真实的问题。我 们将讨论三种一般方法：\n\n通过创建简单的正控制和负控制来检查工作\n将正则表达式与布尔代数结合使用\n使用字符串操作创建复杂模式\n\n\n15.6.1 检查你的工作\n首先，让我们找出所有以“The”开头的句子。仅 使用^锚点是不够的：\n\nstr_view(sentences, \"^The\")\n#&gt;  [1] │ &lt;The&gt; birch canoe slid on the smooth planks.\n#&gt;  [4] │ &lt;The&gt;se days a chicken leg is a rare dish.\n#&gt;  [6] │ &lt;The&gt; juice of lemons makes fine punch.\n#&gt;  [7] │ &lt;The&gt; box was thrown beside the parked truck.\n#&gt;  [8] │ &lt;The&gt; hogs were fed chopped corn and garbage.\n#&gt; [11] │ &lt;The&gt; boy was there when the sun rose.\n#&gt; ... and 271 more\n\n因为这个模式也会匹配以 They 或 These 等单词开头的句子。为 了需要确保 “e” 是单词的最后一个字母，我们可以通过添加一个单词边界来实现这一点：\n\nstr_view(sentences, \"^The\\\\b\")\n#&gt;  [1] │ &lt;The&gt; birch canoe slid on the smooth planks.\n#&gt;  [6] │ &lt;The&gt; juice of lemons makes fine punch.\n#&gt;  [7] │ &lt;The&gt; box was thrown beside the parked truck.\n#&gt;  [8] │ &lt;The&gt; hogs were fed chopped corn and garbage.\n#&gt; [11] │ &lt;The&gt; boy was there when the sun rose.\n#&gt; [13] │ &lt;The&gt; source of the huge river is the clear spring.\n#&gt; ... and 250 more\n\n如何查找所有以代词开头的句子呢？\n\nstr_view(sentences, \"^She|He|It|They\\\\b\")\n#&gt;  [3] │ &lt;It&gt;'s easy to tell the depth of a well.\n#&gt; [15] │ &lt;He&gt;lp the woman get back to her feet.\n#&gt; [27] │ &lt;He&gt;r purse was full of useless trash.\n#&gt; [29] │ &lt;It&gt; snowed, rained, and hailed the same morning.\n#&gt; [63] │ &lt;He&gt; ran half way to the hardware store.\n#&gt; [90] │ &lt;He&gt; lay prone and hardly moved a limb.\n#&gt; ... and 57 more\n\n快速检查结果显示我们得到了一些错误的匹配。这 是因为我们忘记了使用括号：\n\nstr_view(sentences, \"^(She|He|It|They)\\\\b\")\n#&gt;   [3] │ &lt;It&gt;'s easy to tell the depth of a well.\n#&gt;  [29] │ &lt;It&gt; snowed, rained, and hailed the same morning.\n#&gt;  [63] │ &lt;He&gt; ran half way to the hardware store.\n#&gt;  [90] │ &lt;He&gt; lay prone and hardly moved a limb.\n#&gt; [116] │ &lt;He&gt; ordered peach pie with ice cream.\n#&gt; [127] │ &lt;It&gt; caught its hind paw in a rusty trap.\n#&gt; ... and 51 more\n\n你可能会想，如果这种错误没有出现在前几个匹配项中，我如何才能发现它。一 个好的技巧是创建一些正匹配和负匹配项，并用它们来测试你的模式是否按预期工作：\n\npos &lt;- c(\"He is a boy\", \"She had a good time\")\nneg &lt;- c(\"Shells come from the sea\", \"Hadley said 'It's a great day'\")\n\npattern &lt;- \"^(She|He|It|They)\\\\b\"\nstr_detect(pos, pattern)\n#&gt; [1] TRUE TRUE\nstr_detect(neg, pattern)\n#&gt; [1] FALSE FALSE\n\n通常来说，举出好的正面例子比举出负面例子要容易得多，因为你需要一段时间才能熟练地使用正则表达式来预测你的弱点在哪里。尽 管如此，它们仍然是有用的:当你处理问题时，你可以慢慢积累错误的集合，确保自己永远不会犯同样的错误两次。\n\n\n15.6.2 布尔运算\n想象一下，如果我们想找到只包含辅音的单词，一种方法是创建一个字符类，包含除了元音（[^aeiou]）之外的所有字母，然后允许这个字符类匹配任意数量的字母（[^aeiou]+），然后通过将其锚定到字符串的开始和结束来强制它匹配整个字符串（^[^aeiou]+$）：\n\nstr_view(words, \"^[^aeiou]+$\")\n#&gt; [123] │ &lt;by&gt;\n#&gt; [249] │ &lt;dry&gt;\n#&gt; [328] │ &lt;fly&gt;\n#&gt; [538] │ &lt;mrs&gt;\n#&gt; [895] │ &lt;try&gt;\n#&gt; [952] │ &lt;why&gt;\n\n但你反向思考就会使这个问题变得更简单。我 们不是寻找只包含辅音的单词，而是寻找不包含任何元音的单词：\n\nstr_view(words[!str_detect(words, \"[aeiou]\")])\n#&gt; [1] │ by\n#&gt; [2] │ dry\n#&gt; [3] │ fly\n#&gt; [4] │ mrs\n#&gt; [5] │ try\n#&gt; [6] │ why\n\n当你处理逻辑组合时，特别是涉及“和”或“非”的逻辑组合时，这是一种有用的方法。例 如，假设你想找到所有包含“a”和“b”的单词。正 则表达式中没有内置的“和”运算符，所以我们必须通过查找所有包含“a”后跟“b”或“b”后跟“a”的单词来解决这个问题：\n\nstr_view(words, \"a.*b|b.*a\")\n#&gt;  [2] │ &lt;ab&gt;le\n#&gt;  [3] │ &lt;ab&gt;out\n#&gt;  [4] │ &lt;ab&gt;solute\n#&gt; [62] │ &lt;availab&gt;le\n#&gt; [66] │ &lt;ba&gt;by\n#&gt; [67] │ &lt;ba&gt;ck\n#&gt; ... and 24 more\n\n结合两次调用str_detect()的结果会更简单：\n\nwords[str_detect(words, \"a\") & str_detect(words, \"b\")]\n#&gt;  [1] \"able\"      \"about\"     \"absolute\"  \"available\" \"baby\"      \"back\"     \n#&gt;  [7] \"bad\"       \"bag\"       \"balance\"   \"ball\"      \"bank\"      \"bar\"      \n#&gt; [13] \"base\"      \"basis\"     \"bear\"      \"beat\"      \"beauty\"    \"because\"  \n#&gt; [19] \"black\"     \"board\"     \"boat\"      \"break\"     \"brilliant\" \"britain\"  \n#&gt; [25] \"debate\"    \"husband\"   \"labour\"    \"maybe\"     \"probable\"  \"table\"\n\n如果我们想查看是否有单词包含所有元音字母怎么办？如 果我们使用模式来做，我们需要生成 5!（ 120）种不同的模式：\n\nwords[str_detect(words, \"a.*e.*i.*o.*u\")]\n# ...\nwords[str_detect(words, \"u.*o.*i.*e.*a\")]\n\n结合五次对str_detect()的调用会简单得多：\n\nwords[\n  str_detect(words, \"a\") &\n  str_detect(words, \"e\") &\n  str_detect(words, \"i\") &\n  str_detect(words, \"o\") &\n  str_detect(words, \"u\")\n]\n#&gt; character(0)\n\n一般来说，如果你尝试创建一个单一的正则表达式来解决你的问题却陷入了困境，不妨退一步，想想是否可以将问题分解成更小的部分，逐一解决每个挑战，然后再进行下一个。\n\n\n15.6.3 用代码创建模式\n如果我们想找到所有提到颜色的sentences怎么办？基 本思路很简单：我们只需要将分隔符与单词边界结合起来。\n\nstr_view(sentences, \"\\\\b(red|green|blue)\\\\b\")\n#&gt;   [2] │ Glue the sheet to the dark &lt;blue&gt; background.\n#&gt;  [26] │ Two &lt;blue&gt; fish swam in the tank.\n#&gt;  [92] │ A wisp of cloud hung in the &lt;blue&gt; air.\n#&gt; [148] │ The spot on the blotter was made by &lt;green&gt; ink.\n#&gt; [160] │ The sofa cushion is &lt;red&gt; and of light weight.\n#&gt; [174] │ The sky that morning was clear and bright &lt;blue&gt;.\n#&gt; ... and 20 more\n\n但是随着颜色的数量增加，手动构建这个模式会变得非常繁琐。如 果我们能把颜色存储在一个向量里，那不是很好吗？\n\nrgb &lt;- c(\"red\", \"green\", \"blue\")\n\n我们可以！只 需要使用str_c()和str_flatten()从向量中创建模式：\n\nstr_c(\"\\\\b(\", str_flatten(rgb, \"|\"), \")\\\\b\")\n#&gt; [1] \"\\\\b(red|green|blue)\\\\b\"\n\n如果我们有一个好的颜色列表，可以使这个模式更加全面。我 们可以从R用于绘图的内置颜色列表开始:\n\nstr_view(colors())\n#&gt; [1] │ white\n#&gt; [2] │ aliceblue\n#&gt; [3] │ antiquewhite\n#&gt; [4] │ antiquewhite1\n#&gt; [5] │ antiquewhite2\n#&gt; [6] │ antiquewhite3\n#&gt; ... and 651 more\n\n但是让我们首先排除编号的颜色变体：\n\ncols &lt;- colors()\ncols &lt;- cols[!str_detect(cols, \"\\\\d\")]\nstr_view(cols)\n#&gt; [1] │ white\n#&gt; [2] │ aliceblue\n#&gt; [3] │ antiquewhite\n#&gt; [4] │ aquamarine\n#&gt; [5] │ azure\n#&gt; [6] │ beige\n#&gt; ... and 137 more\n\n然后我们可以将这个列表转换成一个巨大的模式。我 们不会在这里显示这个模式，因为它非常庞大，但你可以看到它的工作效果：\n\npattern &lt;- str_c(\"\\\\b(\", str_flatten(cols, \"|\"), \")\\\\b\")\nstr_view(sentences, pattern)\n#&gt;   [2] │ Glue the sheet to the dark &lt;blue&gt; background.\n#&gt;  [12] │ A rod is used to catch &lt;pink&gt; &lt;salmon&gt;.\n#&gt;  [26] │ Two &lt;blue&gt; fish swam in the tank.\n#&gt;  [66] │ Cars and busses stalled in &lt;snow&gt; drifts.\n#&gt;  [92] │ A wisp of cloud hung in the &lt;blue&gt; air.\n#&gt; [112] │ Leaves turn &lt;brown&gt; and &lt;yellow&gt; in the fall.\n#&gt; ... and 57 more\n\n在这个例子中，cols只包含数字和字母，所以你不需要担心元字符。但 是一般来说，每当你从现有字符串创建模式时，最好通过str_escape()对它们进行处理，以确保它们按字面意义进行匹配。\n\n\n15.6.4 练习\n\n对于以下每一个挑战，尝试使用单个正则表达式和多个str_detect()调用的组合来解决它。F or each of the following challenges, try solving it by using both a single regular expression, and a combination of multiple str_detect() calls.\n\n找出所有以x开头或以x结尾的words；\n找出所有以元音字母开头并以辅音字母结尾的words；\n是否存在包含至少每一种元音字母的words ？\n\n构建模式来找到支持或反对“i在e前面，除非在c后面”这一规则的证据。\ncolors()包含了一些像“lightgray”和“darkblue”这样的修饰符。如 何自动识别这些修饰符？（ 考虑如何检测和移除被修饰的颜色）。\n创建一个正则表达式来查找任何基础R数据集。你 可以通过data()的特殊用法来获取这些数据集的列表：data(package = \"datasets\")$results[, \"Item\"]。请 注意，一些旧的数据集是单独的向量，这些向量在括号中包含“数据框”的名称，因此你需要去掉这些括号。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "regexps.html#其他地方的正则表达式",
    "href": "regexps.html#其他地方的正则表达式",
    "title": "15  正则表达式",
    "section": "15.7 其他地方的正则表达式",
    "text": "15.7 其他地方的正则表达式\n就像在stringr和tidyr函数中一样，R中还有许多其他地方可以使用正则表达式。下 面将描述在tidyverse生态系统和基础R中其他一些有用的函数。\n\n15.7.1 tidyverse\n还有三个特别有用的地方可能需要使用正则表达式：\n\nmatches(pattern) 函数会选择所有名称与给定模式匹配的变量。它 是一个“tidyselect”函数，你可以在tidyverse生态系统中任何选择变量的函数（例如select(),rename_with()和across()）中使用它。\npivot_longer()'s 函数的names_pattern参数接受一个正则表达式向量，与separate_wider_regex()类似，在从具有复杂结构的变量名称中提取数据时非常有用。\nseparate_longer_delim()和separate_wider_delim()函数中的delim参数通常用于匹配一个固定的字符串，但你可以使用regex()来使其匹配一个模式。这 在你想匹配一个逗号（后面可能跟着一个空格）时非常有用，例如regex(\", ?\")。\n\n\n\n15.7.2 基础R\napropos(pattern) 会搜索全局环境中所有与给定模式匹配的对象。如 果你不太记得某个函数的名称，这是很有用的。\n\napropos(\"replace\")\n#&gt; [1] \"%+replace%\"       \"replace\"          \"replace_na\"      \n#&gt; [4] \"setReplaceMethod\" \"str_replace\"      \"str_replace_all\" \n#&gt; [7] \"str_replace_na\"   \"theme_replace\"\n\nlist.files(path, pattern)会列出path中所有匹配正则表达式pattern的文件。例 如，你可以用它来查找当前目录下的所有 R Markdown 文件，命令如下：\n\nhead(list.files(pattern = \"\\\\.Rmd$\"))\n#&gt; character(0)\n\n值得注意的是，基础R使用的模式语言与stringr使用的略有不同。这 是因为stringr是建立在stringi包之上的，而stringi包又是建立在ICU引擎之上的，而基础R函数则使用TRE引擎或PCRE引擎，这取决于你是否设置了perl = TRUE。幸 运的是，正则表达式的基础知识已经非常完善，因此你在使用本书中将要学习的模式时，很少会遇到变化。只 有当你开始依赖高级特性，如复杂的Unicode字符范围或使用(?…)语法的特殊特性时才需要意识到这种差异。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "regexps.html#小结",
    "href": "regexps.html#小结",
    "title": "15  正则表达式",
    "section": "15.8 小结",
    "text": "15.8 小结\n由于每个标点符号都可能被赋予多重含义，正则表达式是现存最紧凑的语言之一。它 们一开始确实会让人感到困惑，但当你训练自己的眼睛去阅读它们，大脑去理解它们时，你就掌握了一项强大的技能，你可以在R和其他许多地方使用这项技能。\n在本章中，通过学习最有用的stringr函数和正则表达式语言的最重要组件，开始了成为正则表达式大师的旅程。而 且还有很多资源可以进一步学习。\n一个不错的出发点是vignette(\"regular-expressions\", package = \"stringr\")，它记录了stringr支持的全部语法；另外可以从https://www.regular-expressions.info/获取有用的参考信息。这 个网站不是针对R的，但可以用它来学习正则表达式的最先进特性和工作原理。\n另外需要知道的是，stringr是由Marek Gagolewski在stringi的基础上实现的，如果在stringr中找不到你需要的函数，不要担心查阅stringi。你 会发现stringi非常容易上手，因为它遵循了stringr的许多相同约定。\n在下一章中，我们将讨论与字符串密切相关的数据结构：因子（factors）。因 子用于在R中表示分类数据，即具有固定和已知可能值集的数据，这些可能值由字符串向量标识。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "regexps.html#footnotes",
    "href": "regexps.html#footnotes",
    "title": "15  正则表达式",
    "section": "",
    "text": "你可以用硬音 g（reg-x）或软音 g（rej-x）来发音。↩︎\n你将在 小节 15.4.1 中学习如何转义这些特殊含义。↩︎\n除了\\n以外的任何字符。↩︎\n这给出了包含”x”的名字的比例；如果你想要知道名字中包含”x”的婴儿的比例，你需要计算一个加权平均值。↩︎\n我们希望能向你保证，在现实生活中你永远不会看到这种奇怪的数据格式；但不幸的是，在你的职业生涯中，你可能会看到比这更奇怪的数据格式！↩︎\n元字符的完备集为 .^$\\|*+?{}[]()↩︎\n记住，要创建一个包含\\d或\\s的正则表达式，你需要对字符串中的\\进行转义，所以你需要输入\\\\d或\\\\s。↩︎\n主要是因为我们在本书中从未讨论过矩阵!↩︎",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "factors.html",
    "href": "factors.html",
    "title": "16  因子",
    "section": "",
    "text": "16.1 引言\n因子用于分类变量，这些变量具有一组固定且已知的可能取值。当 你希望以非字母顺序显示字符向量时，它们也很有用。\n我们将从解释为什么数据分析需要因子 (factor)1 以及如何使用factor()函数创建它们开始。 接着，我们将向您介绍gss_cat数据集，它包含一系列可供实验的分类变量。 之后，你将使用此数据集练习修改因子的顺序和值，最后我们将讨论有序因子。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "factors.html#引言",
    "href": "factors.html#引言",
    "title": "16  因子",
    "section": "",
    "text": "16.1.1 必要条件\n基础 R 提供了一些用于创建和操作因子的基本工具。我 们将使用 forcats 包来补充这些工具，forcats 是 tidyverse 的一部分，它提供了处理分类变量 (它是 factors 的字母重新排列!) 的工具，并提供了多种与因子一起工作的辅助函数。\n\nlibrary(tidyverse)",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "factors.html#因子基础",
    "href": "factors.html#因子基础",
    "title": "16  因子",
    "section": "16.2 因子基础",
    "text": "16.2 因子基础\n假设你有一个记录月份的变量:\n\nx1 &lt;- c(\"Dec\", \"Apr\", \"Jan\", \"Mar\")\n\n使用字符串记录这个变量有两个问题:\n\n只有十二个可能的月份，而且没有什么能阻止你出现打字错误：\n\nx2 &lt;- c(\"Dec\", \"Apr\", \"Jam\", \"Mar\")\n\n它并没有以有用的方式进行排序：\n\nsort(x1)\n#&gt; [1] \"Apr\" \"Dec\" \"Jan\" \"Mar\"\n\n\n你可以使用因子（factor）来解决这两个问题。要 创建一个因子，首先需要创建一个有效水平 (levels) 的列表：\n\nmonth_levels &lt;- c(\n  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \n  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n)\n\n现在你可以创建一个因子:\n\ny1 &lt;- factor(x1, levels = month_levels)\ny1\n#&gt; [1] Dec Apr Jan Mar\n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nsort(y1)\n#&gt; [1] Jan Mar Apr Dec\n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\n任何不在水平列表中的值都将被静默地转换为NA（缺失值）：\n\ny2 &lt;- factor(x2, levels = month_levels)\ny2\n#&gt; [1] Dec  Apr  &lt;NA&gt; Mar \n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\n这似乎有点风险，因此你可能想用forcats::fct()来代替：\n\ny2 &lt;- fct(x2, levels = month_levels)\n#&gt; Error in `fct()`:\n#&gt; ! All values of `x` must appear in `levels` or `na`\n#&gt; ℹ Missing level: \"Jam\"\n\n如果省略了水平，则将按照字母顺序从数据中获取:\n\nfactor(x1)\n#&gt; [1] Dec Apr Jan Mar\n#&gt; Levels: Apr Dec Jan Mar\n\n按字母顺序排序稍有风险，因为并非每台计算机都会以相同的方式对字符串进行排序。因 此，forcats::fct()是按照首次出现的顺序进行排序的：\n\nfct(x1)\n#&gt; [1] Dec Apr Jan Mar\n#&gt; Levels: Dec Apr Jan Mar\n\n如果你需要直接访问有效的水平集合，可以使用levels()函数来做到这一点：\n\nlevels(y2)\n#&gt;  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n\n你也可以在使用readr包读取数据时，通过col_factor()来创建一个因子：\n\ncsv &lt;- \"\nmonth,value\nJan,12\nFeb,56\nMar,12\"\n\ndf &lt;- read_csv(csv, col_types = cols(month = col_factor(month_levels)))\ndf$month\n#&gt; [1] Jan Feb Mar\n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "factors.html#一般社会调查",
    "href": "factors.html#一般社会调查",
    "title": "16  因子",
    "section": "16.3 一般社会调查",
    "text": "16.3 一般社会调查\n在本章的剩余部分我们将使用forcats::gss_cat，它是来自一般社会调查 (General Social Survey) 的样本数据。该 调查是由芝加哥大学独立研究机构NORC主导，在美国进行的一项长期调查。这 项调查包含数千个问题，因此在gss_cat中Hadley选择了一些问题来说明你在处理因子时会遇到的一些常见挑战。\n\ngss_cat\n#&gt; # A tibble: 21,483 × 9\n#&gt;    year marital         age race  rincome        partyid           \n#&gt;   &lt;int&gt; &lt;fct&gt;         &lt;int&gt; &lt;fct&gt; &lt;fct&gt;          &lt;fct&gt;             \n#&gt; 1  2000 Never married    26 White $8000 to 9999  Ind,near rep      \n#&gt; 2  2000 Divorced         48 White $8000 to 9999  Not str republican\n#&gt; 3  2000 Widowed          67 White Not applicable Independent       \n#&gt; 4  2000 Never married    39 White Not applicable Ind,near rep      \n#&gt; 5  2000 Divorced         25 White Not applicable Not str democrat  \n#&gt; 6  2000 Married          25 White $20000 - 24999 Strong democrat   \n#&gt; # ℹ 21,477 more rows\n#&gt; # ℹ 3 more variables: relig &lt;fct&gt;, denom &lt;fct&gt;, tvhours &lt;int&gt;\n\n(记住，由于该数据集是由包提供的，因此可以使用?gss_cat获取有关变量的更多信息)\n当因子 (factors) 存储在tibble中时，你不能那么容易地看到它们的水平（levels）。查 看它们的一种方法是使用count()函数。\n\ngss_cat |&gt;\n  count(race)\n#&gt; # A tibble: 3 × 2\n#&gt;   race      n\n#&gt;   &lt;fct&gt; &lt;int&gt;\n#&gt; 1 Other  1959\n#&gt; 2 Black  3129\n#&gt; 3 White 16395\n\n在处理因子时，两种最常见的操作是改变水平的顺序和改变水平的值。这 些操作将在下面的部分中描述。\n\n16.3.1 练习\n\n探索rincome (申报收入) 的分布。默 认的条形图为什么难以理解？如 何改进该图？\n这个调查中哪个relig最常见？哪 个partyid最常见？\ndenom（教派）适用于哪个宗教？你 如何用表格来查找？你 如何用可视化来查找？",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "factors.html#sec-modifying-factor-order",
    "href": "factors.html#sec-modifying-factor-order",
    "title": "16  因子",
    "section": "16.4 修改因子顺序",
    "text": "16.4 修改因子顺序\n在可视化中改变因子水平的顺序通常很有用。例 如，假设你想要探索不同宗教每天平均看电视的小时数：\n\nrelig_summary &lt;- gss_cat |&gt;\n  group_by(relig) |&gt;\n  summarize(\n    tvhours = mean(tvhours, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(relig_summary, aes(x = tvhours, y = relig)) + \n  geom_point()\n\n\n\n\n\n\n\n\n这个图很难阅读，因为没有整体的模式。我 们可以使用fct_reorder()函数来重新排序relig的水平以改进它。f ct_reorder()接受三个参数：\n\n.f, 要修改水平的因子；\n.x, 一个用于对水平重新排序的数字向量；\n可选参数，.fun是一个函数，在.f的每个值对应多个.x值时使用。默认值是median。\n\n\nggplot(relig_summary, aes(x = tvhours, y = fct_reorder(relig, tvhours))) +\n  geom_point()\n\n\n\n\n\n\n\n\n宗教重新排序后，可以更容易看出“不知道”类别的人看电视更多，而印度教和其他东方宗教的人则看得更少。\n当你开始进行更复杂的转换时，我们建议你将它们从aes()中移出，并放入一个单独的mutate()步骤中。例 如，你可以将上面的图形重写为：\n\nrelig_summary |&gt;\n  mutate(\n    relig = fct_reorder(relig, tvhours)\n  ) |&gt;\n  ggplot(aes(x = tvhours, y = relig)) +\n  geom_point()\n\n如果我们创建一个类似的图形来查看申报的收入水平如何随着平均年龄而变化，该怎么做呢？\n\nrincome_summary &lt;- gss_cat |&gt;\n  group_by(rincome) |&gt;\n  summarize(\n    age = mean(age, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(rincome_summary, aes(x = age, y = fct_reorder(rincome, age))) + \n  geom_point()\n\n\n\n\n\n\n\n\n在这里，随意重新排序水平不是一个好主意！因 为rincome已经有了一个基于原则的顺序，我们不应该随意打乱它。f ct_reorder()用于那些水平是任意排序的因子。\n但是，将“Not applicable”与其他特殊水平一起放在前面是有意义的。这 时可以使用fct_relevel()，这个函数接收一个因子.f，然后是你想移动到行前面的任意数量的水平。\n\nggplot(rincome_summary, aes(x = age, y = fct_relevel(rincome, \"Not applicable\"))) +\n  geom_point()\n\n\n\n\n\n\n\n\n你觉得为什么“不适用”的平均年龄这么高？\n另一种重新排序在你为图形上的线条着色时很有用。f ct_reorder2(.f, .x, .y)通过与.x值中最大的值相关联的.y值来重新排序因子.f。这 使得图形更容易阅读，因为图形最右边的线条颜色将与图例对齐。\nby_age &lt;- gss_cat |&gt;\n  filter(!is.na(age)) |&gt; \n  count(age, marital) |&gt;\n  group_by(age) |&gt;\n  mutate(\n    prop = n / sum(n)\n  )\n\nggplot(by_age, aes(x = age, y = prop, color = marital)) +\n  geom_line(linewidth = 1) + \n  scale_color_brewer(palette = \"Set1\")\n\nggplot(by_age, aes(x = age, y = prop, color = fct_reorder2(marital, age, prop))) +\n  geom_line(linewidth = 1) +\n  scale_color_brewer(palette = \"Set1\") + \n  labs(color = \"marital\") \n\n\n\n\n\n\n\n\n\n\n最后，对于条形图，你可以使用fct_infreq()来按频数递减的顺序排列水平：这是最简单的重新排序类型，因为它不需要任何额外的变量。如 果你希望按频数递增的顺序排列它们（这样在条形图中最大的值位于右侧而不是左侧），可以将它与fct_rev()结合使用。\n\ngss_cat |&gt;\n  mutate(marital = marital |&gt; fct_infreq() |&gt; fct_rev()) |&gt;\n  ggplot(aes(x = marital)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n\n16.4.1 练习\n\ntvhours中有一些可疑的大数。均 数是一个好的汇总吗？\n对于gss_cat中的每个因子，确定其水平的顺序是任意的还是遵循原则的。\n为什么将“Not applicable”移至水平的前端会使其在图的底部显示？",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "factors.html#修改因子水平",
    "href": "factors.html#修改因子水平",
    "title": "16  因子",
    "section": "16.5 修改因子水平",
    "text": "16.5 修改因子水平\n比改变水平顺序更有影响力的是修改它们的值。这 允许你明确标签以便适合发表，合并水平以便更好显示。最 通用且强大的工具是fct_recode()，它允许你重编码或改变每个水平的值。例 如，从gss_cat数据框中取出partyid变量：\n\ngss_cat |&gt; count(partyid)\n#&gt; # A tibble: 10 × 2\n#&gt;   partyid                n\n#&gt;   &lt;fct&gt;              &lt;int&gt;\n#&gt; 1 No answer            154\n#&gt; 2 Don't know             1\n#&gt; 3 Other party          393\n#&gt; 4 Strong republican   2314\n#&gt; 5 Not str republican  3032\n#&gt; 6 Ind,near rep        1791\n#&gt; # ℹ 4 more rows\n\n这些水平的标签简洁且不一致。让 我们调整一下使它们更长，并且使用平行结构。和 tidyverse中大多数重命名和重新编码函数一样，新值在左侧，旧值在右侧：\n\ngss_cat |&gt;\n  mutate(\n    partyid = fct_recode(partyid,\n      \"Republican, strong\"    = \"Strong republican\",\n      \"Republican, weak\"      = \"Not str republican\",\n      \"Independent, near rep\" = \"Ind,near rep\",\n      \"Independent, near dem\" = \"Ind,near dem\",\n      \"Democrat, weak\"        = \"Not str democrat\",\n      \"Democrat, strong\"      = \"Strong democrat\"\n    )\n  ) |&gt;\n  count(partyid)\n#&gt; # A tibble: 10 × 2\n#&gt;   partyid                   n\n#&gt;   &lt;fct&gt;                 &lt;int&gt;\n#&gt; 1 No answer               154\n#&gt; 2 Don't know                1\n#&gt; 3 Other party             393\n#&gt; 4 Republican, strong     2314\n#&gt; 5 Republican, weak       3032\n#&gt; 6 Independent, near rep  1791\n#&gt; # ℹ 4 more rows\n\nfct_recode()会保留没有明确提及的水平不变，并且如果你不小心引用了不存在的水平，它会警告你。\n要合并水平，你可以将多个旧水平分配给同一个新水平：\n\ngss_cat |&gt;\n  mutate(\n    partyid = fct_recode(partyid,\n      \"Republican, strong\"    = \"Strong republican\",\n      \"Republican, weak\"      = \"Not str republican\",\n      \"Independent, near rep\" = \"Ind,near rep\",\n      \"Independent, near dem\" = \"Ind,near dem\",\n      \"Democrat, weak\"        = \"Not str democrat\",\n      \"Democrat, strong\"      = \"Strong democrat\",\n      \"Other\"                 = \"No answer\",\n      \"Other\"                 = \"Don't know\",\n      \"Other\"                 = \"Other party\"\n    )\n  )\n\n请谨慎使用这种方法：如果你将真正不同的类别组合在一起，最终可能会得到误导性的结果。\n如果你想要合并很多水平，fct_collapse()是fct_recode()的一个有用的变体。对 于每个新变量，你可以提供一个旧水平的向量：\n\ngss_cat |&gt;\n  mutate(\n    partyid = fct_collapse(partyid,\n      \"other\" = c(\"No answer\", \"Don't know\", \"Other party\"),\n      \"rep\" = c(\"Strong republican\", \"Not str republican\"),\n      \"ind\" = c(\"Ind,near rep\", \"Independent\", \"Ind,near dem\"),\n      \"dem\" = c(\"Not str democrat\", \"Strong democrat\")\n    )\n  ) |&gt;\n  count(partyid)\n#&gt; # A tibble: 4 × 2\n#&gt;   partyid     n\n#&gt;   &lt;fct&gt;   &lt;int&gt;\n#&gt; 1 other     548\n#&gt; 2 rep      5346\n#&gt; 3 ind      8409\n#&gt; 4 dem      7180\n\n有时你只是想将小的组合并在一起，以使绘图或表格更简洁。这 就是fct_lump_*()函数家族的任务。f ct_lump_lowfreq()是一个简单的起点，它逐步将最小的组类别合并为“Other”，并始终保持“Other”为最小的类别。\n\ngss_cat |&gt;\n  mutate(relig = fct_lump_lowfreq(relig)) |&gt;\n  count(relig)\n#&gt; # A tibble: 2 × 2\n#&gt;   relig          n\n#&gt;   &lt;fct&gt;      &lt;int&gt;\n#&gt; 1 Protestant 10846\n#&gt; 2 Other      10637\n\n在这种情况下，它不是很有用：这项调查中的大多数美国人是新教徒，但我们可能想看到更多细节！相 反，我们可以使用fct_lump_n()来指定我们正好想要10个组：\n\ngss_cat |&gt;\n  mutate(relig = fct_lump_n(relig, n = 10)) |&gt;\n  count(relig, sort = TRUE)\n#&gt; # A tibble: 10 × 2\n#&gt;   relig          n\n#&gt;   &lt;fct&gt;      &lt;int&gt;\n#&gt; 1 Protestant 10846\n#&gt; 2 Catholic    5124\n#&gt; 3 None        3523\n#&gt; 4 Christian    689\n#&gt; 5 Other        458\n#&gt; 6 Jewish       388\n#&gt; # ℹ 4 more rows\n\n阅读文档了解fct_lump_min()和fct_lump_prop()，它们在其他情况下很有用。\n\n16.5.1 练习\n\n人们将自己视为民主党人、共和党人和无党派人士的比例是如何随时间变化的？\n你如何将rincome合并成一小类？\n请注意上面的fct_lump示例中有9个组 (不包括其他) ，为什么不是10个？( 提示：键入?fct_lump，并找到参数other_level的默认值为”Other”)",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "factors.html#sec-ordered-factors",
    "href": "factors.html#sec-ordered-factors",
    "title": "16  因子",
    "section": "16.6 有序因子",
    "text": "16.6 有序因子\n在我们继续之前，有一种特殊的因子需要简要地提一下：有序因子。有 序因子使用ordered()创建，表示水平之间存在严格的顺序和相等的距离：第一个水平“小于”第二个水平的程度与第二个水平“小于”第三个水平的程度相同，以此类推。在 输出时可以通过因子水平之间使用的&lt;来识别它们：\n\nordered(c(\"a\", \"b\", \"c\"))\n#&gt; [1] a b c\n#&gt; Levels: a &lt; b &lt; c\n\n在实践中，ordered()因子与常规因子的行为非常相似。你 只有在以下两种情况下可能会注意到不同的行为：\n\n如果你在ggplot2中将有序因子映射到颜色或填充上，它将默认使用scale_color_viridis()/scale_fill_viridis()，这是一种暗含排名的颜色比例尺。\n如果你在线性模型中使用有序函数，它将使用“多边形对比”。这些对比有些用处，但除非你拥有统计学博士学位，否则你可能不会听说过它们，即使你有，你也可能不会常规地解释它们。如果你想了解更多，我们推荐阅读 Lisa DeBruine 写的vignette(\"contrasts\", package = \"faux\")。\n\n鉴于这些差异有争议，我们一般不推荐使用有序因子。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "factors.html#小结",
    "href": "factors.html#小结",
    "title": "16  因子",
    "section": "16.7 小结",
    "text": "16.7 小结\n本章向你介绍了用于处理因子的实用包forcats，并介绍了最常用的函数。f orcats还包含了许多其他辅助函数，在这里我们没有足够的篇幅讨论它们；因此，每当你面临以前从未遇到的因子分析挑战时，我强烈建议你浏览reference index，看看是否有现成的函数可以帮助你解决问题。\n如果你在阅读本章后想了解更多关于因子的内容，我们建议您阅读Amelia McNamara和Nicholas Horton的论文《Wrangling categorical data in R》。这 篇论文概述了stringsAsFactors: An unauthorized biography和stringsAsFactors = &lt;sigh&gt;中讨论的一些历史，并将本书中概述的分类数据的整齐方法与R基础方法进行了比较。这 篇论文的早期版本有助于推动forcats包的开发和范围确定；感谢Amelia和Nick！\n在下一章中，我们将转变话题，开始学习R中的日期和时间。日 期和时间看起来很简单，但你很快就会看到，随着对它们了解得越多，它们似乎变得越复杂！",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "factors.html#footnotes",
    "href": "factors.html#footnotes",
    "title": "16  因子",
    "section": "",
    "text": "它们对建模也很重要。↩︎",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "datetimes.html",
    "href": "datetimes.html",
    "title": "17  日期和时间",
    "section": "",
    "text": "17.1 引言\n本章将向你展示如何在R中处理日期和时间。乍 一看，日期和时间似乎很简单，在日常生活中会经常使用它们，似乎并不会引起太多混淆。然 而，你对日期和时间了解得越多，它们似乎就变得越复杂！\n为了预热，请思考一年中有多少天，一天中有多少小时。你 可能记得大多数年份有365天，但闰年有366天。你 知道确定某年是否为闰年的完整规则吗？一 天中的小时数就不太明显了：大多数日子有24小时，但在使用夏令时（DST）的地方，每年有一天是23小时，另一天是25小时。\n日期和时间之所以难以处理，是因为它们必须协调两种物理现象（地球的自转和绕太阳的公转）以及包括月份、时区和夏令时在内的一系列地缘政治现象。本 章不会告诉你关于日期和时间的每一个细节，但将为你提供扎实的实践技能基础，帮助你应对常见的数据分析挑战。\n我们将首先向你展示如何从各种输入中创建日期-时间；一旦你有了日期-时间，你就可以提取诸如年、月和日等组件。接 下来，我们将深入探讨处理时间跨度的棘手话题，根据你要做的事情不同，时间跨度会有各种各样的形式。最 后，我们将简要讨论时区带来的额外挑战。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>日期和时间</span>"
    ]
  },
  {
    "objectID": "datetimes.html#引言",
    "href": "datetimes.html#引言",
    "title": "17  日期和时间",
    "section": "",
    "text": "17.1.1 必要条件\n本章将重点关注lubridate包，它使在R中处理日期和时间变得更加容易。在 最新的 tidyverse 发行版中，lubridate 是核心包tidyverse的一部分。我 们还将需要nycflights13数据集作为练习数据。\n\nlibrary(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>日期和时间</span>"
    ]
  },
  {
    "objectID": "datetimes.html#sec-creating-datetimes",
    "href": "datetimes.html#sec-creating-datetimes",
    "title": "17  日期和时间",
    "section": "17.2 创建日期/时间",
    "text": "17.2 创建日期/时间\n有三种日期/时间数据类型，它们指的都是时间的一个瞬间：\n\n日期（date）：Tibbles 输出为&lt;date&gt;。\n时间（time）：Tibbles 输出为&lt;time&gt;。\n日期-时间（date-time）：日期加上时间，唯一地标识了一个瞬时时间（通常精确到秒）。T ibbles 输出为&lt;dttm&gt;。B ase R将这些称为 POSIXct，但这个名称并不是很好说。\n\n在本章中，我们将重点关注日期和日期-时间，因为 R 没有用于存储时间的原生类。如 果你需要这样的类，你可以使用 hms 包。\n你应该始终使用最简单的可能满足你需求的数据类型。这 意味着，如果你可以使用日期而不是日期-时间，那么你就应该这样做。日 期-时间要复杂得多，因为需要处理时区，我们将在本章末尾再讨论这个问题。\n要获取当前日期或日期-时间，你可以使用today()或now()：\n\ntoday()\n#&gt; [1] \"2024-10-24\"\nnow()\n#&gt; [1] \"2024-10-24 23:21:13 UTC\"\n\n另外，下面的部分描述了你可能创建日期/时间的四种方法:\n\n在使用readr读取文件时；\n从字符串；\n从单个日期-时间组件；\n从现有的日期-时间对象。\n\n\n17.2.1 During import\n如果你的CSV文件包含ISO8601日期或日期-时间，则不需要做任何操作，readr会自动识别它:\n\ncsv &lt;- \"\n  date,datetime\n  2022-01-02,2022-01-02 05:12\n\"\nread_csv(csv)\n#&gt; # A tibble: 1 × 2\n#&gt;   date       datetime           \n#&gt;   &lt;date&gt;     &lt;dttm&gt;             \n#&gt; 1 2022-01-02 2022-01-02 05:12:00\n\n可能你之前没听说过 ISO8601，它是一种国际日期编写标准，其中日期的组成部分按照从大到小的顺序用短横线（-）分隔。例 如，在 ISO8601 中，2022年5月3日写作 2022-05-03。I SO8601日期还可以包含时间，其中小时、分钟和秒用冒号:分隔，日期和时间组件用 T 或空格分隔。例 如，你可以将 2022年5月3日下午4点26分写作2022-05-03 16:26 或 2022-05-03T16:26。\n对于其他日期-时间格式，你需要使用col_types加上col_date()或col_datetime()以及一个日期-时间格式。r eadr使用的日期时间格式是许多编程语言通用的标准，使用%后跟一个单字符来描述日期组件。例 如，%Y-%m-%d指定了一个格式为年-月（数字）-日的日期。@ tbl-date-formats 列出了所有选项。\n\n\n\n表 17.1: readr 理解的所有日期格式\n\n\n\n\n\n类型\n代码\n意义\n实例\n\n\n\n\n年\n%Y\n4 位数 年\n2021\n\n\n\n%y\n2 位数 年\n21\n\n\n月\n%m\n数字\n2\n\n\n\n%b\n缩写名\nFeb\n\n\n\n%B\n全名\nFebruary\n\n\n日\n%d\n一个或两个数字\n2\n\n\n\n%e\n两个数字\n02\n\n\n时间\n%H\n24-小时 小时\n13\n\n\n\n%I\n12-小时 小时\n1\n\n\n\n%p\nAM/PM\npm\n\n\n\n%M\n分钟\n35\n\n\n\n%S\n秒\n45\n\n\n\n%OS\n带有小数的秒\n45.35\n\n\n\n%Z\n时区名称\nAmerica/Chicago\n\n\n\n%z\nUTC偏移量\n+0800\n\n\n其他\n%.\n跳过一个非数字\n:\n\n\n\n%*\n跳过任何非数字的数字\n\n\n\n\n\n\n\n下面这段代码展示了几个应用于一个非常模糊的日期的选项:\nAnd this code shows a few options applied to a very ambiguous date:\n\ncsv &lt;- \"\n  date\n  01/02/15\n\"\n\nread_csv(csv, col_types = cols(date = col_date(\"%m/%d/%y\")))\n#&gt; # A tibble: 1 × 1\n#&gt;   date      \n#&gt;   &lt;date&gt;    \n#&gt; 1 2015-01-02\n\nread_csv(csv, col_types = cols(date = col_date(\"%d/%m/%y\")))\n#&gt; # A tibble: 1 × 1\n#&gt;   date      \n#&gt;   &lt;date&gt;    \n#&gt; 1 2015-02-01\n\nread_csv(csv, col_types = cols(date = col_date(\"%y/%m/%d\")))\n#&gt; # A tibble: 1 × 1\n#&gt;   date      \n#&gt;   &lt;date&gt;    \n#&gt; 1 2001-02-15\n\n注意，无论你如何指定日期格式，一旦将日期导入 R 中，它总是以相同的方式显示。\n如果您使用%b或%B并处理非英语日期，您还需要提供一个locale()。请 查看date_names_langs()中的内置语言列表，或者使用date_names()创建您自己的语言设置。\n\n\n17.2.2 从字符串\n日期-时间规范语言功能强大，但需要仔细分析日期格式。另 一种方法是使用 lubridate 的辅助函数，这些函数尝试在你指定组件顺序后自动确定格式。要 使用它们，请确定年、月和日等组件在日期中出现的顺序，然后按照相同的顺序排列 “y”、“m” 和 “d”。这 将给出可用于解析日期的 lubridate 函数的名称。例 如：\n\nymd(\"2017-01-31\")\n#&gt; [1] \"2017-01-31\"\nmdy(\"January 31st, 2017\")\n#&gt; [1] \"2017-01-31\"\ndmy(\"31-Jan-2017\")\n#&gt; [1] \"2017-01-31\"\n\nymd()及其相关函数用于创建日期。要 创建日期-时间，请在解析函数名称后添加一个下划线和一个或多个 “h”、“m” 和 “s”：\n\nymd_hms(\"2017-01-31 20:11:59\")\n#&gt; [1] \"2017-01-31 20:11:59 UTC\"\nmdy_hm(\"01/31/2017 08:01\")\n#&gt; [1] \"2017-01-31 08:01:00 UTC\"\n\n你也可以通过提供时区来强制从日期创建日期-时间：\n\nymd(\"2017-01-31\", tz = \"UTC\")\n#&gt; [1] \"2017-01-31 UTC\"\n\n这里使用的是 UTC1 时区，你知道的可能是 GMT，或者格林威治标准时间，也就是 0° 经线2的时间 。它不使用夏令时，使得计算更加方便 。\n\n\n17.2.3 从单个组件\n有时，日期-时间的各个组件会分散在多个列中，而不是在单个字符串。例 如下面的flights 数据:\n\nflights |&gt; \n  select(year, month, day, hour, minute)\n#&gt; # A tibble: 336,776 × 5\n#&gt;    year month   day  hour minute\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1  2013     1     1     5     15\n#&gt; 2  2013     1     1     5     29\n#&gt; 3  2013     1     1     5     40\n#&gt; 4  2013     1     1     5     45\n#&gt; 5  2013     1     1     6      0\n#&gt; 6  2013     1     1     5     58\n#&gt; # ℹ 336,770 more rows\n\n要从这种类型的输入创建日期/时间，使用make_date()表示日期，或使用make_datetime()表示日期-时间:\n\nflights |&gt; \n  select(year, month, day, hour, minute) |&gt; \n  mutate(departure = make_datetime(year, month, day, hour, minute))\n#&gt; # A tibble: 336,776 × 6\n#&gt;    year month   day  hour minute departure          \n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dttm&gt;             \n#&gt; 1  2013     1     1     5     15 2013-01-01 05:15:00\n#&gt; 2  2013     1     1     5     29 2013-01-01 05:29:00\n#&gt; 3  2013     1     1     5     40 2013-01-01 05:40:00\n#&gt; 4  2013     1     1     5     45 2013-01-01 05:45:00\n#&gt; 5  2013     1     1     6      0 2013-01-01 06:00:00\n#&gt; 6  2013     1     1     5     58 2013-01-01 05:58:00\n#&gt; # ℹ 336,770 more rows\n\n让我们对 flights 数据集中的四个时间列进行同样的操作。因 为时间以一种有点奇怪的格式表示，所以使用模运算来提取小时和分钟组件。一 旦创建了日期-时间变量之后，我们将其作为本章其余部分要探索的变量。\n\nmake_datetime_100 &lt;- function(year, month, day, time) {\n  make_datetime(year, month, day, time %/% 100, time %% 100)\n}\n\nflights_dt &lt;- flights |&gt; \n  filter(!is.na(dep_time), !is.na(arr_time)) |&gt; \n  mutate(\n    dep_time = make_datetime_100(year, month, day, dep_time),\n    arr_time = make_datetime_100(year, month, day, arr_time),\n    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),\n    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)\n  ) |&gt; \n  select(origin, dest, ends_with(\"delay\"), ends_with(\"time\"))\n\nflights_dt\n#&gt; # A tibble: 328,063 × 9\n#&gt;   origin dest  dep_delay arr_delay dep_time            sched_dep_time     \n#&gt;   &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dttm&gt;              &lt;dttm&gt;             \n#&gt; 1 EWR    IAH           2        11 2013-01-01 05:17:00 2013-01-01 05:15:00\n#&gt; 2 LGA    IAH           4        20 2013-01-01 05:33:00 2013-01-01 05:29:00\n#&gt; 3 JFK    MIA           2        33 2013-01-01 05:42:00 2013-01-01 05:40:00\n#&gt; 4 JFK    BQN          -1       -18 2013-01-01 05:44:00 2013-01-01 05:45:00\n#&gt; 5 LGA    ATL          -6       -25 2013-01-01 05:54:00 2013-01-01 06:00:00\n#&gt; 6 EWR    ORD          -4        12 2013-01-01 05:54:00 2013-01-01 05:58:00\n#&gt; # ℹ 328,057 more rows\n#&gt; # ℹ 3 more variables: arr_time &lt;dttm&gt;, sched_arr_time &lt;dttm&gt;, …\n\n有了这些数据，我们可以看到全年的出发时间分布:\n\nflights_dt |&gt; \n  ggplot(aes(x = dep_time)) + \n  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day\n\n\n\n\n\n\n\n\n或者一天之内的:\n\nflights_dt |&gt; \n  filter(dep_time &lt; ymd(20130102)) |&gt; \n  ggplot(aes(x = dep_time)) + \n  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes\n\n\n\n\n\n\n\n\n请注意，当您在数值环境中使用日期-时间（如在直方图中）时，1 表示 1 秒，因此 86400 的 binwidth 表示一天；对于日期，1 表示 1 天。\n\n\n17.2.4 从其他类型\n你可能想要在日期-时间和日期之间切换。这 就是as_datetime()和as_date()的工作:\nYou may want to switch between a date-time and a date. That’s the job of as_datetime() and as_date():\n\nas_datetime(today())\n#&gt; [1] \"2024-10-24 UTC\"\nas_date(now())\n#&gt; [1] \"2024-10-24\"\n\n有时，你将获得日期/时间作为“Unix Epoch”1970-01-01的数字偏移量。如 果偏移量以秒为单位，则使用as_datetime()；如果以天为单位，则使用as_date()。\n有时你会得到以“Unix 时间戳”（即 1970-01-01）为基准的日期/时间数值偏移量。如 果偏移量以秒为单位的，使用as_datetime()；如果以天为单位，使用as_date()。\n\nas_datetime(60 * 60 * 10)\n#&gt; [1] \"1970-01-01 10:00:00 UTC\"\nas_date(365 * 10 + 2)\n#&gt; [1] \"1980-01-01\"\n\n\n\n17.2.5 练习\n\n如果解析包含无效日期的字符串会发生什么?\n\nymd(c(\"2010-10-10\", \"bananas\"))\n\ntoday()的tzone参数是做什么的？为 什么它很重要？\n对于以下每个日期-时间，演示你如何使用 readr 的列规范和 lubridate 函数来解析它。\n\nd1 &lt;- \"January 1, 2010\"\nd2 &lt;- \"2015-Mar-07\"\nd3 &lt;- \"06-Jun-2017\"\nd4 &lt;- c(\"August 19 (2015)\", \"July 1 (2015)\")\nd5 &lt;- \"12/30/14\" # Dec 30, 2014\nt1 &lt;- \"1705\"\nt2 &lt;- \"11:15:10.12 PM\"",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>日期和时间</span>"
    ]
  },
  {
    "objectID": "datetimes.html#日期-时间组件",
    "href": "datetimes.html#日期-时间组件",
    "title": "17  日期和时间",
    "section": "17.3 日期-时间组件",
    "text": "17.3 日期-时间组件\n现在你已经知道了如何将日期-时间数据导入到 R 的日期-时间数据结构中，接下来探索一下可以用它们做些什么。本 节将重点介绍获取和设置单个组件的存取函数（accessor functions），下一节将探讨日期-时间的算术运算。\n\n17.3.1 获取组件\n你可以使用存取函数year()、month()、mday()（一月中的某天）、yday()（一年中的某天）、wday()（一周中的某天）、hour()、minute()和second()来提取日期的各个部分。这 些函数实际上是make_datetime()的反相操作。\n\ndatetime &lt;- ymd_hms(\"2026-07-08 12:34:56\")\n\nyear(datetime)\n#&gt; [1] 2026\nmonth(datetime)\n#&gt; [1] 7\nmday(datetime)\n#&gt; [1] 8\n\nyday(datetime)\n#&gt; [1] 189\nwday(datetime)\n#&gt; [1] 4\n\n对于month()和wday()，你可以设置label = TRUE来返回月份的缩写名或星期几的缩写名。设 置abbr = FALSE来返回全名。\n\nmonth(datetime, label = TRUE)\n#&gt; [1] Jul\n#&gt; 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec\nwday(datetime, label = TRUE, abbr = FALSE)\n#&gt; [1] Wednesday\n#&gt; 7 Levels: Sunday &lt; Monday &lt; Tuesday &lt; Wednesday &lt; Thursday &lt; ... &lt; Saturday\n\n使用wday()会发现工作日起飞的航班比周末起飞的航班多：\n\nflights_dt |&gt; \n  mutate(wday = wday(dep_time, label = TRUE)) |&gt; \n  ggplot(aes(x = wday)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n还可以查看一小时内的平均起飞延误时间（以分钟为单位）。你 会发现一个有趣的模式：20～30分钟和50～60分钟起飞的航班比其他时间的航班延误要少得多！\n\nflights_dt |&gt; \n  mutate(minute = minute(dep_time)) |&gt; \n  group_by(minute) |&gt; \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE),\n    n = n()\n  ) |&gt; \n  ggplot(aes(x = minute, y = avg_delay)) +\n  geom_line()\n\n\n\n\n\n\n\n\n有趣的是，如果查看预定的起飞时间，则不会发现这种明显的模式:\n\nsched_dep &lt;- flights_dt |&gt; \n  mutate(minute = minute(sched_dep_time)) |&gt; \n  group_by(minute) |&gt; \n  summarize(\n    avg_delay = mean(arr_delay, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(sched_dep, aes(x = minute, y = avg_delay)) +\n  geom_line()\n\n\n\n\n\n\n\n\n那么为什么在实际起飞时间中看到了这个模式呢？这 就像人类收集的很多数据一样，人们强烈倾向于在“合适”的起飞时间起飞的航班，正如 图 17.1 所展示的，每当你处理涉及人类判断的数据时，都要警惕这种模式的出现！\n\n\n\n\n\n\n\n\n图 17.1: A frequency polygon showing the number of flights scheduled to depart each hour. You can see a strong preference for round numbers like 0 and 30 and generally for numbers that are a multiple of five.\n\n\n\n\n\n\n\n17.3.2 四舍五入（rounding）\n绘制单个组件的另一种方法是使用floor_date()、round_date()和ceiling_date()将日期四舍五入到附近的时间单位。每 个函数都接受一个日期向量进行调整，然后是要向下（floor）、向上取整（ceiling）或四舍五入到的单位名称。例 如，下面的代码可以绘制每周的航班数量：\n\nflights_dt |&gt; \n  count(week = floor_date(dep_time, \"week\")) |&gt; \n  ggplot(aes(x = week, y = n)) +\n  geom_line() + \n  geom_point()\n\n\n\n\n\n\n\n\n你可以使用四舍五入来计算dep_time与当天最早时间之间的差值，从而显示航班在一天内的分布情况。\n\nflights_dt |&gt; \n  mutate(dep_hour = dep_time - floor_date(dep_time, \"day\")) |&gt; \n  ggplot(aes(x = dep_hour)) +\n  geom_freqpoly(binwidth = 60 * 30)\n#&gt; Don't know how to automatically pick scale for object of type &lt;difftime&gt;.\n#&gt; Defaulting to continuous.\n\n\n\n\n\n\n\n\n计算一对日期-时间之间的差值会产生difftime(更多信息请参见@sec-intervals)。我 们可以将其转换为hms对象以获得更有用的x轴:\n\nflights_dt |&gt; \n  mutate(dep_hour = hms::as_hms(dep_time - floor_date(dep_time, \"day\"))) |&gt; \n  ggplot(aes(x = dep_hour)) +\n  geom_freqpoly(binwidth = 60 * 30)\n\n\n\n\n\n\n\n\n\n\n17.3.3 修改组件\n可以使用每个存取函数来修改日期/时间的组件。这 在数据分析中并不常见，但在清理日期明显不正确的数据时很有用。\n\n(datetime &lt;- ymd_hms(\"2026-07-08 12:34:56\"))\n#&gt; [1] \"2026-07-08 12:34:56 UTC\"\n\nyear(datetime) &lt;- 2030\ndatetime\n#&gt; [1] \"2030-07-08 12:34:56 UTC\"\nmonth(datetime) &lt;- 01\ndatetime\n#&gt; [1] \"2030-01-08 12:34:56 UTC\"\nhour(datetime) &lt;- hour(datetime) + 1\ndatetime\n#&gt; [1] \"2030-01-08 13:34:56 UTC\"\n\n另外，可以使用update()创建一个新的日期-时间，而不是修改现有的变量。这 允许你在一步中设置多个值:\n\nupdate(datetime, year = 2030, month = 2, mday = 2, hour = 2)\n#&gt; [1] \"2030-02-02 02:34:56 UTC\"\n\n如果值太大, 则会滚动计算:\n\nupdate(ymd(\"2023-02-01\"), mday = 30)\n#&gt; [1] \"2023-03-02\"\nupdate(ymd(\"2023-02-01\"), hour = 400)\n#&gt; [1] \"2023-02-17 16:00:00 UTC\"\n\n\n\n17.3.4 练习\n\n一天内的飞行时间分布在一年中是如何变化的?\n比较 dep_time, sched_dep_time 和 dep_delay，它们是一致的吗？解 释你的发现。\n比较air_time与起飞和到达之间的时间间隔，并解释你的发现。（ 提示: 考虑机场位置）\n一天中平均延误时间是如何变化的？应 该使用dep_time还是sched_dep_time？为 什么？\n如果想最小化延误的可能性，你应该选择一周中的哪一天离开？\n什么使得diamonds$carat和flights$sched_dep_time的分布相似？\n证实这个假设：航班在20～30分钟和50～60分钟内提早出发是因为这些航班原本就安排在这个时间提前出发。( 提示: 创建一个二分类变量来告诉你航班是否延误)",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>日期和时间</span>"
    ]
  },
  {
    "objectID": "datetimes.html#时间跨度",
    "href": "datetimes.html#时间跨度",
    "title": "17  日期和时间",
    "section": "17.4 时间跨度",
    "text": "17.4 时间跨度\n接下来，你将学习日期的算术运算，包括减法、加法和除法。在 这个过程中，了解三种表示时间跨度的重要类：\n\n时长（Durations），精确到秒的一个数字。\n周期（Periods），人类定义的时间单位，如周和月。\n区间（Intervals），表示起点和终点。\n\n如何在持续时间、周期和间隔之间做出选择？和 往常一样，选择最简单的能解决你问题的数据结构。如 果你只关心物理时间，使用持续时间；如果你需要添加人类的时间单位，使用周期；如果你需要计算出人类时间单位下的时间跨度有多长，使用间隔。\n\n17.4.1 时长\n在R中，当两个日期相减后你会得到一个difftime对象：\n\n# How old is Hadley?\nh_age &lt;- today() - ymd(\"1979-10-14\")\nh_age\n#&gt; Time difference of 16447 days\n\ndifftime类的一个对象记录了一个时间跨度，可以是秒、分、小时、天或周。这 种不确定性可能会让difftimes使用起来有些麻烦。因 此，lubridate提供了一个总是以秒为单位的替代方案：时长。\n\nas.duration(h_age)\n#&gt; [1] \"1421020800s (~45.03 years)\"\n\n时长提供了一系列方便的构造函数:\n\ndseconds(15)\n#&gt; [1] \"15s\"\ndminutes(10)\n#&gt; [1] \"600s (~10 minutes)\"\ndhours(c(12, 24))\n#&gt; [1] \"43200s (~12 hours)\" \"86400s (~1 days)\"\nddays(0:5)\n#&gt; [1] \"0s\"                \"86400s (~1 days)\"  \"172800s (~2 days)\"\n#&gt; [4] \"259200s (~3 days)\" \"345600s (~4 days)\" \"432000s (~5 days)\"\ndweeks(3)\n#&gt; [1] \"1814400s (~3 weeks)\"\ndyears(1)\n#&gt; [1] \"31557600s (~1 years)\"\n\n时长总是以秒为单位记录时间跨度。较 大的单位是通过将分钟、小时、天、周和年转换为秒来创建的：一分钟有60秒，一小时有60分钟，一天有24小时，一周有7天。更 大的时间单位则更成问题。一 年使用一年中的“平均”天数，即365.25。没 有办法将月转换为时长，因为变化太多了。\n可以对时长进行加法和乘法运算：\n\n2 * dyears(1)\n#&gt; [1] \"63115200s (~2 years)\"\ndyears(1) + dweeks(12) + dhours(15)\n#&gt; [1] \"38869200s (~1.23 years)\"\n\n也可以用日期与时长进行加法或减法运算：\n\ntomorrow &lt;- today() + ddays(1)\nlast_year &lt;- today() - dyears(1)\n\n然而，由于时长是以秒为单位的确切数字，有时可能会得到意想不到的结果：\n\none_am &lt;- ymd_hms(\"2026-03-08 01:00:00\", tz = \"America/New_York\")\n\none_am\n#&gt; [1] \"2026-03-08 01:00:00 EST\"\none_am + ddays(1)\n#&gt; [1] \"2026-03-09 02:00:00 EDT\"\n\n为什么3月8日凌晨1点的一天之后是3月9日凌晨2点？如 果仔细观察日期，就会注意到时区已经改变了。3 月8日只有23小时，因为这一天是夏令时开始的时间，所以如果加上一整天所包含的秒数，最终会得到不同的时间。\n\n\n17.4.2 周期\n为了解决这个问题，lubridate提供了周期。 周期是时间跨度，但它们不以固定的秒数来表示，而是使用“人类”的时间单位，如天和月，这使得它们以更直观的方式工作：\n\none_am\n#&gt; [1] \"2026-03-08 01:00:00 EST\"\none_am + days(1)\n#&gt; [1] \"2026-03-09 01:00:00 EDT\"\n\n与时长一样，可以使用许多友好的构造函数创建周期。\n\nhours(c(12, 24))\n#&gt; [1] \"12H 0M 0S\" \"24H 0M 0S\"\ndays(7)\n#&gt; [1] \"7d 0H 0M 0S\"\nmonths(1:6)\n#&gt; [1] \"1m 0d 0H 0M 0S\" \"2m 0d 0H 0M 0S\" \"3m 0d 0H 0M 0S\" \"4m 0d 0H 0M 0S\"\n#&gt; [5] \"5m 0d 0H 0M 0S\" \"6m 0d 0H 0M 0S\"\n\n周期支持加法和乘法运算:\n\n10 * (months(6) + days(1))\n#&gt; [1] \"60m 10d 0H 0M 0S\"\ndays(50) + hours(25) + minutes(2)\n#&gt; [1] \"50d 25H 2M 0S\"\n\n当然, 也可以与日期相加；与时长相比，周期经期更有可能做你预期的事情：\n\n# A leap year\nymd(\"2024-01-01\") + dyears(1)\n#&gt; [1] \"2024-12-31 06:00:00 UTC\"\nymd(\"2024-01-01\") + years(1)\n#&gt; [1] \"2025-01-01\"\n\n# Daylight saving time\none_am + ddays(1)\n#&gt; [1] \"2026-03-09 02:00:00 EDT\"\none_am + days(1)\n#&gt; [1] \"2026-03-09 01:00:00 EDT\"\n\n让我们使用周期来修复与航班日期相关的一个异常问题。一 些飞机似乎在离开纽约市之前就已经到达了目的地。\n\nflights_dt |&gt; \n  filter(arr_time &lt; dep_time) \n#&gt; # A tibble: 10,633 × 9\n#&gt;   origin dest  dep_delay arr_delay dep_time            sched_dep_time     \n#&gt;   &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dttm&gt;              &lt;dttm&gt;             \n#&gt; 1 EWR    BQN           9        -4 2013-01-01 19:29:00 2013-01-01 19:20:00\n#&gt; 2 JFK    DFW          59        NA 2013-01-01 19:39:00 2013-01-01 18:40:00\n#&gt; 3 EWR    TPA          -2         9 2013-01-01 20:58:00 2013-01-01 21:00:00\n#&gt; 4 EWR    SJU          -6       -12 2013-01-01 21:02:00 2013-01-01 21:08:00\n#&gt; 5 EWR    SFO          11       -14 2013-01-01 21:08:00 2013-01-01 20:57:00\n#&gt; 6 LGA    FLL         -10        -2 2013-01-01 21:20:00 2013-01-01 21:30:00\n#&gt; # ℹ 10,627 more rows\n#&gt; # ℹ 3 more variables: arr_time &lt;dttm&gt;, sched_arr_time &lt;dttm&gt;, …\n\n这些都是夜间航班。我 们为出发和到达时间使用了相同的日期信息，但这些航班在第二天到达。我 们可以通过在每个夜间航班的到达时间上增加days(1)来解决这个问题。\n\nflights_dt &lt;- flights_dt |&gt; \n  mutate(\n    overnight = arr_time &lt; dep_time,\n    arr_time = arr_time + days(overnight),\n    sched_arr_time = sched_arr_time + days(overnight)\n  )\n\n现在所有航班都遵循物理定律。\n\nflights_dt |&gt; \n  filter(arr_time &lt; dep_time) \n#&gt; # A tibble: 0 × 10\n#&gt; # ℹ 10 variables: origin &lt;chr&gt;, dest &lt;chr&gt;, dep_delay &lt;dbl&gt;,\n#&gt; #   arr_delay &lt;dbl&gt;, dep_time &lt;dttm&gt;, sched_dep_time &lt;dttm&gt;, …\n\n\n\n17.4.3 区间\ndyears(1) / ddays(365)返回的值是什么？并 不是1，因为dyears()被定义为平均每年有多少秒，这等于365.25天。\nyears(1) / days(1)返回什么值呢？如 果年份是2015年，它应该返回365，但如果年份是2016年，它应该返回366！l ubridate 没有足够的信息来给出一个明确的答案，相反，它给出了一个估计值：\n\nyears(1) / days(1)\n#&gt; [1] 365.25\n\n如果你想要一个更准确的测量，你将需要使用区间。区 间是一对开始和结束日期时间，或者你可以将其视为带有起始点的时长。\n你可以通过编写start %--% end来创建一个区间：\n\ny2023 &lt;- ymd(\"2023-01-01\") %--% ymd(\"2024-01-01\")\ny2024 &lt;- ymd(\"2024-01-01\") %--% ymd(\"2025-01-01\")\n\ny2023\n#&gt; [1] 2023-01-01 UTC--2024-01-01 UTC\ny2024\n#&gt; [1] 2024-01-01 UTC--2025-01-01 UTC\n\n然后你可以用它除以days()来计算一年中有多少天:\n\ny2023 / days(1)\n#&gt; [1] 365\ny2024 / days(1)\n#&gt; [1] 366\n\n\n\n17.4.4 练习\n\n向刚开始学习R的人解释days(!overnight)和days(overnight)：你需要知道的关键事实是什么？\n创建一个向量，包含2015年每个月的第一天；再创建一个向量，包含当前年份每个月的第一天；\n编写一个函数，给定你的生日（作为日期），返回你的年龄（以年为单位）；\n为什么 (today() %--% (today() + years(1))) / months(1) 不能正常运行?",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>日期和时间</span>"
    ]
  },
  {
    "objectID": "datetimes.html#时区",
    "href": "datetimes.html#时区",
    "title": "17  日期和时间",
    "section": "17.5 时区",
    "text": "17.5 时区\n时区是一个极其复杂的话题，因为它们与地缘政治实体相互交织。幸 运的是，我们不需要深入探究所有细节，因为它们对于数据分析来说并非都是重要的，但有几个挑战我们需要直接面对。\n第一个挑战是日常使用的时区名称往往具有歧义。例 如，如果你是美国人，你可能熟悉EST，即东部标准时间（Eastern Standard Time）。然 而，澳大利亚和加拿大也都有EST！为 了避免混淆，R使用国际标准IANA时区。I ANA使用一致的命名方案{area}/{location}，通常形式为{continent}/{city}或 {ocean}/{city}。例 如“America/New_York”、“Europe/Paris”和“Pacific/Auckland”。\n你可能会好奇为什么时区会使用城市名，而通常你会认为时区是与一个国家或国家内的某个地区相关联的。这 是因为IANA数据库需要记录几十年来的时区规则。在 过去的几十年里，国家的名称（或分裂）经常发生变化，但城市名称往往保持不变。另 一个问题是，名称不仅需要反映当前的行为，还需要反映完整的历史。例 如，存在“America/New_York”和“America/Detroit”这两个时区。这 两个城市目前都使用东部标准时间，但在1969-1972年期间，密歇根州（底特律所在的州）没有实行夏令时，因此它需要一个不同的名称。值 得一读的是原始的时区数据库（https://www.iana.org/time-zones），其中讲述了一些这样的故事！\n你可以使用Sys.timezone()函数来找出R认为你的当前时区是什么。\nYou can find out what R thinks your current time zone is with Sys.timezone():\n\nSys.timezone()\n#&gt; [1] \"UTC\"\n\n(如果R 不知道, 返回 NA.)\n使用 OlsonNames()查看所有时区名称的完整列表:\n\nlength(OlsonNames())\n#&gt; [1] 597\nhead(OlsonNames())\n#&gt; [1] \"Africa/Abidjan\"     \"Africa/Accra\"       \"Africa/Addis_Ababa\"\n#&gt; [4] \"Africa/Algiers\"     \"Africa/Asmara\"      \"Africa/Asmera\"\n\n在R中，时区是日期-时间的一个属性，它只控制输出。例 如，这三个对象表示时间上的同一瞬间\n\nx1 &lt;- ymd_hms(\"2024-06-01 12:00:00\", tz = \"America/New_York\")\nx1\n#&gt; [1] \"2024-06-01 12:00:00 EDT\"\n\nx2 &lt;- ymd_hms(\"2024-06-01 18:00:00\", tz = \"Europe/Copenhagen\")\nx2\n#&gt; [1] \"2024-06-01 18:00:00 CEST\"\n\nx3 &lt;- ymd_hms(\"2024-06-02 04:00:00\", tz = \"Pacific/Auckland\")\nx3\n#&gt; [1] \"2024-06-02 04:00:00 NZST\"\n\n你可以用减法来验证它们是相同的时间:\n\nx1 - x2\n#&gt; Time difference of 0 secs\nx1 - x3\n#&gt; Time difference of 0 secs\n\n除非另有指定，lubridate 总是使用 UTC。U TC是科学界使用的标准时区，相当于 GMT（Greenwich Mean Time，格林威治标准时间）。U TC 不包含夏令时，这使得它在计算时非常方便。像 c() 这样的将日期和时间组合起来的操作通常会丢失时区信息。在 这种情况下，日期和时间将以第一个元素的时区显示：\n\nx4 &lt;- c(x1, x2, x3)\nx4\n#&gt; [1] \"2024-06-01 12:00:00 EDT\" \"2024-06-01 12:00:00 EDT\"\n#&gt; [3] \"2024-06-01 12:00:00 EDT\"\n\n可以通过两种方法更改时区:\n\n保持瞬时时间不变，但改变其显示方式。当 即时时间正确，但你想要一个更自然的方式显示时使用这种方法。\n\nx4a &lt;- with_tz(x4, tzone = \"Australia/Lord_Howe\")\nx4a\n#&gt; [1] \"2024-06-02 02:30:00 +1030\" \"2024-06-02 02:30:00 +1030\"\n#&gt; [3] \"2024-06-02 02:30:00 +1030\"\nx4a - x4\n#&gt; Time differences in secs\n#&gt; [1] 0 0 0\n\n(这也说明了时区的另一个挑战：它们的偏移量并不都是以小时为单位的整数！）\n改变底层的瞬时时间。当 有一个瞬间被标记了错误的时区，并且需要修复它时使用这个方法。C hange the underlying instant in time. Use this when you have an instant that has been labelled with the incorrect time zone, and you need to fix it.\n\nx4b &lt;- force_tz(x4, tzone = \"Australia/Lord_Howe\")\nx4b\n#&gt; [1] \"2024-06-01 12:00:00 +1030\" \"2024-06-01 12:00:00 +1030\"\n#&gt; [3] \"2024-06-01 12:00:00 +1030\"\nx4b - x4\n#&gt; Time differences in hours\n#&gt; [1] -14.5 -14.5 -14.5",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>日期和时间</span>"
    ]
  },
  {
    "objectID": "datetimes.html#小结",
    "href": "datetimes.html#小结",
    "title": "17  日期和时间",
    "section": "17.6 小结",
    "text": "17.6 小结\n本章介绍了lubridate提供的工具，这些工具可以帮助你处理日期-时间数据。处 理日期和时间可能看起来比必需的要复杂，但希望本章能帮助你明白原因——日期-时间比乍看之下要复杂得多，处理每一种可能的情况都会增加复杂性。即 使您的数据从未跨越夏令时边界或涉及闰年，这些函数也需要能够处理这些情况。\n下一章将总结缺失值。您 已经在几个地方看到了它们，并且在您自己的分析中无疑也遇到了它们，现在是时候提供一系列有用的技术来处理它们了。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>日期和时间</span>"
    ]
  },
  {
    "objectID": "datetimes.html#footnotes",
    "href": "datetimes.html#footnotes",
    "title": "17  日期和时间",
    "section": "",
    "text": "您可能想知道UTC代表什么。它 是英国“协调世界时（Coordinated Universal Time）”和法国“协调世界时（Temps Universel Coordonné）”之间的折衷。↩︎\n猜猜是哪个国家提出了经度系统，这并不难猜。↩︎",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>日期和时间</span>"
    ]
  },
  {
    "objectID": "missing-values.html",
    "href": "missing-values.html",
    "title": "18  缺失值",
    "section": "",
    "text": "18.1 引言\n在本书的早期部分，你已经学习了缺失值的基础知识。你 首先在 章节 1 遇到了它们，这些缺失值在作图时会导致警告，也在 小节 3.5.2 干扰了计算汇总统计量。在 小节 12.2.2 ，你了解了它们的“传染性”以及如何检查它们的存在。现 在我们将更深入地讨论它们，以便你可以了解更多细节。\n首先，我们将讨论一些用于处理记录为NAs的缺失值的通用工具。然 后，探讨隐式缺失值的概念，即那些在数据中完全缺失的值，并展示一些可以用来使它们变成显式的工具。最 后，讨论由不在数据中出现的因子水平引起的空组的相关问题。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>缺失值</span>"
    ]
  },
  {
    "objectID": "missing-values.html#引言",
    "href": "missing-values.html#引言",
    "title": "18  缺失值",
    "section": "",
    "text": "18.1.1 必要条件\n处理缺失数据的函数主要来自 dplyr 和 tidyr，这两个库是 tidyverse 的核心成员。\n\nlibrary(tidyverse)",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>缺失值</span>"
    ]
  },
  {
    "objectID": "missing-values.html#显式缺失值",
    "href": "missing-values.html#显式缺失值",
    "title": "18  缺失值",
    "section": "18.2 显式缺失值",
    "text": "18.2 显式缺失值\n首先，让我们来探索一些用于创建或消除显式缺失值（即你看到 NA 的单元格）的实用工具。\n\n18.2.1 末次观测值结转（LOCF）\n缺失值的一个常见用途是作为一种数据输入的便利方式。当 数据是手动输入时，缺失值有时表示前一行的值被重复（或结转）：\n\ntreatment &lt;- tribble(\n  ~person,           ~treatment, ~response,\n  \"Derrick Whitmore\", 1,         7,\n  NA,                 2,         10,\n  NA,                 3,         NA,\n  \"Katherine Burke\",  1,         4\n)\n\n你可以使用tidyr::fill()来填充这些缺失值。它 的工作方式与select()类似，接受一组列作为参数：\n\ntreatment |&gt;\n  fill(everything())\n#&gt; # A tibble: 4 × 3\n#&gt;   person           treatment response\n#&gt;   &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 Derrick Whitmore         1        7\n#&gt; 2 Derrick Whitmore         2       10\n#&gt; 3 Derrick Whitmore         3       10\n#&gt; 4 Katherine Burke          1        4\n\n这种处理方法有时被称为“末次观测值结转 (last observation carried forward) ”，简称 locf。你 可以使用 .direction 参数来填充以更特殊方式生成的缺失值。\n\n\n18.2.2 固定值\n有时，缺失值代表某个固定且已知的值，最常见的是0。你 可以使用dplyr::coalesce()函数来替换它们：\n\nx &lt;- c(1, 4, 5, 7, NA)\ncoalesce(x, 0)\n#&gt; [1] 1 4 5 7 0\n\n有时你会遇到相反的问题，即某个具体的值实际上代表了一个缺失值。这 通常出现在由较旧软件生成的数据中，这些软件没有正确表示缺失值的方式，因此它们必须使用一些特殊的值，如99或-999来代替。\n如果可能的话，在读取数据时处理这种情况，例如，使用readr::read_csv()函数的na参数，例如read_csv(path, na = \"99\")。如 果你稍后才发现这个问题，或者你的数据源在读取时没有提供处理它的方式，你可以使用dplyr::na_if()函数来处理。\n\nx &lt;- c(1, 4, 5, 7, -99)\nna_if(x, -99)\n#&gt; [1]  1  4  5  7 NA\n\n\n\n18.2.3 NaN\n在我们继续之前，有一种特殊的缺失值类型是你会不时遇到的：NaN (读作“nan”，表示“not a number”) 。了 解它并不那么重要，因为它通常的行为与NA相同：\n\nx &lt;- c(NA, NaN)\nx * 10\n#&gt; [1]  NA NaN\nx == 1\n#&gt; [1] NA NA\nis.na(x)\n#&gt; [1] TRUE TRUE\n\n在极少数情况下，如果你需要区分NA和NaN，你可以使用is.nan(x)函数。\n当你执行具有不确定结果的数学运算时，通常会遇到NaN：\n\n0 / 0 \n#&gt; [1] NaN\n0 * Inf\n#&gt; [1] NaN\nInf - Inf\n#&gt; [1] NaN\nsqrt(-1)\n#&gt; Warning in sqrt(-1): NaNs produced\n#&gt; [1] NaN",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>缺失值</span>"
    ]
  },
  {
    "objectID": "missing-values.html#sec-missing-implicit",
    "href": "missing-values.html#sec-missing-implicit",
    "title": "18  缺失值",
    "section": "18.3 隐式缺失值",
    "text": "18.3 隐式缺失值\n到目前为止，我们谈论的缺失值都是显式缺失的，即你可以在数据中看到NA。但 是，如果整行数据完全缺失，那么缺失值也可以是隐式的。让 我们用一个简单的数据集来说明这种区别，该数据集记录了某些股票每个季度的价格：\n\nstocks &lt;- tibble(\n  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),\n  qtr   = c(   1,    2,    3,    4,    2,    3,    4),\n  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)\n)\n\n这个数据集有两个缺失的观测值：\n\n2020年第四季度的price是显式缺失的，因为它的值是NA；\n2021年第一季度的price是隐式缺失的，因为它在数据集中根本没有出现。\n\n理解这种区别的一种方式是借助这个类似禅宗的公案：\n\n显式的缺失值是缺失的存在。\n隐式的缺失值是存在的缺失。\n\n有时你想将隐式缺失变为显式缺失，以便有具体的东西可以处理。在 其他情况下，由于数据的结构，显式缺失是强加于你的，你希望消除它们。以 下部分将讨论一些在隐式和显式缺失之间转换的工具。\n\n18.3.1 重塑 (Pivoting)\n你已经见过一个工具可以将隐式缺失变为显式缺失，反之亦然：即重塑。将 数据变宽可以使隐式缺失值变为显式缺失值，因为行和新列的每个组合都必须具有某个值。例 如，如果我们透视stocks数据，将quarter放入列中，那么两个缺失值都会变为显式缺失值：\n\nstocks |&gt;\n  pivot_wider(\n    names_from = qtr, \n    values_from = price\n  )\n#&gt; # A tibble: 2 × 5\n#&gt;    year   `1`   `2`   `3`   `4`\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  2020  1.88  0.59  0.35 NA   \n#&gt; 2  2021 NA     0.92  0.17  2.66\n\n默认情况下，将数据变长会保留显式缺失值，但是如果它们是由于数据不整齐而存在的结构性缺失值，你可以通过设置values_drop_na = TRUE来删除它们（使它们变为隐式）。更 多细节请参见 小节 5.2 中的示例。\n\n\n18.3.2 完整(Complete)\ntidyr::complete()允许你通过提供一组变量来生成显式缺失值，这些变量定义了应该存在的行的组合。例 如，我们知道在stocks数据中应该存在year和qtr的所有组合：\n\nstocks |&gt;\n  complete(year, qtr)\n#&gt; # A tibble: 8 × 3\n#&gt;    year   qtr price\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  2020     1  1.88\n#&gt; 2  2020     2  0.59\n#&gt; 3  2020     3  0.35\n#&gt; 4  2020     4 NA   \n#&gt; 5  2021     1 NA   \n#&gt; 6  2021     2  0.92\n#&gt; # ℹ 2 more rows\n\n通常，你会使用现有变量的名称来调用complete()函数，以填充缺失的组合。然 而，有时单个变量本身也是不完整的，因此你可以提供自己的数据。例 如，你可能知道stocks 数据集应该从2019年到2021年，所以你可以为year明确提供这些值：\n\nstocks |&gt;\n  complete(year = 2019:2021, qtr)\n#&gt; # A tibble: 12 × 3\n#&gt;    year   qtr price\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  2019     1 NA   \n#&gt; 2  2019     2 NA   \n#&gt; 3  2019     3 NA   \n#&gt; 4  2019     4 NA   \n#&gt; 5  2020     1  1.88\n#&gt; 6  2020     2  0.59\n#&gt; # ℹ 6 more rows\n\n如果变量的范围是正确的，但不是所有值都存在，你可以使用full_seq(x, 1)来生成从min(x)到max(x)之间间隔为1的所有值。\n在某些情况下，完整的观测集不能仅通过变量的简单组合来生成。在 这种情况下，你可以手动执行complete()为你所做的操作：创建一个包含所有应该存在的行的数据框（使用你需要的任何方法组合），然后使用dplyr::full_join()将其与你的原始数据集结合起来。\n\n\n18.3.3 连接 (Joins)\n这让我们引出了另一种揭示隐式缺失观测值的重要方法：连接。你 将在 章节 19 学习更多关于连接的内容，但我们想在这里快速向你提及它们，因为通常只有当你将一个数据集与另一个数据集进行比较时，你才能知道某个数据集中缺失了哪些值。\ndplyr::anti_join(x, y)在这里是一个特别有用的工具，因为它只选择那些在x中但在y中没有匹配的行。例 如，我们可以使用两次anti_join()来揭示flights中提到的四个机场和722架飞机的信息缺失了：\n\nlibrary(nycflights13)\n\nflights |&gt; \n  distinct(faa = dest) |&gt; \n  anti_join(airports)\n#&gt; Joining with `by = join_by(faa)`\n#&gt; # A tibble: 4 × 1\n#&gt;   faa  \n#&gt;   &lt;chr&gt;\n#&gt; 1 BQN  \n#&gt; 2 SJU  \n#&gt; 3 STT  \n#&gt; 4 PSE\n\nflights |&gt; \n  distinct(tailnum) |&gt; \n  anti_join(planes)\n#&gt; Joining with `by = join_by(tailnum)`\n#&gt; # A tibble: 722 × 1\n#&gt;   tailnum\n#&gt;   &lt;chr&gt;  \n#&gt; 1 N3ALAA \n#&gt; 2 N3DUAA \n#&gt; 3 N542MQ \n#&gt; 4 N730MQ \n#&gt; 5 N9EAMQ \n#&gt; 6 N532UA \n#&gt; # ℹ 716 more rows\n\n\n\n18.3.4 练习\n\n你能找到承运人和planes上缺失的行之间的关系吗？",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>缺失值</span>"
    ]
  },
  {
    "objectID": "missing-values.html#因子和空组",
    "href": "missing-values.html#因子和空组",
    "title": "18  缺失值",
    "section": "18.4 因子和空组",
    "text": "18.4 因子和空组\n缺失数据的最后一种类型是空组 (empty group)，即不包含任何观测值的组，这在处理因子时可能会出现。例 如，假设我们有一个数据集，其中包含了一些关于人的健康信息：\n\nhealth &lt;- tibble(\n  name   = c(\"Ikaia\", \"Oletta\", \"Leriah\", \"Dashay\", \"Tresaun\"),\n  smoker = factor(c(\"no\", \"no\", \"no\", \"no\", \"no\"), levels = c(\"yes\", \"no\")),\n  age    = c(34, 88, 75, 47, 56),\n)\n\n我们想使用dplyr::count()来计算吸烟者的数量：\n\nhealth |&gt; count(smoker)\n#&gt; # A tibble: 1 × 2\n#&gt;   smoker     n\n#&gt;   &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 no         5\n\n这个数据集只包含了非吸烟者，但我们知道吸烟者是存在的，吸烟者这一组是空的。我 们可以通过设置.drop = FALSE来请求count()保留所有组，即使这些组在数据中不存在：\n\nhealth |&gt; count(smoker, .drop = FALSE)\n#&gt; # A tibble: 2 × 2\n#&gt;   smoker     n\n#&gt;   &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 yes        0\n#&gt; 2 no         5\n\n同样的原理也适用于ggplot2的离散轴，它们也会丢弃没有任何值的水平。你 可以通过将drop = FALSE参数传递给适当的离散轴来强制它们显示：\nggplot(health, aes(x = smoker)) +\n  geom_bar() +\n  scale_x_discrete()\n\nggplot(health, aes(x = smoker)) +\n  geom_bar() +\n  scale_x_discrete(drop = FALSE)\n\n\n\n\n\n\n\n\n\n\n同样的问题也会在使用dplyr::group_by()时经常出现。同 样地，你可以使用.drop = FALSE来保留所有的因子水平：\n\nhealth |&gt; \n  group_by(smoker, .drop = FALSE) |&gt; \n  summarize(\n    n = n(),\n    mean_age = mean(age),\n    min_age = min(age),\n    max_age = max(age),\n    sd_age = sd(age)\n  )\n#&gt; # A tibble: 2 × 6\n#&gt;   smoker     n mean_age min_age max_age sd_age\n#&gt;   &lt;fct&gt;  &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 yes        0      NaN     Inf    -Inf   NA  \n#&gt; 2 no         5       60      34      88   21.6\n\n我们在这里得到了一些有趣的结果，因为当对空组进行汇总时，汇总函数会应用于长度为0的向量。这 里有一个重要的区别，即长度为0的空向量和每个长度为1的缺失值。\nWe get some interesting results here because when summarizing an empty group, the summary functions are applied to zero-length vectors. There’s an important distinction between empty vectors, which have length 0, and missing values, each of which has length 1.\n\n# A vector containing two missing values\nx1 &lt;- c(NA, NA)\nlength(x1)\n#&gt; [1] 2\n\n# A vector containing nothing\nx2 &lt;- numeric()\nlength(x2)\n#&gt; [1] 0\n\n所有的汇总函数都可以处理长度为0的向量，但它们可能会返回一些乍看之下令人惊讶的结果。在 这里，我们看到mean(age)返回了NaN，因为mean(age) = sum(age)/length(age)，在这里就变成了0/0。m ax()和min()对于空向量返回-Inf和Inf，所以如果你将这些结果与非空的新数据向量结合并重新计算，你会得到新数据的最小值或最大值。\n有时，一个更简单的方法是先进行汇总，然后使用complete()将隐式缺失显式化。\n\nhealth |&gt; \n  group_by(smoker) |&gt; \n  summarize(\n    n = n(),\n    mean_age = mean(age),\n    min_age = min(age),\n    max_age = max(age),\n    sd_age = sd(age)\n  ) |&gt; \n  complete(smoker)\n#&gt; # A tibble: 2 × 6\n#&gt;   smoker     n mean_age min_age max_age sd_age\n#&gt;   &lt;fct&gt;  &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 yes       NA       NA      NA      NA   NA  \n#&gt; 2 no         5       60      34      88   21.6\n\n这种方法的主要缺点是，即使你知道计数应该是零，你也会得到一个NA作为计数结果。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>缺失值</span>"
    ]
  },
  {
    "objectID": "missing-values.html#小结",
    "href": "missing-values.html#小结",
    "title": "18  缺失值",
    "section": "18.5 小结",
    "text": "18.5 小结\n缺失值很奇怪！有 时它们被记录为明确的NA，但其他时候你只能通过它们的缺失来注意到它们。本 章为你提供了一些处理显式缺失值的工具，以及发现隐式缺失值的工具，并讨论了隐式缺失值如何变为显式缺失值的一些方法，反之亦然。\n在下一章中，我们将处理本书这部分的最后一章：连接。这 与之前的章节有所不同，因为我们将讨论一些对整个数据框进行操作的工具，而不是数据框内部的内容。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>缺失值</span>"
    ]
  },
  {
    "objectID": "joins.html",
    "href": "joins.html",
    "title": "19  连接",
    "section": "",
    "text": "19.1 引言\n在数据分析中，很少只涉及单个数据框。通 常你会有多个数据框，并且需要将它们连接在一起来回答你感兴趣的问题。本 章将向你介绍两种重要的连接类型：\n我们将首先讨论键 (keys)，即用于在连接中连接一对数据框的变量。我 们将通过检查nycflights13包中数据集的键来巩固这一理论，然后利用这些知识开始连接数据框。接 下来我们将讨论连接的工作原理，重点关注它们对行的操作。最 后，我们将讨论非等值连接（non-equi joins），这是一种比默认的等值关系更灵活的键匹配方式连接家族。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "joins.html#引言",
    "href": "joins.html#引言",
    "title": "19  连接",
    "section": "",
    "text": "变异连接（Mutating joins），通过匹配另一个数据框中的观测值向一个数据框添加新变量；\n筛选连接（Filtering joins），根据一个数据框中的观测值是否与另一个数据框中的观测值匹配来筛选观测值。\n\n\n\n19.1.1 必要条件\n在本章中，我们将使用来自dplyr的join函数来探索来自nycflights13的五个相关数据集。\n\nlibrary(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "joins.html#键keys",
    "href": "joins.html#键keys",
    "title": "19  连接",
    "section": "19.2 键（Keys）",
    "text": "19.2 键（Keys）\n要理解连接（join）操作，首先需要理解如何通过每个表中的一对键来连接两个表。在 本节中，你将学习两种类型的键，并在nycflights13包的数据集中看到这两种键的示例。你 还将学习如何检查你的键是否有效，以及如果表中缺少键该如何处理。\n\n19.2.1 主键和外键\n每次连接操作都涉及一对键：主键 (primary key) 和外键 (foreign key) 。主 键是一个变量或一组变量，用于唯一标识每个观测。当 需要多个变量时，这个键被称为复合键。例 如，在nycflights13包中：\n\nairlines 记录关于每家航空公司的两项数据：承运人代码和全名。你 可以使用其两个字母的承运人代码来识别航空公司，使carrier (承运人) 成为主键。\n\nairlines\n#&gt; # A tibble: 16 × 2\n#&gt;   carrier name                    \n#&gt;   &lt;chr&gt;   &lt;chr&gt;                   \n#&gt; 1 9E      Endeavor Air Inc.       \n#&gt; 2 AA      American Airlines Inc.  \n#&gt; 3 AS      Alaska Airlines Inc.    \n#&gt; 4 B6      JetBlue Airways         \n#&gt; 5 DL      Delta Air Lines Inc.    \n#&gt; 6 EV      ExpressJet Airlines Inc.\n#&gt; # ℹ 10 more rows\n\nairports 记录了关于每个机场的数据。你 可以通过其三个字母的机场代码来识别每个机场，使faa成为主键。\n\nairports\n#&gt; # A tibble: 1,458 × 8\n#&gt;   faa   name                            lat   lon   alt    tz dst  \n#&gt;   &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1 04G   Lansdowne Airport              41.1 -80.6  1044    -5 A    \n#&gt; 2 06A   Moton Field Municipal Airport  32.5 -85.7   264    -6 A    \n#&gt; 3 06C   Schaumburg Regional            42.0 -88.1   801    -6 A    \n#&gt; 4 06N   Randall Airport                41.4 -74.4   523    -5 A    \n#&gt; 5 09J   Jekyll Island Airport          31.1 -81.4    11    -5 A    \n#&gt; 6 0A9   Elizabethton Municipal Airpo…  36.4 -82.2  1593    -5 A    \n#&gt; # ℹ 1,452 more rows\n#&gt; # ℹ 1 more variable: tzone &lt;chr&gt;\n\nplanes 记录关于每架飞机的数据。你 可以通过其尾号来识别一架飞机，使tailnum成为主键。\n\nplanes\n#&gt; # A tibble: 3,322 × 9\n#&gt;   tailnum  year type              manufacturer    model     engines\n#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;             &lt;chr&gt;           &lt;chr&gt;       &lt;int&gt;\n#&gt; 1 N10156   2004 Fixed wing multi… EMBRAER         EMB-145XR       2\n#&gt; 2 N102UW   1998 Fixed wing multi… AIRBUS INDUSTR… A320-214        2\n#&gt; 3 N103US   1999 Fixed wing multi… AIRBUS INDUSTR… A320-214        2\n#&gt; 4 N104UW   1999 Fixed wing multi… AIRBUS INDUSTR… A320-214        2\n#&gt; 5 N10575   2002 Fixed wing multi… EMBRAER         EMB-145LR       2\n#&gt; 6 N105UW   1999 Fixed wing multi… AIRBUS INDUSTR… A320-214        2\n#&gt; # ℹ 3,316 more rows\n#&gt; # ℹ 3 more variables: seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt;\n\nweather 记录关于出发机场的天气数据。你 可以通过位置和时间的组合来识别每个观测，使origin和time_hour成为复合主键。\n\nweather\n#&gt; # A tibble: 26,115 × 15\n#&gt;   origin  year month   day  hour  temp  dewp humid wind_dir\n#&gt;   &lt;chr&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 EWR     2013     1     1     1  39.0  26.1  59.4      270\n#&gt; 2 EWR     2013     1     1     2  39.0  27.0  61.6      250\n#&gt; 3 EWR     2013     1     1     3  39.0  28.0  64.4      240\n#&gt; 4 EWR     2013     1     1     4  39.9  28.0  62.2      250\n#&gt; 5 EWR     2013     1     1     5  39.0  28.0  64.4      260\n#&gt; 6 EWR     2013     1     1     6  37.9  28.0  67.2      240\n#&gt; # ℹ 26,109 more rows\n#&gt; # ℹ 6 more variables: wind_speed &lt;dbl&gt;, wind_gust &lt;dbl&gt;, …\n\n\n外键是一个变量（或变量集），它对应于另一个表中的主键。例 如：\n\nflights$tailnum 是一个外键，它对应于主键 planes$tailnum.\nflights$carrier 是一个外键，它对应于主键 airlines$carrier.\nflights$origin 是一个外键，它对应于主键 airports$faa.\nflights$dest 是一个外键，它对应于主键 airports$faa.\nflights$origin-flights$time_hour 是一个复合外键，它对应于复合主键 weather$origin-weather$time_hour.\n\n这些关系在 图 19.1 中以图形方式进行了总结。\n\n\n\n\n\n\n\n\n图 19.1: Connections between all five data frames in the nycflights13 package. Variables making up a primary key are colored grey, and are connected to their corresponding foreign keys with arrows.\n\n\n\n\n\n你会注意到这些键的设计中的一个很好的特征：主键和外键几乎总是具有相同的名称，正如你很快就会看到的，这将使你的连接操作变得更加容易。同 样值得注意的是相反的关系：在多个表中使用的几乎每个变量名在每个位置都有相同的含义。只 有一个例外：在flights表中year表示出发年份，而在planes表中，year表示制造年份。当 我们开始实际将表连接在一起时，这一点将变得很重要。\n\n\n19.2.2 检查主键\n既然我们已经确定了每个表的主键，那么验证它们确实能唯一地标识每个观测是明智的做法。一 种方法是count()主键的数量，并查找n大于 1 的条目。结 果表明planes和weather两个表都没有问题：\n\nplanes |&gt; \n  count(tailnum) |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 0 × 2\n#&gt; # ℹ 2 variables: tailnum &lt;chr&gt;, n &lt;int&gt;\n\nweather |&gt; \n  count(time_hour, origin) |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 0 × 3\n#&gt; # ℹ 3 variables: time_hour &lt;dttm&gt;, origin &lt;chr&gt;, n &lt;int&gt;\n\n你也应该检查主键中是否有缺失值：如果某个值缺失了，那么它就无法标识一个观测！\n\nplanes |&gt; \n  filter(is.na(tailnum))\n#&gt; # A tibble: 0 × 9\n#&gt; # ℹ 9 variables: tailnum &lt;chr&gt;, year &lt;int&gt;, type &lt;chr&gt;, manufacturer &lt;chr&gt;,\n#&gt; #   model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt;\n\nweather |&gt; \n  filter(is.na(time_hour) | is.na(origin))\n#&gt; # A tibble: 0 × 15\n#&gt; # ℹ 15 variables: origin &lt;chr&gt;, year &lt;int&gt;, month &lt;int&gt;, day &lt;int&gt;,\n#&gt; #   hour &lt;int&gt;, temp &lt;dbl&gt;, dewp &lt;dbl&gt;, humid &lt;dbl&gt;, wind_dir &lt;dbl&gt;, …\n\n\n\n19.2.3 代理键 (Surrogate keys)\n到目前为止，我们还没有谈到flights的主键。在 这里它不是特别重要，因为没有数据框使用它作为外键；但考虑它仍然是有用的，因为如果我们有某种方式可以向其他人描述观测，那么处理这些观测会更加容易。\n经过一些思考和尝试，我们确定有三个变量一起能够唯一地标识每次航班：\n\nflights |&gt; \n  count(time_hour, carrier, flight) |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 0 × 4\n#&gt; # ℹ 4 variables: time_hour &lt;dttm&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, n &lt;int&gt;\n\n缺少重复项是否自动使time_hour-carrier-flight成为主键？当 然这是一个好的开始，但并不能保证成功。例 如，海拔和纬度是否适合作为airports的主键？\n\nairports |&gt;\n  count(alt, lat) |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 1 × 3\n#&gt;     alt   lat     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1    13  40.6     2\n\n仅通过海拔和纬度来识别机场显然是一个糟糕的主意，而且通常仅凭数据本身是无法知道变量组合是否可以成为一个好的主键的。但 是对于航班来说，time_hour、carrier和flight的组合看起来是合理的，因为如果同时有多个航班在空中使用相同的航班号，对于航空公司和其客户来说会非常混乱的。\n不过，我们最好使用行号来引入一个简单的数字代理键：\n\nflights2 &lt;- flights |&gt; \n  mutate(id = row_number(), .before = 1)\nflights2\n#&gt; # A tibble: 336,776 × 20\n#&gt;      id  year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1     1  2013     1     1      517            515         2      830\n#&gt; 2     2  2013     1     1      533            529         4      850\n#&gt; 3     3  2013     1     1      542            540         2      923\n#&gt; 4     4  2013     1     1      544            545        -1     1004\n#&gt; 5     5  2013     1     1      554            600        -6      812\n#&gt; 6     6  2013     1     1      554            558        -4      740\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, …\n\n代理键在与他人交流时特别有用：告诉某人查看航班2001比告诉某人查看2013年1月3日上午9点起飞的UA430航班要容易得多。\n\n\n19.2.4 练习\n\n在 图 19.1 中，我们忘记了画出weather 和airports之间的关系。这 种关系是什么？它 应该如何出现在图中？\nweather 数据只包含纽约市三个出发机场的信息。如 果它包含了美国所有机场的天气记录，那么它会与flights产生什么样的额外关联？\nyear, month, day, hour, 和 origin 几乎构成了天气的复合键，但是有一个小时有重复的观察记录。你 能找出那个小时有什么特别之处吗？\n我们知道一年中的某些天是特殊的，通常会比平时少人乘坐飞机（例如，平安夜和圣诞节）。你 如何将这些数据表示为数据框？主 键会是什么？它 将如何与现有的数据框连接？\n画一个图，说明Lahman包中Batting、People和Salaries数据框之间的连接关系。再 画一个图，显示People、Managers和AwardsManagers之间的关系。你 会如何描述Batting、Pitching和Fielding数据框之间的关系？",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "joins.html#sec-mutating-joins",
    "href": "joins.html#sec-mutating-joins",
    "title": "19  连接",
    "section": "19.3 基本连接",
    "text": "19.3 基本连接\n既然你已经理解了如何通过键来连接数据框，现在就可以开始使用连接来更好地理解flights数据集了。d plyr提供了六种连接函数：left_join()、inner_join()、right_join()、full_join()、semi_join()和anti_join()。这 些函数都具有相同的接口：它们接受一对数据框（x和y）并返回一个数据框。输 出中行和列的顺序主要由x决定。\n在本节中，你将学习如何使用一个变异连接left_join()和两个筛选连接semi_join()和anti_join()。在 下一节中，你将详细了解这些函数是如何工作的，包括剩下的inner_join()、right_join()和full_join()。\n\n19.3.1 变异连接\n变异连接允许你将两个数据框中的变量组合起来：它首先通过键来匹配观测值，然后将一个数据框中的变量复制到另一个数据框中。与 mutate()函数类似，连接函数将变量添加到右侧，因此如果你的数据集有很多变量，你可能不会立即看到新添加的变量。为 了这些示例，我们将通过创建一个仅包含六个变量的较窄数据集来更容易地查看发生了什么1：\n\nflights2 &lt;- flights |&gt; \n  select(year, time_hour, origin, dest, tailnum, carrier)\nflights2\n#&gt; # A tibble: 336,776 × 6\n#&gt;    year time_hour           origin dest  tailnum carrier\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA     \n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA     \n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA     \n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6     \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL     \n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA     \n#&gt; # ℹ 336,770 more rows\n\n变异连接有四种类型，但有一种你几乎总是会用到：left_join()。它 很特别，因为输出总是与x（你正在连接的数据框）有相同的行2。 left_join()的主要用途是添加额外的元数据。 例如，我们可以使用left_join()向flights2数据中添加完整的航空公司名称：\n\nflights2 |&gt;\n  left_join(airlines)\n#&gt; Joining with `by = join_by(carrier)`\n#&gt; # A tibble: 336,776 × 7\n#&gt;    year time_hour           origin dest  tailnum carrier name                \n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;               \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      United Air Lines In…\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      United Air Lines In…\n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      American Airlines I…\n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      JetBlue Airways     \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Delta Air Lines Inc.\n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      United Air Lines In…\n#&gt; # ℹ 336,770 more rows\n\n或者我们可以查找每架飞机起飞时的温度和风速：\n\nflights2 |&gt; \n  left_join(weather |&gt; select(origin, time_hour, temp, wind_speed))\n#&gt; Joining with `by = join_by(time_hour, origin)`\n#&gt; # A tibble: 336,776 × 8\n#&gt;    year time_hour           origin dest  tailnum carrier  temp wind_speed\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA       39.0       12.7\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA       39.9       15.0\n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA       39.0       15.0\n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6       39.0       15.0\n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL       39.9       16.1\n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA       39.0       12.7\n#&gt; # ℹ 336,770 more rows\n\n或者查看当时飞行的是哪种大小的飞机：\n\nflights2 |&gt; \n  left_join(planes |&gt; select(tailnum, type, engines, seats))\n#&gt; Joining with `by = join_by(tailnum)`\n#&gt; # A tibble: 336,776 × 9\n#&gt;    year time_hour           origin dest  tailnum carrier type                \n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;               \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Fixed wing multi en…\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      Fixed wing multi en…\n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Fixed wing multi en…\n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      Fixed wing multi en…\n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Fixed wing multi en…\n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Fixed wing multi en…\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 2 more variables: engines &lt;int&gt;, seats &lt;int&gt;\n\n当left_join()找不到与x中某行相匹配的记录时，它会用缺失值来填充新的变量。例 如，没有关于尾号为N3ALAA的飞机的信息，因此其type、engines和seats将是缺失的：\n\nflights2 |&gt; \n  filter(tailnum == \"N3ALAA\") |&gt; \n  left_join(planes |&gt; select(tailnum, type, engines, seats))\n#&gt; Joining with `by = join_by(tailnum)`\n#&gt; # A tibble: 63 × 9\n#&gt;    year time_hour           origin dest  tailnum carrier type  engines seats\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt; &lt;int&gt;\n#&gt; 1  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 2  2013 2013-01-02 18:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 3  2013 2013-01-03 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 4  2013 2013-01-07 19:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 5  2013 2013-01-08 17:00:00 JFK    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 6  2013 2013-01-16 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; # ℹ 57 more rows\n\n在本章剩下的部分，我们还会多次回到这个问题。\n\n\n19.3.2 指定连接键\n默认情况下，left_join()会使用两个数据框中都出现的所有变量作为连接键，这被称为自然连接 (natural join)。这 是一个有用的启发式方法，但并不总是有效。例 如，如果我们尝试将flights2与完整的planes数据集连接，会发生什么呢？\n\nflights2 |&gt; \n  left_join(planes)\n#&gt; Joining with `by = join_by(year, tailnum)`\n#&gt; # A tibble: 336,776 × 13\n#&gt;    year time_hour           origin dest  tailnum carrier type  manufacturer\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;       \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 5 more variables: model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, …\n\n我们得到了很多缺失的匹配项，因为连接试图使用tailnum和year作为复合键。f lights和planes都有一个year列，但它们表示的是不同的含义：flights$year是航班发生的年份，而planes$year是飞机制造的年份。我 们只想通过tailnum进行连接，因此我们需要使用join_by()来提供一个明确的规范。\n\nflights2 |&gt; \n  left_join(planes, join_by(tailnum))\n#&gt; # A tibble: 336,776 × 14\n#&gt;   year.x time_hour           origin dest  tailnum carrier year.y\n#&gt;    &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;    &lt;int&gt;\n#&gt; 1   2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA        1999\n#&gt; 2   2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA        1998\n#&gt; 3   2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA        1990\n#&gt; 4   2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6        2012\n#&gt; 5   2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL        1991\n#&gt; 6   2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA        2012\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 7 more variables: type &lt;chr&gt;, manufacturer &lt;chr&gt;, model &lt;chr&gt;, …\n\n请注意，在输出中year变量通过后缀（year.x 和 year.y）来区分，以告诉你该变量来自x还是y参数。你 可以使用suffix参数来覆盖默认后缀。\njoin_by(tailnum)是join_by(tailnum == tailnum)的简写。了 解这种完整形式很重要，原因有两个：首先，它描述了两个表之间的关系：键必须相等。这 就是为什么这种连接类型通常被称为等值连接 (equi join)。你 将在@sec-non-equi-joins 学习非等值连接。\n其次，这是你在每个表中指定不同连接键的方式。例 如，有两种方式可以将flight2和airports表连接起来：通过dest或origin。\n\nflights2 |&gt; \n  left_join(airports, join_by(dest == faa))\n#&gt; # A tibble: 336,776 × 13\n#&gt;    year time_hour           origin dest  tailnum carrier name                \n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;               \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      George Bush Interco…\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      George Bush Interco…\n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Miami Intl          \n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      &lt;NA&gt;                \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Hartsfield Jackson …\n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Chicago Ohare Intl  \n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 6 more variables: lat &lt;dbl&gt;, lon &lt;dbl&gt;, alt &lt;dbl&gt;, tz &lt;dbl&gt;, …\n\nflights2 |&gt; \n  left_join(airports, join_by(origin == faa))\n#&gt; # A tibble: 336,776 × 13\n#&gt;    year time_hour           origin dest  tailnum carrier name               \n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;              \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Newark Liberty Intl\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      La Guardia         \n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      John F Kennedy Intl\n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      John F Kennedy Intl\n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      La Guardia         \n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Newark Liberty Intl\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 6 more variables: lat &lt;dbl&gt;, lon &lt;dbl&gt;, alt &lt;dbl&gt;, tz &lt;dbl&gt;, …\n\n在旧代码中，你可能会看到使用字符向量来指定连接键的不同方式：\n\nby = \"x\"对应于join_by(x)。\nby = c(\"a\" = \"x\")对应于join_by(a == x)。\n\n既然现在有了join_by()，我们更倾向于使用它，因为它提供了更清晰且更灵活的规范。\ninner_join()、right_join()、full_join()与left_join()的接口相同。它 们之间的区别在于保留哪些行：左连接保留x中的所有行，右连接保留y中的所有行，全连接保留x或y中的所有行，而内连接仅保留在x和y中都出现的行。我 们将在稍后更详细地讨论这些连接类型。\n\n\n19.3.3 筛选连接\n正如你可能猜到的，筛选连接的主要操作是筛选行。有 两种类型：半连接（semi-join）和反连接（anti-join）。半 连接保留x在y中有匹配项的所有行。例 如，我们可以使用半连接来筛选机场数据集，仅显示始发机场：\n\nairports |&gt; \n  semi_join(flights2, join_by(faa == origin))\n#&gt; # A tibble: 3 × 8\n#&gt;   faa   name                  lat   lon   alt    tz dst   tzone           \n#&gt;   &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           \n#&gt; 1 EWR   Newark Liberty Intl  40.7 -74.2    18    -5 A     America/New_York\n#&gt; 2 JFK   John F Kennedy Intl  40.6 -73.8    13    -5 A     America/New_York\n#&gt; 3 LGA   La Guardia           40.8 -73.9    22    -5 A     America/New_York\n\n或者仅仅是目的地:\n\nairports |&gt; \n  semi_join(flights2, join_by(faa == dest))\n#&gt; # A tibble: 101 × 8\n#&gt;   faa   name                     lat    lon   alt    tz dst   tzone          \n#&gt;   &lt;chr&gt; &lt;chr&gt;                  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;          \n#&gt; 1 ABQ   Albuquerque Internati…  35.0 -107.   5355    -7 A     America/Denver \n#&gt; 2 ACK   Nantucket Mem           41.3  -70.1    48    -5 A     America/New_Yo…\n#&gt; 3 ALB   Albany Intl             42.7  -73.8   285    -5 A     America/New_Yo…\n#&gt; 4 ANC   Ted Stevens Anchorage…  61.2 -150.    152    -9 A     America/Anchor…\n#&gt; 5 ATL   Hartsfield Jackson At…  33.6  -84.4  1026    -5 A     America/New_Yo…\n#&gt; 6 AUS   Austin Bergstrom Intl   30.2  -97.7   542    -6 A     America/Chicago\n#&gt; # ℹ 95 more rows\n\n反连接则相反：它们返回x在y中没有匹配项的所有行。它 们在寻找数据中隐式的缺失值方面很有用，这是 小节 18.3 的主题。隐 式的缺失值不会显示为NA，而仅表现为缺失。例 如，我们可以通过查找没有匹配目的地机场的航班来找到airports数据集中缺失的行：\n\nflights2 |&gt; \n  anti_join(airports, join_by(dest == faa)) |&gt; \n  distinct(dest)\n#&gt; # A tibble: 4 × 1\n#&gt;   dest \n#&gt;   &lt;chr&gt;\n#&gt; 1 BQN  \n#&gt; 2 SJU  \n#&gt; 3 STT  \n#&gt; 4 PSE\n\n或者我们可以找出哪些tailnum在planes数据集中缺失：\n\nflights2 |&gt;\n  anti_join(planes, join_by(tailnum)) |&gt; \n  distinct(tailnum)\n#&gt; # A tibble: 722 × 1\n#&gt;   tailnum\n#&gt;   &lt;chr&gt;  \n#&gt; 1 N3ALAA \n#&gt; 2 N3DUAA \n#&gt; 3 N542MQ \n#&gt; 4 N730MQ \n#&gt; 5 N9EAMQ \n#&gt; 6 N532UA \n#&gt; # ℹ 716 more rows\n\n\n\n19.3.4 练习\n\n找出全年中延误最严重的48小时，并与weather数据进行交叉比对。你 能否看到任何模式？\n假设你使用这段代码找到了最受欢迎的10个目的地:\n\ntop_dest &lt;- flights2 |&gt;\n  count(dest, sort = TRUE) |&gt;\n  head(10)\n\n你怎样才能找到去这些目的地的所有航班呢?\n是否每个起飞的航班都有对应的该小时天气数据？\n那些在planes中没有匹配记录的尾号有什么共同之处？( 提示: 一个变量解释了约90%的问题）\n给planes数据框添加一个列，列出飞过该飞机的所有航空公司。你 可能会期望飞机和航空公司之间存在一种隐式关系，因为每架飞机都由单一的航空公司运营。使 用你在前几章中学到的工具来证实或反驳这一假设。\n将起飞机场和目的地机场的纬度和经度添加到flights数据框中。在 连接之前还是之后重命名列更容易？\n按目的地计算平均延误时间，然后与airports数据框进行连接，以便你可以展示延误的空间分布。以 下是一个绘制美国地图的简单方法：\n\nairports |&gt;\n  semi_join(flights, join_by(faa == dest)) |&gt;\n  ggplot(aes(x = lon, y = lat)) +\n    borders(\"state\") +\n    geom_point() +\n    coord_quickmap()\n\n你可能想使用点的大小或颜色来显示每个机场的平均延误时间。\n2013年6月13日发生了什么？画 一张延误地图，然后使用Google与天气进行交叉比对。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "joins.html#连接是如何工作的",
    "href": "joins.html#连接是如何工作的",
    "title": "19  连接",
    "section": "19.4 连接是如何工作的?",
    "text": "19.4 连接是如何工作的?\n既然你已经使用连接操作几次了，现在是时候深入了解它们是如何工作的了，重点关注x中的每一行如何与y中的行进行匹配。我 们将从引入连接的视觉表示开始，使用下面定义的简单tibble，并在 图 19.2 中展示。在 这些例子中，我们将使用名为key的单个键和一个值列（val_x和val_y），但这些想法都可以推广到多个键和多个值。\n\nx &lt;- tribble(\n  ~key, ~val_x,\n     1, \"x1\",\n     2, \"x2\",\n     3, \"x3\"\n)\ny &lt;- tribble(\n  ~key, ~val_y,\n     1, \"y1\",\n     2, \"y2\",\n     4, \"y3\"\n)\n\n\n\n\n\n\n\n\n\n图 19.2: Graphical representation of two simple tables. The colored key columns map background color to key value. The grey columns represent the “value” columns that are carried along for the ride.\n\n\n\n\n\n图 19.3 为我们的视觉表示法奠定了基础。它 展示了x和y之间所有可能的匹配，这些匹配是从x的每一行和y的每一行绘制出的线条的交点。输 出结果中的行和列主要由x决定，因此x表格是水平的，并且与输出结果对齐。\n\n\n\n\n\n\n\n\n图 19.3: To understand how joins work, it’s useful to think of every possible match. Here we show that with a grid of connecting lines.\n\n\n\n\n\n为了描述一种特定的连接类型，我们用点来表示匹配项，这些匹配项决定了输出的行。输 出是一个新的数据框，包含键、x值和y值。例 如，图 19.4 展示了内连接，只有当键相等时，行才会被保留。\n\n\n\n\n\n\n\n\n图 19.4: An inner join matches each row in x to the row in y that has the same value of key. Each match becomes a row in the output.\n\n\n\n\n\n我们可以应用同样的原理来解释外连接 (outer joins)，外连接会保留至少在一个数据框中出现的观测值。这 些连接通过在每个数据框中添加一个额外的“虚拟”观测值来实现。这 个观测值具有一个键，当没有其他键匹配时，它会匹配，并将值填充为NA。有 三种类型的外连接：\n\n左连接保留x中的所有观测值，如 图 19.5 所示。x 的每一行都保留在输出中，因为它可以退回到与y中的NA行进行匹配。\n\n\n\n\n\n\n\n\n图 19.5: A visual representation of the left join where every row in x appears in the output.\n\n\n\n\n\n右连接保留y中的所有观测值，如图 图 19.6 所示。y 的每一行都保留在输出中，因为它可以退回到与x中的NA行进行匹配。输 出仍然尽可能与x进行匹配；y中的任何额外行都会添加到末尾。\n\n\n\n\n\n\n\n\n图 19.6: A visual representation of the right join where every row of y appears in the output.\n\n\n\n\n\n全连接保留出现在x或y中的所有观测值，如图 图 19.7 所示。x 和y的每一行都包含在输出中，因为x和y都有一个回退行为NA。同 样，输出以x的所有行开始，然后是剩余的未匹配的y行。\n\n\n\n\n\n\n\n\n图 19.7: A visual representation of the full join where every row in x and y appears in the output.\n\n\n\n\n\n\n另一种展示不同类型的外连接差异的方法是使用文氏图 (Venn diagram)，如 图 19.8 所示。然 而，这并不是一个很好的表示方法，因为它虽然可能会唤起你对哪些行被保留的记忆，但它无法说明列发生了什么。\n\n\n\n\n\n\n\n\n图 19.8: Venn diagrams showing the difference between inner, left, right, and full joins.\n\n\n\n\n\n这里展示的连接被称为等值连接，即当键相等时行会匹配。等 值连接是最常见的连接类型，因此我们通常会省略equi前缀，只说“内连接”而不是“等值内连接”。我 们将在@sec-non-equi-joins 讨论非等值连接。\n\n19.4.1 行匹配\n到目前为止，我们已经探讨了x中的一行与y中的零行或一行匹配时会发生什么。但 如果它匹配多行时会发生什么呢？为 了理解这一点，让我们首先关注inner_join()函数，然后画一张图，如 图 19.9 所示。\n\n\n\n\n\n\n\n\n图 19.9: The three ways a row in x can match. x1 matches one row in y, x2 matches two rows in y, x3 matches zero rows in y. Note that while there are three rows in x and three rows in the output, there isn’t a direct correspondence between the rows.\n\n\n\n\n\nx中的行有三种可能的结果：\n\n如果它不匹配任何行，它将被删除；\n如果它与y中的一行匹配，它将被保留；\n如果它与y中的多行匹配，它将为每个匹配项复制一次。\n\n原则上，这意味着输出中的行与x中的行之间没有保证的对应关系，但在实践中，这种情况很少会引起问题。然 而，有一种特别危险的情况可能导致行的组合爆炸，想象一下连接以下两个表：\n\ndf1 &lt;- tibble(key = c(1, 2, 2), val_x = c(\"x1\", \"x2\", \"x3\"))\ndf2 &lt;- tibble(key = c(1, 2, 2), val_y = c(\"y1\", \"y2\", \"y3\"))\n\n虽然df1的第一行只与df2中的一行匹配，但第二行和第三行都与两行匹配。这 个有时被称为多对多 (many-to-many) 连接，将会导致dplyr发出警告：\n\ndf1 |&gt; \n  inner_join(df2, join_by(key))\n#&gt; Warning in inner_join(df1, df2, join_by(key)): Detected an unexpected many-to-many relationship between `x` and `y`.\n#&gt; ℹ Row 2 of `x` matches multiple rows in `y`.\n#&gt; ℹ Row 2 of `y` matches multiple rows in `x`.\n#&gt; ℹ If a many-to-many relationship is expected, set `relationship =\n#&gt;   \"many-to-many\"` to silence this warning.\n#&gt; # A tibble: 5 × 3\n#&gt;     key val_x val_y\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1     1 x1    y1   \n#&gt; 2     2 x2    y2   \n#&gt; 3     2 x2    y3   \n#&gt; 4     2 x3    y2   \n#&gt; 5     2 x3    y3\n\n如果你有意这么做，可以按照警告的提示设置 relationship = \"many-to-many\"。\n\n\n19.4.2 筛选连接\n匹配的数量也决定了筛选连接的行为。半 连接保留x在y中有一个或多个匹配的行，如 图 19.10 所示。反 连接保留x在y中零个匹配的行，如 图 19.11 所示。在 这两种情况下，仅匹配的存在是重要的，匹配的次数并不重要。这 意味着筛选连接永远不会像变异连接那样重复行。\n\n\n\n\n\n\n\n\n图 19.10: In a semi-join it only matters that there is a match; otherwise values in y don’t affect the output.\n\n\n\n\n\n\n\n\n\n\n\n\n\n图 19.11: An anti-join is the inverse of a semi-join, dropping rows from x that have a match in y.",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "joins.html#sec-non-equi-joins",
    "href": "joins.html#sec-non-equi-joins",
    "title": "19  连接",
    "section": "19.5 非等值连接",
    "text": "19.5 非等值连接\n到目前为止，你只看到了等连接（equi joins），也就是当x的键等于y的键时行才会匹配。现 在我们放宽这个限制，并讨论确定一对行是否匹配的其他方法。\n但是，在我们这样做之前，我们需要回顾一下上面所做的简化。在 等连接中，x的键和y的键总是相等的，所以我们只需要在输出中显示一个。我 们可以要求dplyr通过keep = TRUE保留两个键，这将导致下面的代码和 图 19.12 中重新绘制的inner_join()。\nSo far you’ve only seen equi joins, joins where the rows match if the x key equals the y key. Now we’re going to relax that restriction and discuss other ways of determining if a pair of rows match.\nBut before we can do that, we need to revisit a simplification we made above. In equi joins the x keys and y are always equal, so we only need to show one in the output. We can request that dplyr keep both keys with keep = TRUE, leading to the code below and the re-drawn inner_join() in 图 19.12.\n\nx |&gt; inner_join(y, join_by(key == key), keep = TRUE)\n#&gt; # A tibble: 2 × 4\n#&gt;   key.x val_x key.y val_y\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1     1 x1        1 y1   \n#&gt; 2     2 x2        2 y2\n\n\n\n\n\n\n\n\n\n图 19.12: An inner join showing both x and y keys in the output.\n\n\n\n\n\n当我们从等值连接转向非等值连接时，我们总是会显示键，因为键值通常会有所不同。例 如，我们不再仅在x$key和y$key相等时才进行匹配，而是可以在x$key大于或等于y$key时进行匹配，如 图 19.13 所示。d plyr的连接函数理解等值连接和非等值连接之间的区别，因此当你执行非等值连接时，它总是会显示两个键。\n\n\n\n\n\n\n\n\n图 19.13: A non-equi join where the x key must be greater than or equal to the y key. Many rows generate multiple matches.\n\n\n\n\n\n“非等值连接”这个术语不是特别有用，因为它只告诉你这个连接不是什么，而不是它是什么。d plyr通过识别四种特别有用的非等值连接类型来帮助你：\n\n交叉连接 (cross joins) 匹配每一对行；\n不等式(inequality joins) 使用 &lt;、&lt;=、&gt; 和 &gt;= 而不是 ==；\n滚动连接 (rolling joins) 类似于不等式连接，但只找到最接近的匹配项；\n重叠连接 (overlap joins) 是一种特殊的不等式连接类型，专为处理范围而设计。\n\n这些类型将在以下部分中更详细地描述。\n\n19.5.1 交叉连接\n交叉连接会匹配所有内容，如 图 19.14 所示，生成行的笛卡尔积。这 意味着输出将具有nrow(x) * nrow(y)行。\n\n\n\n\n\n\n\n\n图 19.14: A cross join matches each row in x with every row in y.\n\n\n\n\n\n交叉连接在生成排列时很有用。例 如下面的代码生成了所有可能的名称对。因 为我们正在将df与其自身连接，所以这有时被称为自连接 (self-join)。交 叉连接使用不同的连接函数，因为在匹配每一行时，没有内连接/左连接/右连接/全连接之间的区别。\n\ndf &lt;- tibble(name = c(\"John\", \"Simon\", \"Tracy\", \"Max\"))\ndf |&gt; cross_join(df)\n#&gt; # A tibble: 16 × 2\n#&gt;   name.x name.y\n#&gt;   &lt;chr&gt;  &lt;chr&gt; \n#&gt; 1 John   John  \n#&gt; 2 John   Simon \n#&gt; 3 John   Tracy \n#&gt; 4 John   Max   \n#&gt; 5 Simon  John  \n#&gt; 6 Simon  Simon \n#&gt; # ℹ 10 more rows\n\n\n\n19.5.2 不等式连接\n不等连接使用 &lt;、&lt;=、&gt; 或 &gt;= 来限制可能匹配的集合，如 图 19.13 和 图 19.15 所示。\n\n\n\n\n\n\n\n\n图 19.15: An inequality join where x is joined to y on rows where the key of x is less than the key of y. This makes a triangular shape in the top-left corner.\n\n\n\n\n\n不等连接非常通用，以至于很难提出有意义的特定用例。一 个有用的小技巧是使用它们来限制交叉连接，以便我们不是生成所有排列，而是生成所有组合：\n\ndf &lt;- tibble(id = 1:4, name = c(\"John\", \"Simon\", \"Tracy\", \"Max\"))\n\ndf |&gt; inner_join(df, join_by(id &lt; id))\n#&gt; # A tibble: 6 × 4\n#&gt;    id.x name.x  id.y name.y\n#&gt;   &lt;int&gt; &lt;chr&gt;  &lt;int&gt; &lt;chr&gt; \n#&gt; 1     1 John       2 Simon \n#&gt; 2     1 John       3 Tracy \n#&gt; 3     1 John       4 Max   \n#&gt; 4     2 Simon      3 Tracy \n#&gt; 5     2 Simon      4 Max   \n#&gt; 6     3 Tracy      4 Max\n\n\n\n19.5.3 滚动连接\n滚动连接是一种特殊的不等式连接，其中不是获取满足不等式的每一行，而是仅获取最接近的行，如 图 19.16 所示。你 可以通过将closest()添加到不等连接中来将其转换为滚动连接。例 如join_by(closest(x &lt;= y))将匹配大于或等于x的最小的y，而join_by(closest(x &gt; y))将匹配小于x的最大的y。\n\n\n\n\n\n\n\n\n图 19.16: A rolling join is similar to a greater-than-or-equal inequality join but only matches the first value.\n\n\n\n\n\n滚动连接在以下场景特别有用：假如你有两个日期表，但日期并不完全对应；你想要在表1中找到与表2中某个日期最接近的日期 (之前或之后)。\n例如，假设你负责你们办公室的派对策划委员会。由 于公司比较节俭，不是举办单独的派对，而是每个季度只举办一次。确 定派对日期的规则有些复杂：派对总是在星期一举行，而且你跳过了1月的第一周，因为很多人都在休假。此 外，2022年第三季度的第一个星期一是7月4日，所以派对必须推迟一周。基 于这些规则，以下是确定的派对日期：\n\nparties &lt;- tibble(\n  q = 1:4,\n  party = ymd(c(\"2022-01-10\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\"))\n)\n\n现在，假设你有一张员工生日的表格：\n\nset.seed(123)\nemployees &lt;- tibble(\n  name = sample(babynames::babynames$name, 100),\n  birthday = ymd(\"2022-01-01\") + (sample(365, 100, replace = TRUE) - 1)\n)\nemployees\n#&gt; # A tibble: 100 × 2\n#&gt;   name     birthday  \n#&gt;   &lt;chr&gt;    &lt;date&gt;    \n#&gt; 1 Kemba    2022-01-22\n#&gt; 2 Orean    2022-06-26\n#&gt; 3 Kirstyn  2022-02-11\n#&gt; 4 Amparo   2022-11-11\n#&gt; 5 Belen    2022-03-25\n#&gt; 6 Rayshaun 2022-01-11\n#&gt; # ℹ 94 more rows\n\n对于每个员工，我们都想找到在他们生日之后（或当天）的第一个派对日期。我 们可以用滚动连接来表示这一点：\n\nemployees |&gt; \n  left_join(parties, join_by(closest(birthday &gt;= party)))\n#&gt; # A tibble: 100 × 4\n#&gt;   name     birthday       q party     \n#&gt;   &lt;chr&gt;    &lt;date&gt;     &lt;int&gt; &lt;date&gt;    \n#&gt; 1 Kemba    2022-01-22     1 2022-01-10\n#&gt; 2 Orean    2022-06-26     2 2022-04-04\n#&gt; 3 Kirstyn  2022-02-11     1 2022-01-10\n#&gt; 4 Amparo   2022-11-11     4 2022-10-03\n#&gt; 5 Belen    2022-03-25     1 2022-01-10\n#&gt; 6 Rayshaun 2022-01-11     1 2022-01-10\n#&gt; # ℹ 94 more rows\n\n然而，这种方法存在一个问题：在1月10日之前过生日的人没有派对：\n\nemployees |&gt; \n  anti_join(parties, join_by(closest(birthday &gt;= party)))\n#&gt; # A tibble: 2 × 2\n#&gt;   name   birthday  \n#&gt;   &lt;chr&gt;  &lt;date&gt;    \n#&gt; 1 Maks   2022-01-07\n#&gt; 2 Nalani 2022-01-04\n\n为了解决这个问题，我们需要以不同的方式处理它，即使用重叠连接。\n\n\n19.5.4 重叠连接\n重叠连接提供了三个辅助函数，这些函数使用不等式连接来简化区间操作：\n\nbetween(x, y_lower, y_upper) 是 x &gt;= y_lower, x &lt;= y_upper的简写；\nwithin(x_lower, x_upper, y_lower, y_upper) 是 x_lower &gt;= y_lower, x_upper &lt;= y_upper的简写；\noverlaps(x_lower, x_upper, y_lower, y_upper) 是 x_lower &lt;= y_upper, x_upper &gt;= y_lower的简写。\n\n让我们继续生日的例子，看看如何使用这些函数。我 们之前使用的策略有一个问题：1月1日到9日之间过生日的人没有派对。因 此，明确每个派对涵盖的日期范围，并为这些早过生日的人设置一个特殊情况可能会更好：\n\nparties &lt;- tibble(\n  q = 1:4,\n  party = ymd(c(\"2022-01-10\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  start = ymd(c(\"2022-01-01\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  end = ymd(c(\"2022-04-03\", \"2022-07-11\", \"2022-10-02\", \"2022-12-31\"))\n)\nparties\n#&gt; # A tibble: 4 × 4\n#&gt;       q party      start      end       \n#&gt;   &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    \n#&gt; 1     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; 2     2 2022-04-04 2022-04-04 2022-07-11\n#&gt; 3     3 2022-07-11 2022-07-11 2022-10-02\n#&gt; 4     4 2022-10-03 2022-10-03 2022-12-31\n\nHadley 在数据录入方面糟糕透顶，因此他还想检查派对时间段是否重叠。一 种方法是通过自连接来检查是否有任何开始-结束区间与其他区间重叠：\n\nparties |&gt; \n  inner_join(parties, join_by(overlaps(start, end, start, end), q &lt; q)) |&gt; \n  select(start.x, end.x, start.y, end.y)\n#&gt; # A tibble: 1 × 4\n#&gt;   start.x    end.x      start.y    end.y     \n#&gt;   &lt;date&gt;     &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    \n#&gt; 1 2022-04-04 2022-07-11 2022-07-11 2022-10-02\n\n哎呀，有重叠的区间，让我们修复这个问题并继续：\n\nparties &lt;- tibble(\n  q = 1:4,\n  party = ymd(c(\"2022-01-10\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  start = ymd(c(\"2022-01-01\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  end = ymd(c(\"2022-04-03\", \"2022-07-10\", \"2022-10-02\", \"2022-12-31\"))\n)\n\n现在我们可以将每个员工与他们的派对匹配起来。这 里非常适合使用unmatched = \"error\"选项，因为我们想快速找出是否有员工没有被分配到派对。\n\nemployees |&gt; \n  inner_join(parties, join_by(between(birthday, start, end)), unmatched = \"error\")\n#&gt; # A tibble: 100 × 6\n#&gt;   name     birthday       q party      start      end       \n#&gt;   &lt;chr&gt;    &lt;date&gt;     &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    \n#&gt; 1 Kemba    2022-01-22     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; 2 Orean    2022-06-26     2 2022-04-04 2022-04-04 2022-07-10\n#&gt; 3 Kirstyn  2022-02-11     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; 4 Amparo   2022-11-11     4 2022-10-03 2022-10-03 2022-12-31\n#&gt; 5 Belen    2022-03-25     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; 6 Rayshaun 2022-01-11     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; # ℹ 94 more rows\n\n\n\n19.5.5 练习\n\n你能解释下面等值连接的键是如何工作的吗？它 们的结果为什么是不同的？\n\nx |&gt; full_join(y, join_by(key == key))\n#&gt; # A tibble: 4 × 3\n#&gt;     key val_x val_y\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1     1 x1    y1   \n#&gt; 2     2 x2    y2   \n#&gt; 3     3 x3    &lt;NA&gt; \n#&gt; 4     4 &lt;NA&gt;  y3\n\nx |&gt; full_join(y, join_by(key == key), keep = TRUE)\n#&gt; # A tibble: 4 × 4\n#&gt;   key.x val_x key.y val_y\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1     1 x1        1 y1   \n#&gt; 2     2 x2        2 y2   \n#&gt; 3     3 x3       NA &lt;NA&gt; \n#&gt; 4    NA &lt;NA&gt;      4 y3\n\n在检查任何派对时间段是否与另一个派对时间段重叠时，我们在join_by()中使用了q &lt; q。为 什么？如 果去掉这个不等式会发生什么?",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "joins.html#小结",
    "href": "joins.html#小结",
    "title": "19  连接",
    "section": "19.6 小结",
    "text": "19.6 小结\n在本章中，你学习了如何使用变异连接和过滤连接来合并来自两个数据框的数据。在 此过程中，你学习了如何识别键，以及主键和外键之间的区别。你 还了解了连接的工作原理，以及如何计算输出将有多少行。最 后，初步了解了非等值连接的强大功能，并看到了一些有趣的应用案例。\n本章结束了本书“转换”部分的内容，该部分重点关注了你可以使用单个列和tibble的工具。你 学习了dplyr和基础函数来处理逻辑向量、数字和完整表格，学习了stringr函数来处理字符串，lubridate函数来处理日期和时间，以及forcats函数来处理因子。\n在本书的下一部分，你将学习更多关于如何将各种类型的数据以整齐的形式导入到R中。",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "joins.html#footnotes",
    "href": "joins.html#footnotes",
    "title": "19  连接",
    "section": "",
    "text": "记住，在RStudio中，你也可以使用View()来避免这个问题。↩︎\n这并不是百分百正确，但如果不是，你就会得到警告。↩︎",
    "crumbs": [
      "转换",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "spreadsheets.html",
    "href": "spreadsheets.html",
    "title": "20  电子表格",
    "section": "",
    "text": "20.1 引言\n在 章节 7 ，你学习了如何从纯文本文件 (如.csv和.tsv) 中导入数据。现 在是时候学习如何从电子表格（无论是Excel电子表格还是Google表单）中提取数据了。这 将在很大程度上基于你在 章节 7 所学的内容，但当我们处理来自电子表格的数据时，我们还将讨论其他考虑事项和复杂性。\n如果你或你的合作者正在使用电子表格组织数据，我们强烈建议你阅读Karl Broman和Kara Woo撰写的论文“Data Organization in Spreadsheets”：https://doi.org/10.1080/00031305.2017.1375989。该 论文中提出的最佳实践将让你在将电子表格中的数据导入R进行分析和可视化时省去许多麻烦。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>电子表格</span>"
    ]
  },
  {
    "objectID": "spreadsheets.html#excel",
    "href": "spreadsheets.html#excel",
    "title": "20  电子表格",
    "section": "20.2 Excel",
    "text": "20.2 Excel\nMicrosoft Excel 是一款广泛使用的电子表格软件程序，其中数据在电子表格文件内的工作表中组织。\n\n20.2.1 必要条件\n在本节中，你将学习如何使用readxl包在R中加载Excel电子表格中的数据。这 个包不是tidyverse的核心部分，所以你需要明确地加载它，但是当您安装tidyverse包时，它会自动安装。稍 后，我们还将使用writexl包，它允许我们创建Excel电子表格。\n\nlibrary(readxl)\nlibrary(tidyverse)\nlibrary(writexl)\n\n\n\n20.2.2 入门\nreadxl包的大部分函数都允许你将Excel电子表格加载到R中：\n\nread_xls() 用于读取xls格式的Excel文件；\nread_xlsx() 用于读取xlsx格式的Excel文件；\nread_excel() 可以读取xls和xlsx两种格式的文件，它根据输入的文件来猜测文件类型。\n\n这些函数的语法都与其他我们之前介绍的读取其他类型文件的函数 (例如read_csv()，read_table()等) 类似。在 本章的剩余部分，我们将重点介绍read_excel()函数。\n\n\n20.2.3 读取Excel电子表格\n图 20.1 展示了我们将要读入R的Excel电子表格在Excel中的样子。这 个电子表格可以从以下链接下载为Excel文件： https://docs.google.com/spreadsheets/d/1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w/。\n\n\n\n\n\n\n\n\n图 20.1: Spreadsheet called students.xlsx in Excel.\n\n\n\n\n\nread_excel()的第一个参数是要读取的文件的路径。\n\nstudents &lt;- read_excel(\"data/students.xlsx\")\n\nread_excel()会将文件读取为一个 tibble。\n\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 Güvenç Attila    Ice cream          Lunch only          6\n\n数据中有六名学生，每个学生有五个变量。但 是，在这个数据集中我们可能需要解决几个问题：\n\n列名非常混乱。你 可以提供遵循一致格式的列名；我们推荐使用col_names参数并遵循snake_case。\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\")\n)\n#&gt; # A tibble: 7 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;   &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1 Student ID Full Name        favourite.food     mealPlan            AGE  \n#&gt; 2 1          Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 3 2          Barclay Lynn     French fries       Lunch only          5    \n#&gt; 4 3          Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 5 4          Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 6 5          Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 7 6          Güvenç Attila    Ice cream          Lunch only          6\n\n不幸的是，这并不完全奏效。我 们现在有了想要的变量名，但是之前作为表头的行现在显示为数据中的第一行观测值。你 可以使用skip参数来明确跳过那一行。\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1\n)\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n\n在favourite_food列中，其中一个观测值是N/A，它代表“不可用”，但当前它并没有被识别为NA（请注意这个N/A和列表中第四个学生的年龄中的NA是不同的）。你 可以使用na参数来指定哪些字符串应该被识别为NA。默 认情况下，只有\"\"（空字符串，或者在从电子表格中读取数据时一个空单元格或者一个包含公式=NA()的单元格）会被识别为NA。\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1,\n  na = c(\"\", \"N/A\")\n)\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n\n另一个待解决的问题是，age被读取为字符变量，但实际上它应该是数值型的。就 像使用read_csv()和它的相关函数从平面文件中读取数据一样，你可以为read_excel()提供一个col_types参数，并指定你读取的变量的列类型。不 过，语法有点不同，选项有\"skip\"、\"guess\"、\"logical\"、\"numeric\"、\"date\"、\"text\"或\"list\"。\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1,\n  na = c(\"\", \"N/A\"),\n  col_types = c(\"numeric\", \"text\", \"text\", \"text\", \"numeric\")\n)\n#&gt; Warning: Expecting numeric in E6 / R6C5: got 'five'\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch    NA\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\n\n然而，这也没有产生期望的结果。通 过指定age应该是数值型的，我们已经将包含非数值条目（其值为five）的单元格转换成了NA。在 这种情况下，我们应该将年龄读取为\"text\"类型，然后在数据加载到R中后再进行更改。\n\nstudents &lt;- read_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1,\n  na = c(\"\", \"N/A\"),\n  col_types = c(\"numeric\", \"text\", \"text\", \"text\", \"text\")\n)\n\nstudents &lt;- students |&gt;\n  mutate(\n    age = if_else(age == \"five\", \"5\", age),\n    age = parse_number(age)\n  )\n\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\n\n\n加载数据以得到我们想要的精确格式需要多个步骤和反复尝试，这并不意外。数 据科学是一个迭代的过程，而与其他纯文本、矩形数据文件相比，从电子表格中读取数据时的迭代过程可能更加繁琐，因为人类倾向于将数据输入到电子表格中，并不仅仅用于数据存储，还用于共享和交流。\n在加载数据并查看之前，我们无法确切知道数据将是什么样子。不 过，实际上还是有一种方法的。你 可以在Excel中打开文件并查看。如 果你打算这样做，我们建议你复制Excel文件以进行交互式打开和浏览，同时保持原始数据文件不变，并从原始文件中读取到R中。这 将确保你在检查数据时不会意外地覆盖电子表格中的任何内容。你 也不应该害怕像我们这样做：加载数据，查看一下，调整你的代码，再次加载，重复这个过程，直到你对结果满意为止。\n\n\n20.2.4 读取工作表\n电子表格与平面文件之间的一个重要区别在于电子表格有多个表单，这些表单被称为工作表。@ fig-penguins-islands 显示了一个包含多个工作表的Excel电子表格。这 些数据来自palmerpenguins包，你可以从 https://docs.google.com/spreadsheets/d/1aFu8lnD_g0yjF5O-K6SFgSEWiHPpgvFCF0NY9D6LXnY/ 下载这个电子表格作为Excel文件。每 个工作表都包含了从不同岛屿收集到的企鹅信息。\n\n\n\n\n\n\n\n\n图 20.2: Spreadsheet called penguins.xlsx in Excel containing three worksheets.\n\n\n\n\n\n你可以利用read_excel()中的sheet参数从电子表格中读取单个工作表。到 目前为止，默认值是第一个工作表。\n\nread_excel(\"data/penguins.xlsx\", sheet = \"Torgersen Island\")\n#&gt; # A tibble: 52 × 8\n#&gt;   species island    bill_length_mm     bill_depth_mm      flipper_length_mm\n#&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;              &lt;chr&gt;              &lt;chr&gt;            \n#&gt; 1 Adelie  Torgersen 39.1               18.7               181              \n#&gt; 2 Adelie  Torgersen 39.5               17.399999999999999 186              \n#&gt; 3 Adelie  Torgersen 40.299999999999997 18                 195              \n#&gt; 4 Adelie  Torgersen NA                 NA                 NA               \n#&gt; 5 Adelie  Torgersen 36.700000000000003 19.3               193              \n#&gt; 6 Adelie  Torgersen 39.299999999999997 20.6               190              \n#&gt; # ℹ 46 more rows\n#&gt; # ℹ 3 more variables: body_mass_g &lt;chr&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n由于字符串 \"NA\" 没有被识别为真正的 NA（缺失值），一些看起来包含数值数据的变量被读取为字符类型。\n\npenguins_torgersen &lt;- read_excel(\"data/penguins.xlsx\", sheet = \"Torgersen Island\", na = \"NA\")\n\npenguins_torgersen\n#&gt; # A tibble: 52 × 8\n#&gt;   species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1 Adelie  Torgersen           39.1          18.7               181\n#&gt; 2 Adelie  Torgersen           39.5          17.4               186\n#&gt; 3 Adelie  Torgersen           40.3          18                 195\n#&gt; 4 Adelie  Torgersen           NA            NA                  NA\n#&gt; 5 Adelie  Torgersen           36.7          19.3               193\n#&gt; 6 Adelie  Torgersen           39.3          20.6               190\n#&gt; # ℹ 46 more rows\n#&gt; # ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n或者，您可以使用excel_sheets()来获取 Excel 电子表格中所有工作表的信息，然后读取你感兴趣的一个或多个工作表。\n\nexcel_sheets(\"data/penguins.xlsx\")\n#&gt; [1] \"Torgersen Island\" \"Biscoe Island\"    \"Dream Island\"\n\n如果你知道工作表的名称，可以使用read_excel()函数单独读取它们。\n\npenguins_biscoe &lt;- read_excel(\"data/penguins.xlsx\", sheet = \"Biscoe Island\", na = \"NA\")\npenguins_dream  &lt;- read_excel(\"data/penguins.xlsx\", sheet = \"Dream Island\", na = \"NA\")\n\n在这种情况下，完整的企鹅数据集分布在电子表格的三个工作表中。每 个工作表都有相同数量的列，但行数不同。\n\ndim(penguins_torgersen)\n#&gt; [1] 52  8\ndim(penguins_biscoe)\n#&gt; [1] 168   8\ndim(penguins_dream)\n#&gt; [1] 124   8\n\n我们可以使用bind_rows()将它们放在一起。\n\npenguins &lt;- bind_rows(penguins_torgersen, penguins_biscoe, penguins_dream)\npenguins\n#&gt; # A tibble: 344 × 8\n#&gt;   species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1 Adelie  Torgersen           39.1          18.7               181\n#&gt; 2 Adelie  Torgersen           39.5          17.4               186\n#&gt; 3 Adelie  Torgersen           40.3          18                 195\n#&gt; 4 Adelie  Torgersen           NA            NA                  NA\n#&gt; 5 Adelie  Torgersen           36.7          19.3               193\n#&gt; 6 Adelie  Torgersen           39.3          20.6               190\n#&gt; # ℹ 338 more rows\n#&gt; # ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n在 章节 26 中，我们将讨论在不重复代码的情况下完成这类任务的方法。\n\n\n20.2.5 读取部分工作表\n由于很多人使用 Excel 电子表格进行展示以及数据存储，因此经常会在电子表格中找到不属于你想要读入 R 的数据的单元格条目。@ fig-deaths-excel 展示了这样一个电子表格：在表格中间是一个类似数据框的内容，但在数据的上方和下方有一些额外的文本单元格。\n\n\n\n\n\n\n\n\n图 20.3: Spreadsheet called deaths.xlsx in Excel.\n\n\n\n\n\n这个电子表格是 readxl 包提供的一个示例电子表格。你 可以使用readxl_example()函数来定位这个电子表格在你系统上安装该包的目录中的位置。这 个函数会返回电子表格的路径，你可以像平常一样在read_excel()中使用它。\n\ndeaths_path &lt;- readxl_example(\"deaths.xlsx\")\ndeaths &lt;- read_excel(deaths_path)\n#&gt; New names:\n#&gt; • `` -&gt; `...2`\n#&gt; • `` -&gt; `...3`\n#&gt; • `` -&gt; `...4`\n#&gt; • `` -&gt; `...5`\n#&gt; • `` -&gt; `...6`\ndeaths\n#&gt; # A tibble: 18 × 6\n#&gt;   `Lots of people`    ...2       ...3  ...4     ...5          ...6           \n#&gt;   &lt;chr&gt;               &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;         &lt;chr&gt;          \n#&gt; 1 simply cannot resi… &lt;NA&gt;       &lt;NA&gt;  &lt;NA&gt;     &lt;NA&gt;          some notes     \n#&gt; 2 at                  the        top   &lt;NA&gt;     of            their spreadsh…\n#&gt; 3 or                  merging    &lt;NA&gt;  &lt;NA&gt;     &lt;NA&gt;          cells          \n#&gt; 4 Name                Profession Age   Has kids Date of birth Date of death  \n#&gt; 5 David Bowie         musician   69    TRUE     17175         42379          \n#&gt; 6 Carrie Fisher       actor      60    TRUE     20749         42731          \n#&gt; # ℹ 12 more rows\n\n前三行和最后四行不属于数据框。虽 然可以使用skip和n_max参数来消除这些多余的行，但我们建议使用单元格范围。在 Excel 中，左上角的单元格是 A1。当 你向右移动到其他列时，单元格标签会按照字母顺序向下移动，即 B1、C1 等。当 你向下移动到一个列时，单元格标签中的数字会增加，即 A2、A3 等。\n在这里，我们想要读取的数据从 A5 单元格开始，到 F15 单元格结束。在 电子表格表示法中，这是 A5:F15，我们将它提供给range参数：\n\nread_excel(deaths_path, range = \"A5:F15\")\n#&gt; # A tibble: 10 × 6\n#&gt;   Name          Profession   Age `Has kids` `Date of birth`    \n#&gt;   &lt;chr&gt;         &lt;chr&gt;      &lt;dbl&gt; &lt;lgl&gt;      &lt;dttm&gt;             \n#&gt; 1 David Bowie   musician      69 TRUE       1947-01-08 00:00:00\n#&gt; 2 Carrie Fisher actor         60 TRUE       1956-10-21 00:00:00\n#&gt; 3 Chuck Berry   musician      90 TRUE       1926-10-18 00:00:00\n#&gt; 4 Bill Paxton   actor         61 TRUE       1955-05-17 00:00:00\n#&gt; 5 Prince        musician      57 TRUE       1958-06-07 00:00:00\n#&gt; 6 Alan Rickman  actor         69 FALSE      1946-02-21 00:00:00\n#&gt; # ℹ 4 more rows\n#&gt; # ℹ 1 more variable: `Date of death` &lt;dttm&gt;\n\n\n\n20.2.6 数据类型\n在 CSV 文件中所有的值都是字符串。这 并不一定符合数据的实际情况，但它是简单的：一切都是字符串。I n CSV files, all values are strings. This is not particularly true to the data, but it is simple: everything is a string.\nExcel 电子表格中的底层数据更为复杂。一 个单元格可以是以下四种类型之一：\n\n一个布尔值，如 TRUE、FALSE 或 NA；\n一个数字，如 “10” 或 “10.5”；\n一个日期时间，也可以包含时间，如 “11/1/21” 或 “11/1/21 3:00 PM”；\n一个文本字符串，如 “ten”。\n\n在处理电子表格数据时，重要的是要记住底层数据可能与您在单元格中看到的内容大不相同。例 如，Excel 没有整数的概念。所 有数字都以浮点数形式存储，但您可以选择以可自定义的小数位数显示数据。类 似地，日期实际上是作为数字存储的，特别是自 1970 年 1 月 1 日以来的秒数。您 可以在 Excel 中应用格式设置来自定义日期的显示方式。令 人困惑的是，还可能有看起来像是数字但实际上是字符串的内容（例如，在 Excel 单元格中输入 '10）。\n底层数据存储方式与显示方式之间的差异可能会在将数据加载到 R 时造成意外。默 认情况下，readxl 会猜测给定列的数据类型。建 议的工作流程是让 readxl 猜测列类型，确认你对猜测的列类型满意，如果不满意，则返回并重新导入，指定col_types，如 小节 20.2.3 所示。\n另一个挑战是当你的 Excel 电子表格中的某一列包含这些类型的混合数据时，例如，一些单元格是数字，其他是文本，其他是日期。当 将数据导入 R 时，readxl 必须做出一些决策。在 这些情况下，你可以将该列的类型设置为 \"list\"，将该列加载为长度为 1 的向量列表，其中向量的每个元素的类型都将被猜测。\n\n\n\n\n\n\n有时数据会以更特殊的方式存储，比如单元格背景的颜色，或者文本是否为粗体。在 这种情况下，你可能会发现 tidyxl包很有用。请 访问https://nacnudus.github.io/spreadsheet-munging-strategies/ 以获取更多关于从 Excel 处理非表格数据的策略。\n\n\n\n\n\n20.2.7 写入Excel\n让我们创建一个小的数据框，然后将其写入Excel。请 注意，item是一个因子，而quantity是一个整数。\n\nbake_sale &lt;- tibble(\n  item     = factor(c(\"brownie\", \"cupcake\", \"cookie\")),\n  quantity = c(10, 5, 8)\n)\n\nbake_sale\n#&gt; # A tibble: 3 × 2\n#&gt;   item    quantity\n#&gt;   &lt;fct&gt;      &lt;dbl&gt;\n#&gt; 1 brownie       10\n#&gt; 2 cupcake        5\n#&gt; 3 cookie         8\n\n您可以使用 writexl包中的 write_xlsx() 函数将数据作为 Excel 文件写回到磁盘中：\n\nwrite_xlsx(bake_sale, path = \"data/bake-sale.xlsx\")\n\n图 20.4 展示了在 Excel 中数据的样子。请 注意，列名已经被包含并加粗了。这 些可以通过将 col_names 和 format_headers 参数设置为 FALSE 来关闭。\n\n\n\n\n\n\n\n\n图 20.4: Spreadsheet called bake_sale.xlsx in Excel.\n\n\n\n\n\n就像从 CSV 读取数据一样，当我们重新将数据读入时，数据类型的信息会丢失。这 使得Excel文件在缓存中间结果时也不可靠。对 于替代方案，请参阅 小节 7.5。\n\nread_excel(\"data/bake-sale.xlsx\")\n#&gt; # A tibble: 3 × 2\n#&gt;   item    quantity\n#&gt;   &lt;chr&gt;      &lt;dbl&gt;\n#&gt; 1 brownie       10\n#&gt; 2 cupcake        5\n#&gt; 3 cookie         8\n\n\n\n20.2.8 格式化输出\nwritexl包是一个轻量级的解决方案，用于编写简单的Excel电子表格。但 如果你对在电子表格内部写入工作表以及样式设置等额外功能感兴趣，那么你可能需要使用openxlsx包。我 们不会在这里详细介绍如何使用这个包，但我们建议你阅读https://ycphs.github.io/openxlsx/articles/Formatting.html，以获得有关使用openxlsx从R将数据写入Excel的更多格式化功能的广泛讨论。\n请注意，这个包不是tidyverse的一部分，因此它的函数和工作流程可能会让你感到陌生。例 如，函数名是驼峰命名法（camelCase），多个函数不能在管道中组合使用，并且参数的顺序与tidyverse中的习惯不同。不 过，这没问题。随 着你的R语言学习和使用范围扩展到本书之外，你将遇到许多用于实现R中特定目标的R包的不同使用风格。熟 悉新包中使用的编码风格的一个好方法是运行函数文档中提供的示例，以了解语法和输出格式，并阅读可能随包一起提供的任何说明文档。\n\n\n20.2.9 练习\n\n在Excel文件中创建以下数据集，并将其保存为survey.xlsx。或 者，从这里下载为Excel文件。\n\n\n\n\n\n\n\n\n\n然后将其读入R，其中survey_id作为字符变量，n_pets作为数值变量。\n\n#&gt; # A tibble: 6 × 2\n#&gt;   survey_id n_pets\n#&gt;   &lt;chr&gt;      &lt;dbl&gt;\n#&gt; 1 1              0\n#&gt; 2 2              1\n#&gt; 3 3             NA\n#&gt; 4 4              2\n#&gt; 5 5              2\n#&gt; 6 6             NA\n\n在另一个Excel文件中，创建以下数据集并将其保存为roster.xlsx。或 者，从这里下载为Excel文件。\n\n\n\n\n\n\n\n\n\n然后，将其读入R。生 成的数据框帧应该称为roster，如下所示。\n\n#&gt; # A tibble: 12 × 3\n#&gt;    group subgroup    id\n#&gt;    &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n#&gt;  1     1 A            1\n#&gt;  2     1 A            2\n#&gt;  3     1 A            3\n#&gt;  4     1 B            4\n#&gt;  5     1 B            5\n#&gt;  6     1 B            6\n#&gt;  7     1 B            7\n#&gt;  8     2 A            8\n#&gt;  9     2 A            9\n#&gt; 10     2 B           10\n#&gt; 11     2 B           11\n#&gt; 12     2 B           12\n\n在新的Excel文件中，创建以下数据集并将其保存为sale .xlsx。或 者，从这里下载为Excel文件。\n\n\n\n\n\n\n\n\n\na. 读取sale .xlsx并保存为sales。数 据框架应该如下所示，以id和n作为列名，共有9行。\n\n#&gt; # A tibble: 9 × 2\n#&gt;   id      n    \n#&gt;   &lt;chr&gt;   &lt;chr&gt;\n#&gt; 1 Brand 1 n    \n#&gt; 2 1234    8    \n#&gt; 3 8721    2    \n#&gt; 4 1822    3    \n#&gt; 5 Brand 2 n    \n#&gt; 6 3333    1    \n#&gt; 7 2156    3    \n#&gt; 8 3987    6    \n#&gt; 9 3216    5\n\nb. 进一步修改sales，转换为以下整齐格式，其中包含三列 (brand、id和n) 和7行数据。注 意id和n是数字，brand是字符变量。\n\n#&gt; # A tibble: 7 × 3\n#&gt;   brand      id     n\n#&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Brand 1  1234     8\n#&gt; 2 Brand 1  8721     2\n#&gt; 3 Brand 1  1822     3\n#&gt; 4 Brand 2  3333     1\n#&gt; 5 Brand 2  2156     3\n#&gt; 6 Brand 2  3987     6\n#&gt; 7 Brand 2  3216     5\n\n重新创建bake_sale数据框，使用openxlsx包的write.xlsx()函数将其写入Excel文件。\n在 章节 7 中，你了解了janitor::clean_names()函数，该函数将列名转换为蛇形大小写。阅 读本节前面介绍的students.xlsx文件，使用该函数“清除”列名。\n如果尝试使用read_xls()读入扩展名为.xlsx的文件，会发生什么情况？",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>电子表格</span>"
    ]
  },
  {
    "objectID": "spreadsheets.html#google表单",
    "href": "spreadsheets.html#google表单",
    "title": "20  电子表格",
    "section": "20.3 Google表单",
    "text": "20.3 Google表单\nGoogle表单是另一个广泛使用的电子表格程序。它 是免费的，基于网络。就 像Excel一样，在Google表单中，数据被组织在电子表格文件内的工作表（也称为表单）中。\n\n20.3.1 必要条件\n本节也关注电子表格，但这次你将使用googlesheets4包从Google表单中加载数据。这 个包也不是tidyverse的核心部分，你需要明确加载它。\n\nlibrary(googlesheets4)\nlibrary(tidyverse)\n\n关于包的名称的简要说明：googlesheets4使用Sheets API v4的v4版本来为Google表单提供R接口，因此得名。\n\n\n20.3.2 入门\ngooglesheets4包的主要函数是read_sheet()，它可以从URL或文件ID中读取Google表单。这 个函数也叫做range_read()。\n您还可以使用gs4_create()来创建一个全新的表单，或者使用sheet_write()及其相关函数写入现有表单。\n在本节中，我们将使用与Excel部分相同的数据集，以突出从Excel和Google表单读取数据的工作流程之间的相似性和差异。r eadxl和googlesheets4包都旨在模仿readr包的功能，readr包提供了在 章节 7 见提到的read_csv()函数。因 此，许多任务可以简单地通过用read_sheet()替换read_excel()来完成。然 而，你也会看到Excel和Google表单的行为并不完全相同，因此其他任务可能需要对函数调用进行进一步的更新。\n\n\n20.3.3 读取Google表单\n图 20.5 展示了我们将要读取到R中的电子表格在Google表单中的样子。这 与@fig-students-excel 中的数据集相同，只是它被存储在Google表单中而不是Excel中。\n\n\n\n\n\n\n\n\n图 20.5: Google Sheet called students in a browser window.\n\n\n\n\n\nread_sheet()的第一个参数是要读取的文件的URL，它返回一个tibble:\nhttps://docs.google.com/spreadsheets/d/1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w. 这些URL使用起来并不方便，因此通常希望通过其ID来标识表单。\n\ngs4_deauth()\n\n\n# students_sheet_id &lt;- \"1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w\"\n# students &lt;- read_sheet(students_sheet_id)\n# students\n\n就像我们使用read_excel()一样，我们可以为read_sheet()提供列名、NA字符串和列类型。\n\n# students &lt;- read_sheet(\n#   students_sheet_id,\n#   col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n#   skip = 1,\n#   na = c(\"\", \"N/A\"),\n#   col_types = \"dcccc\"\n# )\n# \n# students\n\n请注意，我们这里使用短代码对列类型进行了稍微不同的定义。例 如，“dcccc”代表“double, character, character, character, character”。\n同样，也可以从Google表单中读取单个表单。让 我们从penguins Google Sheet中读取“Torgersen Island”表单：\n\n# penguins_sheet_id &lt;- \"1aFu8lnD_g0yjF5O-K6SFgSEWiHPpgvFCF0NY9D6LXnY\"\n# read_sheet(penguins_sheet_id, sheet = \"Torgersen Island\")\n\n你可以使用sheet_names()函数来获取Google表单中所有表单的列表：\n\n# sheet_names(penguins_sheet_id)\n\n最后，就像使用read_excel()一样，我们可以通过在read_sheet()中定义一个范围来读取Google表单的一部分。请 注意，下面我们还使用了gs4_example()函数来定位与googlesheets4包一起提供的示例Google表单。\n\n# deaths_url &lt;- gs4_example(\"deaths\")\n# deaths &lt;- read_sheet(deaths_url, range = \"A5:F15\")\n# deaths\n\n\n\n20.3.4 写入Google表单\n您可以使用write_sheet()函数将R中的数据写入Google表单。第 一个参数是要写入的数据框，第二个参数是要写入的Google表单的名称 (或其他标识符)：\n\n# write_sheet(bake_sale, ss = \"bake-sale\")\n\n如果您想将数据写入Google表单中的特定表单，您还可以使用sheet参数来指定它。\n\n# write_sheet(bake_sale, ss = \"bake-sale\", sheet = \"Sales\")\n\n\n\n20.3.5 身份验证\n虽然你可以在没有使用Google帐户进行身份验证的情况下使用gs4_deauth()从公共的Google表单中读取数据，但读取私有表单或写入表单需要身份验证，以便googlesheets4 能够查看和管理您的Google表单。\n当你尝试读取需要身份验证的表单时，googlesheets4 会引导你访问一个网页，提示你登录Google帐户并授予权限，以便代表你使用Google表单进行操作。但 是，如果你想指定特定的Google帐户、身份验证范围等，可以使用gs4_auth()来完成，例如gs4_auth(email = \"mine@example.com\")，这将强制使用与特定电子邮件关联的令牌。有 关身份验证的更多详细信息，我们建议您阅读googlesheets4 的身份验证文档：https://googlesheets4.tidyverse.org/articles/auth.html 。\n\n\n20.3.6 练习\n\n从Excel和Google表单中读取本章前面提到的students数据集，不向read_excel()和read_sheet()函数提供任何额外的参数。在 R中生成的数据框是否完全相同？如 果不同，它们有何不同？\n从 https://pos.it/r4ds-survey 读取名为survey的Google表单，其中survey_id作为字符变量，n_pets作为数值变量。\n从 https://pos.it/r4ds-roster 读取名为roster的Google表单。生 成的数据框应命名为roster，并应如下所示。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>电子表格</span>"
    ]
  },
  {
    "objectID": "spreadsheets.html#小结",
    "href": "spreadsheets.html#小结",
    "title": "20  电子表格",
    "section": "20.4 小结",
    "text": "20.4 小结\nMicrosoft Excel和Google Sheets是两个最受欢迎的电子表格系统。能 够直接从R与存储在Excel和Google Sheets文件中的数据进行交互是一项超能力！在 本章中，你学习了如何使用readxl包中的read_excel()函数从Excel电子表格读取数据到R中，以及如何使用googlesheets4包中的read_sheet()函数从Google Sheets读取数据。这 些函数彼此之间的工作方式非常相似，并且具有类似的参数来指定列名、NA字符串、要跳过的文件顶部的行等。此 外，这两个函数都允许你从电子表格中读取单个表单。\n另一方面，写入Excel文件需要不同的包和函数（writexl::write_xlsx()），而你可以使用googlesheets4包的write_sheet()函数将数据写入Google Sheets。\n在下一章中，你将学习一种不同的数据源以及如何将数据从该数据源读取到R中：数据库。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>电子表格</span>"
    ]
  },
  {
    "objectID": "databases.html",
    "href": "databases.html",
    "title": "21  数据库",
    "section": "",
    "text": "21.1 引言\n大量的数据存储在数据库中，因此知道如何访问这些数据至关重要。有 时你可以请求他人为你下载数据库的一个快照到.csv文件中，但这样做很快就会变得麻烦：每次你需要做出更改时，你都需要与另一个人沟通。你 希望能够在你需要时直接访问数据库来获取所需的数据。\n在本章中，你将首先学习DBI包的基础知识：如何使用它连接到数据库，然后使用SQL1 查询检索数据。 SQL，即structured query language (结构化查询语言) 的缩写，是数据库的通用语言，是所有数据科学家都需要学习的重要语言。 不过，我们不会从SQL开始，而是教你使用dbplyr，它可以将你的dplyr代码转换为SQL。 我们将使用这种方法来教你SQL的一些最重要的特性。 到本章结束时你或许不会成为SQL大师，但你能够识别最重要的组件并理解它们的作用。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "databases.html#引言",
    "href": "databases.html#引言",
    "title": "21  数据库",
    "section": "",
    "text": "21.1.1 必要条件\n在本章中，我们将介绍DBI和dbplyr。D BI是一个低级接口，用于连接到数据库并执行SQL语句；而dbplyr是一个高级接口，它将你的dplyr代码转换为SQL查询，然后使用DBI来执行这些查询。\n\nlibrary(DBI)\nlibrary(dbplyr)\nlibrary(tidyverse)",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "databases.html#数据库基础",
    "href": "databases.html#数据库基础",
    "title": "21  数据库",
    "section": "21.2 数据库基础",
    "text": "21.2 数据库基础\n在最简单的层面上，你可以将数据库视为数据框的集合，在数据库术语中称为表 (tables)。与 数据框一样，数据库的表是由命名列组成的集合，列中的每个值都是相同的类型。数 据框和数据库表之间存在三个主要差异：\n\n数据库表存储在磁盘上，可以任意大。而数据框存储在内存中，并且本质上存在限制（尽管这个限制对于许多问题来说仍然足够大）。\n数据库表几乎总是有索引。就像书的索引一样，数据库索引使得可以快速地找到感兴趣的行，而无需查看每一行。数据框和tibbles没有索引，但data.tables有，这也是它们如此快速的原因之一。\n大多数经典数据库都优化为快速收集数据，而不是分析现有数据。这些数据库被称为行式数据库，因为它们按行存储数据，而不是像R那样按列存储。最近，已经开发出了许多列式数据库，这些数据库使分析现有数据变得更快。\n\n数据库由数据库管理系统（DBMS）运行，DBMS有三种基本形式：\n\n客户端-服务器：DBMS在功能强大的中央服务器上运行，你可以从你的电脑（客户端）连接到它。它们非常适合在组织内与多人共享数据。流行的客户端-服务器DBMS包括PostgreSQL、MariaDB、SQL Server和Oracle等。\n云DBMS：如Snowflake、Amazon的RedShift和Google的BigQuery，类似于客户端-服务器DBMS，但它们在云端运行。这意味着它们可以轻松地处理非常大的数据集，并可以根据需要自动提供更多的计算资源。\n进程内DBMS：如SQLite或duckdb，完全在你的电脑上运行。当你是主要用户时，它们非常适合处理大型数据集。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "databases.html#连接数据库",
    "href": "databases.html#连接数据库",
    "title": "21  数据库",
    "section": "21.3 连接数据库",
    "text": "21.3 连接数据库\n要从R连接到数据库，需要使用一对软件包：\n\n经常使用的DBI (database interface)包，因为它提供了一组通用函数，用于连接到数据库、上传数据、运行SQL查询等。\n一个针对你要连接的DBMS定制的包，这个包将通用的DBI命令转换为DBMS所需的特定命令。通常每个DBMS都有一个这样的包，例如RPostgres用于PostgreSQL，RMariaDB用于MySQL。\n\n如果找不到针对你的DBMS的特定包，你通常可以使用odbc包作为替代。o dbc使用许多DBMS都支持的ODBC协议。但 是，odbc需要更多的设置，因为你还需要安装一个ODBC驱动程序，并告诉odbc包在哪里找到它。\n具体来说，你使用DBI::dbConnect()创建一个数据库连接。第 一个参数选择DBMS2，然后第二个及后续参数描述如何连接到它 (即它在哪里以及你需要访问它的凭据)。 以下代码展示了几个典型的例子：\n\ncon &lt;- DBI::dbConnect(\n  RMariaDB::MariaDB(), \n  username = \"root\",\n  password = \"702177gqb\"\n)\ncon &lt;- DBI::dbConnect(\n  RPostgres::Postgres(), \n  hostname = \"databases.mycompany.com\", \n  port = 1234\n)\n\n连接的具体细节在不同的DBMS之间差异很大，所以我们无法在这里涵盖所有细节。这 意味着你需要自己进行一些研究。通 常，你可以询问你团队中的其他数据科学家，或者与你的DBA（数据库管理员）交谈。初 始设置通常需要一些调试（也许还需要一些网络搜索）才能正确完成，但通常你只需要做一次这样的设置。\n\n21.3.1 在这本书中\n为了这本书设置客户端-服务器或云DBMS会是一个繁琐的过程，所以我们将使用完全驻留在R包duckdb中的进程内DBMS。由 于DBI的魔力，使用duckdb与其他DBMS之间的唯一区别在于将如何连接到数据库。这 使得它非常适合用于教学，因为你可以轻松地运行此代码，并且可以将所学到的知识轻松地应用到其他地方。\n连接到duckdb特别简单，因为默认设置会创建一个临时数据库，当你退出R时该数据库会被删除。这 对于学习来说非常棒，因为它保证了你每次重启R时都会从一个干净的状态开始。\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb())\n\nduckdb 是一个高性能数据库，专为数据科学家的需求而设计。我 们在这里使用它是因为它上手非常简单，同时也能够以极高的速度处理数十亿字节的数据。如 果你想在真实的数据分析项目中使用 duckdb，你还需要提供dbdir参数来创建一个持久的数据库，并告诉 duckdb 在哪里保存它。假 设你正在使用一个项目 (如@sec-workflow-scripts-projects)，将其存储在当前项目的 duckdb 目录下是一个合理的选择：\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = \"duckdb\")\n\n\n\n21.3.2 加载数据\n既然这是一个新的数据库，我们首先需要添加一些数据。在 这里，我们将使用DBI::dbWriteTable()函数从ggplot2包中添加mpg和diamonds数据集。d bWriteTable()函数的最简单用法需要三个参数：一个数据库连接、在数据库中要创建的表的名称以及一个数据框。\n\ndbWriteTable(con, \"mpg\", ggplot2::mpg)\ndbWriteTable(con, \"diamonds\", ggplot2::diamonds)\n\n如果你在一个实际项目中使用 duckdb，我们强烈推荐你学习duckdb_read_csv()和duckdb_register_arrow()。这 两个函数为你提供了强大且高效的方式，可以直接将数据快速加载到 duckdb中，而无需首先将数据加载到 R 中。在 小节 26.4.1 我们还将展示一种有用的技术，用于将多个文件加载到数据库中。\n\n\n21.3.3 DBI基础\n你可以通过使用其他一些DBI函数来检查数据是否正确加载：dbListTables()函数列出了数据库中的所有表，而dbReadTable()函数则检索表的内容。\n\ndbListTables(con)\n#&gt; [1] \"diamonds\" \"mpg\"\n\ncon |&gt; \n  dbReadTable(\"diamonds\") |&gt; \n  as_tibble()\n#&gt; # A tibble: 53,940 × 10\n#&gt;   carat cut       color clarity depth table price     x     y     z\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#&gt; 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#&gt; 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#&gt; 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#&gt; 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#&gt; 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#&gt; # ℹ 53,934 more rows\n\ndbReadTable()函数返回一个data.frame，所以我们使用as_tibble()函数将其转换为tibble，以便输出更美观。\n如果你已经熟悉 SQL，你可以使用dbGetQuery()函数来执行数据库查询并获取结果：\n\nsql &lt;- \"\n  SELECT carat, cut, clarity, color, price \n  FROM diamonds \n  WHERE price &gt; 15000\n\"\nas_tibble(dbGetQuery(con, sql))\n#&gt; # A tibble: 1,655 × 5\n#&gt;   carat cut       clarity color price\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt;   &lt;fct&gt; &lt;int&gt;\n#&gt; 1  1.54 Premium   VS2     E     15002\n#&gt; 2  1.19 Ideal     VVS1    F     15005\n#&gt; 3  2.1  Premium   SI1     I     15007\n#&gt; 4  1.69 Ideal     SI1     D     15011\n#&gt; 5  1.5  Very Good VVS2    G     15013\n#&gt; 6  1.73 Very Good VS1     G     15014\n#&gt; # ℹ 1,649 more rows\n\n如果你之前从未见过SQL，不用担心！很 快你就会了解更多关于它的知识。如 果仔细阅读，你可能会猜出它是从diamonds数据集中选择了五列，并且只选择了price大于15,000的所有行。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "databases.html#dbplyr基础",
    "href": "databases.html#dbplyr基础",
    "title": "21  数据库",
    "section": "21.4 dbplyr基础",
    "text": "21.4 dbplyr基础\n既然我们已经连接到数据库并加载了一些数据，那么就可以开始学习dbplyr了。d bplyr是dplyr的一个后端 (backend)，这意味着你仍然编写dplyr代码，但后端会以不同的方式执行它。在 这里，dbplyr将dplyr代码转换为SQL；其他后端包括dtplyr，它将代码转换为data.table，以及multidplyr，它会在多个核心上执行你的代码。\n要使用dbplyr，你首先必须使用tbl()函数来创建一个代表数据库表的对象：\n\ndiamonds_db &lt;- tbl(con, \"diamonds\")\ndiamonds_db\n#&gt; # Source:   table&lt;diamonds&gt; [?? x 10]\n#&gt; # Database: DuckDB v1.0.0 [root@Darwin 23.6.0:R 4.4.1/:memory:]\n#&gt;   carat cut       color clarity depth table price     x     y     z\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#&gt; 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#&gt; 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#&gt; 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#&gt; 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#&gt; 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#&gt; # ℹ more rows\n\n\n\n\n\n\n\n与数据库交互有另外两种常见方式。首 先，许多企业数据库都非常大，因此你需要某种层次结构来保持所有表的组织有序。在 这种情况下，你可能需要提供一个模式（schema），或者一个目录（catalog）和一个模式（schema），以便选择你感兴趣的表：\n\ndiamonds_db &lt;- tbl(con, in_schema(\"sales\", \"diamonds\"))\ndiamonds_db &lt;- tbl(con, in_catalog(\"north_america\", \"sales\", \"diamonds\"))\n\n其他时候，你可能想以自己的SQL查询作为起点：\n\ndiamonds_db &lt;- tbl(con, sql(\"SELECT * FROM diamonds\"))\n\n\n\n\n这个对象是有惰性的；当你在它上面使用dplyr函数时，dplyr不会执行任何操作，它只是记录你想要执行的操作序列，并且只在需要时才执行它们。例 如，看下面的管道：\n\nbig_diamonds_db &lt;- diamonds_db |&gt; \n  filter(price &gt; 15000) |&gt; \n  select(carat:clarity, price)\n\nbig_diamonds_db\n#&gt; # Source:   SQL [?? x 5]\n#&gt; # Database: DuckDB v1.0.0 [root@Darwin 23.6.0:R 4.4.1/:memory:]\n#&gt;   carat cut       color clarity price\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n#&gt; 1  1.54 Premium   E     VS2     15002\n#&gt; 2  1.19 Ideal     F     VVS1    15005\n#&gt; 3  2.1  Premium   I     SI1     15007\n#&gt; 4  1.69 Ideal     D     SI1     15011\n#&gt; 5  1.5  Very Good G     VVS2    15013\n#&gt; 6  1.73 Very Good G     VS1     15014\n#&gt; # ℹ more rows\n\n你可以看出这个对象代表一个数据库查询，因为它在顶部输出DBMS的名称，虽然它告诉你列数，但它通常不知道行数。因 为查找总行数通常需要执行完整的查询，这是我们试图避免的。\n你可以通过dplyr函数show_query()来查看生成的SQL代码。如 果你了解dplyr，这是一个学习SQL的好方法！编 写一些dplyr代码，让dbplyr将其转换为SQL，然后尝试理解这两种语言是如何对应的。\n\nbig_diamonds_db |&gt;\n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT carat, cut, color, clarity, price\n#&gt; FROM diamonds\n#&gt; WHERE (price &gt; 15000.0)\n\n要将所有数据返回到R中，调用collect()函数。在 幕后，这个函数会生成SQL语句，调用dbGetQuery()来获取数据，然后将结果转换为一个tibble：\n\nbig_diamonds &lt;- big_diamonds_db |&gt; \n  collect()\nbig_diamonds\n#&gt; # A tibble: 1,655 × 5\n#&gt;   carat cut       color clarity price\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n#&gt; 1  1.54 Premium   E     VS2     15002\n#&gt; 2  1.19 Ideal     F     VVS1    15005\n#&gt; 3  2.1  Premium   I     SI1     15007\n#&gt; 4  1.69 Ideal     D     SI1     15011\n#&gt; 5  1.5  Very Good G     VVS2    15013\n#&gt; 6  1.73 Very Good G     VS1     15014\n#&gt; # ℹ 1,649 more rows\n\n通常，你会使用dbplyr从数据库中选择你想要的数据，利用下面描述的转换来进行基本的筛选和聚合。然 后，当你准备好使用R特有的函数来分析数据时，你会使用collect()函数将数据收集到内存中作为一个tibble，并继续用纯R代码进行工作。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "databases.html#sql",
    "href": "databases.html#sql",
    "title": "21  数据库",
    "section": "21.5 SQL",
    "text": "21.5 SQL\n本章的其余部分将通过dbplyr的视角向你介绍一些SQL知识。虽 然这是一种非传统的SQL入门方式，但我们希望它能让你快速掌握基础知识。幸 运的是，如果你了解dplyr，你就已经站在了一个可以快速学习SQL的起点上，因为很多概念都是相同的。\n我们将使用nycflights13包中的两个老朋友 flights和planes 来探索dplyr和SQL之间的关系。这 些数据集很容易导入到我们的学习数据库中，因为dbplyr提供了一个函数，可以将nycflights13中的表复制到我们的数据库中：\n\ndbplyr::copy_nycflights13(con)\n#&gt; Creating table: airlines\n#&gt; Creating table: airports\n#&gt; Creating table: flights\n#&gt; Creating table: planes\n#&gt; Creating table: weather\nflights &lt;- tbl(con, \"flights\")\nplanes &lt;- tbl(con, \"planes\")\n\n\n21.5.1 SQL基础\nSQL的顶层组件被称为语句 (statements)。常 见的语句包括用于定义新表的CREATE、用于添加数据的INSERT和用于检索数据的SELECT。我 们将专注于SELECT语句，也称为查询 (queries)，因为作为数据科学家，你几乎只会使用它们。\n一个查询由子句组成。有 五个重要的子句：SELECT、FROM、WHERE、ORDER BY和GROUP BY。每 个查询都必须有SELECT3和FROM4子句，最简单的查询是SELECT * FROM table，它从指定的表中选择所有列 。这就是dbplyr为一个未经修改的表生成的内容 ：\n\nflights |&gt; show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT *\n#&gt; FROM flights\nplanes |&gt; show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT *\n#&gt; FROM planes\n\nWHERE和ORDER BY控制哪些行被包括在内以及它们的排序方式：\n\nflights |&gt; \n  filter(dest == \"IAH\") |&gt; \n  arrange(dep_delay) |&gt;\n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (dest = 'IAH')\n#&gt; ORDER BY dep_delay\n\nGROUP BY 将查询转换为摘要汇总，导致发生聚合：converts the query to a summary, causing aggregation to happen:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(dep_delay = mean(dep_delay, na.rm = TRUE)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT dest, AVG(dep_delay) AS dep_delay\n#&gt; FROM flights\n#&gt; GROUP BY dest\n\ndplyr的动词和SELECT子句之间有两个重要的区别：\n\n在SQL中，大小写不敏感：你可以写select、SELECT，甚至是SeLeCt。在本书中，我们将坚持使用常见的约定，将SQL关键字大写以区别于表名或变量名。\n在SQL中，顺序很重要：你必须始终按照SELECT、FROM、WHERE、GROUP BY、ORDER BY的顺序编写子句。令人困惑的是，这个顺序并不匹配子句实际评估的顺序，实际的顺序是首先FROM，然后是WHERE，GROUP BY，SELECT，最后是ORDER BY。\n\n以下部分将更详细地探讨每个子句。\n\n\n\n\n\n\n请注意，尽管SQL是一个标准，但它非常复杂，没有哪个数据库能够完全遵循它。尽 管本书关注的主要组件在不同的DBMS之间非常相似，但仍存在许多细微的差异。幸 运的是，dbplyr可以用来处理这个问题，并为不同的数据库生成不同的翻译。它 并不完美，但正在不断改进，如果你遇到问题，可以在GitHub上提交一个问题来帮助我们做得更好。\n\n\n\n\n\n21.5.2 SELECT\nSELECT子句是查询的支柱，执行与select(), mutate(), rename(), relocate() 以及你将在下一节学到的summarize()相同的工作。\nselect(), rename() 和 relocate() 在SQL的SELECT中有非常直接的对应关系，因为它们只是影响列出现的位置（如果有的话）及其名称：\n\nplanes |&gt; \n  select(tailnum, type, manufacturer, model, year) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT tailnum, \"type\", manufacturer, model, \"year\"\n#&gt; FROM planes\n\nplanes |&gt; \n  select(tailnum, type, manufacturer, model, year) |&gt; \n  rename(year_built = year) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT tailnum, \"type\", manufacturer, model, \"year\" AS year_built\n#&gt; FROM planes\n\nplanes |&gt; \n  select(tailnum, type, manufacturer, model, year) |&gt; \n  relocate(manufacturer, model, .before = type) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT tailnum, manufacturer, model, \"type\", \"year\"\n#&gt; FROM planes\n\n这个例子还展示了SQL如何进行重命名。在 SQL术语中重命名被称为别名（aliasing），并通过AS关键字来完成。请 注意，与mutate()不同，旧名称在左侧，新名称在右侧。\n\n\n\n\n\n\n在上面的例子中，请注意“year”和“type”被双引号括起来了。这 是因为这些是duckdb中的保留字 (reserved words)，所以dbplyr将它们用引号括起来以避免列/表名与SQL运算符之间的任何潜在混淆。\n当与其他数据库一起工作时，你可能会看到每个变量名都被引用了，因为只有少数几个客户端包（如duckdb）知道所有的保留字是什么，所以它们为了安全起见，将所有内容都加上引号。\nSELECT \"tailnum\", \"type\", \"manufacturer\", \"model\", \"year\"\nFROM \"planes\"\n其他一些数据库系统使用反引号代替引号:\nSELECT `tailnum`, `type`, `manufacturer`, `model`, `year`\nFROM `planes`\n\n\n\nmutate()的转换同样直接：每个变量都成为SELECT中的一个新表达式：\n\nflights |&gt; \n  mutate(\n    speed = distance / (air_time / 60)\n  ) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*, distance / (air_time / 60.0) AS speed\n#&gt; FROM flights\n\n我们将在 小节 21.6 讨论单个组件 (如/) 的转换。\n\n\n21.5.3 FROM\nFROM子句定义数据源。这 一段时间你会很无趣，因为我们只是在用单表。在 学习连接函数之后，你将看到更复杂的示例。\n\n\n21.5.4 GROUP BY\ngroup_by()被转换成 GROUP BY5 子句，而summarize()被转换成 SELECT 子句：\n\ndiamonds_db |&gt; \n  group_by(cut) |&gt; \n  summarize(\n    n = n(),\n    avg_price = mean(price, na.rm = TRUE)\n  ) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT cut, COUNT(*) AS n, AVG(price) AS avg_price\n#&gt; FROM diamonds\n#&gt; GROUP BY cut\n\n我们将回头在 小节 21.6 讨论 n()和mean()的转换是如何进行的。\n\n\n21.5.5 WHERE\nfilter() 转换成 WHERE 子句:\n\nflights |&gt; \n  filter(dest == \"IAH\" | dest == \"HOU\") |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (dest = 'IAH' OR dest = 'HOU')\n\nflights |&gt; \n  filter(arr_delay &gt; 0 & arr_delay &lt; 20) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (arr_delay &gt; 0.0 AND arr_delay &lt; 20.0)\n\n这里有几个重要的细节需要注意：\n\n| 变成了 OR， 而 & 变成了 AND.\nSQL 使用 = 进行比较，而不是 ==。SQL 没有赋值操作，所以在这方面没有混淆的可能性。\nSQL 只使用单引号 '' 来标识字符串，而不是双引号 \"\"。在 SQL 中，双引号 \"\" 用于标识变量，类似于 R 中的反引号 ``。\n\n另一个有用的 SQL 操作符是 IN，它与 R 中的 %in% 非常接近。\n\nflights |&gt; \n  filter(dest %in% c(\"IAH\", \"HOU\")) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (dest IN ('IAH', 'HOU'))\n\nSQL 使用 NULL 而不是 NA。N ULL 的行为与 NA 类似。主 要区别在于虽然它们在比较和算术运算中具有“传染性”，但在汇总时它们会被静默地删除。当 你第一次遇到这种行为时，dbplyr 会提醒你注意这一点。\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(delay = mean(arr_delay))\n#&gt; Warning: Missing values are always removed in SQL aggregation functions.\n#&gt; Use `na.rm = TRUE` to silence this warning\n#&gt; This warning is displayed once every 8 hours.\n#&gt; # Source:   SQL [?? x 2]\n#&gt; # Database: DuckDB v1.0.0 [root@Darwin 23.6.0:R 4.4.1/:memory:]\n#&gt;   dest  delay\n#&gt;   &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 ATL   11.3 \n#&gt; 2 CLT    7.36\n#&gt; 3 MCO    5.45\n#&gt; 4 MDW   12.4 \n#&gt; 5 HOU    7.18\n#&gt; 6 SDF   12.7 \n#&gt; # ℹ more rows\n\n如果你想了解更多关于 NULL 是如何工作的，你可能会喜欢 Markus Winand 的《The Three-Valued Logic of SQL》。\n通常，你可以使用在 R 中用于处理 NA 的函数来处理 NULL：\n\nflights |&gt; \n  filter(!is.na(dep_delay)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (NOT((dep_delay IS NULL)))\n\n这个 SQL 查询展示了 dbplyr 的一个缺点：虽然 SQL 是正确的，但它并不像你手动编写时那样简单。在 这种情况下，你可以去掉括号，并使用一个更易读的特殊操作符：\nWHERE \"dep_delay\" IS NOT NULL\n请注意，如果你对一个通过summarize()创建的变量进行filter()操作，dbplyr 会生成一个 HAVING 子句，而不是 WHERE 子句。这 是 SQL 的一个特性：WHERE 子句在 SELECT 和 GROUP BY 之前评估，所以 SQL 需要另一个在之后评估的子句，这就是 HAVING 子句。\n\ndiamonds_db |&gt; \n  group_by(cut) |&gt; \n  summarize(n = n()) |&gt; \n  filter(n &gt; 100) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT cut, COUNT(*) AS n\n#&gt; FROM diamonds\n#&gt; GROUP BY cut\n#&gt; HAVING (COUNT(*) &gt; 100.0)\n\n\n\n21.5.6 ORDER BY\n对行进行排序涉及从arrange()到ORDER BY子句的直接转换：\n\nflights |&gt; \n  arrange(year, month, day, desc(dep_delay)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; ORDER BY \"year\", \"month\", \"day\", dep_delay DESC\n\n请注意desc()是如何被转换成DESC的：这是许多直接受到SQL启发的dplyr函数之一。\n\n\n21.5.7 子查询 (Subqueries)\n有时，无法将dplyr管道转换成单个SELECT语句，这时就需要使用子查询。子 查询只是在FROM子句中用作数据源，而不是通常的表。\ndbplyr通常使用子查询来克服SQL的限制。例 如，SELECT子句中的表达式不能引用刚刚创建的列。这 意味着以下（愚蠢的）dplyr管道需要分两步进行：第一个（内部）查询计算year1，然后第二个（外部）查询可以计算year2。\n\nflights |&gt; \n  mutate(\n    year1 = year + 1,\n    year2 = year1 + 1\n  ) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT q01.*, year1 + 1.0 AS year2\n#&gt; FROM (\n#&gt;   SELECT flights.*, \"year\" + 1.0 AS year1\n#&gt;   FROM flights\n#&gt; ) q01\n\n如果你试图对刚刚创建的变量进行filter()操作，你也会遇到这个问题。请 记住，尽管WHERE在SELECT之后编写，但它是在SELECT之前评估的，所以在这个（愚蠢的）例子中我们需要一个子查询。\nYou’ll also see this if you attempted to filter() a variable that you just created. Remember, even though WHERE is written after SELECT, it’s evaluated before it, so we need a subquery in this (silly) example:\n\nflights |&gt; \n  mutate(year1 = year + 1) |&gt; \n  filter(year1 == 2014) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT q01.*\n#&gt; FROM (\n#&gt;   SELECT flights.*, \"year\" + 1.0 AS year1\n#&gt;   FROM flights\n#&gt; ) q01\n#&gt; WHERE (year1 = 2014.0)\n\n有时，dbplyr 会在不需要子查询的情况下创建子查询，因为它还不知道如何优化这种转换。随 着时间的推移，dbplyr 的改进会使这种情况越来越少，但可能永远不会完全消失。\n\n\n21.5.8 Joins\n如果你熟悉dplyr的连接（joins），那么SQL的连接是非常相似的。下 面是一个简单的例子：\n\nflights |&gt; \n  left_join(planes |&gt; rename(year_built = year), by = \"tailnum\") |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   flights.*,\n#&gt;   planes.\"year\" AS year_built,\n#&gt;   \"type\",\n#&gt;   manufacturer,\n#&gt;   model,\n#&gt;   engines,\n#&gt;   seats,\n#&gt;   speed,\n#&gt;   engine\n#&gt; FROM flights\n#&gt; LEFT JOIN planes\n#&gt;   ON (flights.tailnum = planes.tailnum)\n\n这里需要注意的主要是语法：SQL 连接使用 FROM 子句的子句来引入其他表，并使用 ON 来定义表之间的关系。\ndplyr 中这些函数的命名与 SQL 如此紧密相关，以至于你可以很容易地猜出 inner_join()、right_join() 和 full_join() 的等效 SQL 语句：\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nINNER JOIN planes ON (flights.tailnum = planes.tailnum)\n\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nRIGHT JOIN planes ON (flights.tailnum = planes.tailnum)\n\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nFULL JOIN planes ON (flights.tailnum = planes.tailnum)\n当从数据库中处理数据时，你可能需要很多连接操作。这 是因为数据库表通常以高度规范化的形式存储，其中每个“事实”都存储在单个位置，为了保持完整的数据集以供分析，你需要遍历由主键和外键连接的复杂表网络。如 果你遇到这种情况，Tobias Schieferdecker、Kirill Müller 和 Darko Bergant 开发的 dm 包将是一个救星。它 可以使用 DBA 通常提供的约束自动确定表之间的连接，可视化这些连接以便你可以看到发生了什么，并生成你需要的连接来将一个表连接到另一个表。\n\n\n21.5.9 其他函数\ndbplyr 还翻译了其他函数，如distinct()、slice_*()、和intersect() 以及越来越多的 tidyr 函数，如pivot_longer()和pivot_wider()。查 看当前可用的完整集合的最简单方法是访问 dbplyr 网站：https://dbplyr.tidyverse.org/reference/ 。\n\n\n21.5.10 练习\n\ndistinct() 被转换成什么？ 那么head()呢？\n解释下面每个SQL查询的作用，并尝试使用dbplyr重新创建它们。\nSELECT * \nFROM flights\nWHERE dep_delay &lt; arr_delay\n\nSELECT *, distance / (air_time / 60) AS speed\nFROM flights",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "databases.html#sec-sql-expressions",
    "href": "databases.html#sec-sql-expressions",
    "title": "21  数据库",
    "section": "21.6 函数转换",
    "text": "21.6 函数转换\n到目前为止，我们主要关注了 dplyr 函数如何被转换成查询的子句。现 在我们将稍微深入一些，讨论与单个列一起工作的 R 函数的转换，例如，当你在summarize()中使用mean(x)时会发生什么？\n为了帮助我们了解正在发生的事情，我们将使用几个辅助函数来运行summarize()或mutate()并显示生成的 SQL。这 将使探索一些变体以及汇总和转换如何不同变得更加容易。\n\nsummarize_query &lt;- function(df, ...) {\n  df |&gt; \n    summarize(...) |&gt; \n    show_query()\n}\nmutate_query &lt;- function(df, ...) {\n  df |&gt; \n    mutate(..., .keep = \"none\") |&gt; \n    show_query()\n}\n\n让我们深入一些汇总！查 看下面的代码，你会注意到一些汇总函数，如mean()，其转换相对简单，而其他一些函数，如median()则复杂得多。这 种复杂性通常出现在统计学中常见但在数据库中不太常见的操作中。\n\nflights |&gt; \n  group_by(year, month, day) |&gt;  \n  summarize_query(\n    mean = mean(arr_delay, na.rm = TRUE),\n    median = median(arr_delay, na.rm = TRUE)\n  )\n#&gt; `summarise()` has grouped output by \"year\" and \"month\". You can override\n#&gt; using the `.groups` argument.\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   \"year\",\n#&gt;   \"month\",\n#&gt;   \"day\",\n#&gt;   AVG(arr_delay) AS mean,\n#&gt;   PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY arr_delay) AS median\n#&gt; FROM flights\n#&gt; GROUP BY \"year\", \"month\", \"day\"\n\n当在mutate()内部使用汇总函数时，其转换会变得更加复杂，因为它们需要变成所谓的窗口 (window) 函数。在 SQL 中，你可以通过在聚合函数后面添加OVER来将其转变为窗口函数：\n\nflights |&gt; \n  group_by(year, month, day) |&gt;  \n  mutate_query(\n    mean = mean(arr_delay, na.rm = TRUE),\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   \"year\",\n#&gt;   \"month\",\n#&gt;   \"day\",\n#&gt;   AVG(arr_delay) OVER (PARTITION BY \"year\", \"month\", \"day\") AS mean\n#&gt; FROM flights\n\n在 SQL 中，GROUP BY子句专门用于汇总，因此你可以看到分组已经从PARTITION BY参数移动到了OVER子句中。\n窗口函数包括所有向前或向后查看的函数，如lead()和lag()，它们分别查看“前一个”或“后一个”值：\n\nflights |&gt; \n  group_by(dest) |&gt;  \n  arrange(time_hour) |&gt; \n  mutate_query(\n    lead = lead(arr_delay),\n    lag = lag(arr_delay)\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   dest,\n#&gt;   LEAD(arr_delay, 1, NULL) OVER (PARTITION BY dest ORDER BY time_hour) AS lead,\n#&gt;   LAG(arr_delay, 1, NULL) OVER (PARTITION BY dest ORDER BY time_hour) AS lag\n#&gt; FROM flights\n#&gt; ORDER BY time_hour\n\n在这里，对数据进行arrange()排序是很重要的，因为 SQL 表没有固有的顺序。事 实上，如果不使用arrange()，你可能会每次得到不同顺序的行！请 注意，对于窗口函数排序信息是重复的：主查询的 ORDER BY 子句不会自动应用于窗口函数。\n另一个重要的 SQL 函数是 CASE WHEN。它 被用作if_else()和case_when()的翻译，这两个 dplyr 函数直接受到它的启发。这 里有几个简单的例子：\n\nflights |&gt; \n  mutate_query(\n    description = if_else(arr_delay &gt; 0, \"delayed\", \"on-time\")\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT CASE WHEN (arr_delay &gt; 0.0) THEN 'delayed' WHEN NOT (arr_delay &gt; 0.0) THEN 'on-time' END AS description\n#&gt; FROM flights\nflights |&gt; \n  mutate_query(\n    description = \n      case_when(\n        arr_delay &lt; -5 ~ \"early\", \n        arr_delay &lt; 5 ~ \"on-time\",\n        arr_delay &gt;= 5 ~ \"late\"\n      )\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT CASE\n#&gt; WHEN (arr_delay &lt; -5.0) THEN 'early'\n#&gt; WHEN (arr_delay &lt; 5.0) THEN 'on-time'\n#&gt; WHEN (arr_delay &gt;= 5.0) THEN 'late'\n#&gt; END AS description\n#&gt; FROM flights\n\nCASE WHEN 也用于一些没有从 R 到 SQL 直接翻译的函数。c ut()函数就是一个很好的例子：\n\nflights |&gt; \n  mutate_query(\n    description =  cut(\n      arr_delay, \n      breaks = c(-Inf, -5, 5, Inf), \n      labels = c(\"early\", \"on-time\", \"late\")\n    )\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT CASE\n#&gt; WHEN (arr_delay &lt;= -5.0) THEN 'early'\n#&gt; WHEN (arr_delay &lt;= 5.0) THEN 'on-time'\n#&gt; WHEN (arr_delay &gt; 5.0) THEN 'late'\n#&gt; END AS description\n#&gt; FROM flights\n\ndbplyr 还转换了常见的字符串和日期-时间处理函数，你可以在 vignette(\"translation-function\", package = \"dbplyr\") 了解到更多信息。d bplyr 的转换当然不是完美的，而且还有很多 R 函数尚未被转换，但 dbplyr 在涵盖你大部分时间都会使用的函数方面做得相当出色。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "databases.html#小结",
    "href": "databases.html#小结",
    "title": "21  数据库",
    "section": "21.7 小结",
    "text": "21.7 小结\n在本章中，你学习了如何从数据库中访问数据。我 们专注于 dbplyr，它是一个 dplyr 的“后端”，允许你编写你熟悉的 dplyr 代码并自动将其转换为 SQL。我 们利用这种转换来教你一点 SQL；学习一些 SQL 是很重要的，因为 SQL 是最常用于处理数据的语言，了解一些 SQL 将使你更容易与其他不使用 R 的数据专业人士交流。如 果你已经完成了本章并希望了解更多关于 SQL 的知识，我们有两个推荐：\n\nRenée M.P. Teate 的《SQL for Data Scientists》是一本专门为数据科学家设计的 SQL 入门书籍，包含了你在真实组织中可能遇到的高度互联数据的示例。\nAnthony DeBarros 的《Practical SQL》是从数据记者（专注于讲述引人入胜故事的数据科学家）的角度编写的，并详细介绍了如何将数据导入数据库以及运行自己的 DBMS。\n\n在下一章中，我们将学习使用另一个 dplyr 后端来处理大数据：arrow。A rrow 专为处理磁盘上的大文件而设计，是数据库的天然补充。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "databases.html#footnotes",
    "href": "databases.html#footnotes",
    "title": "21  数据库",
    "section": "",
    "text": "SQL 读作 “s”-“q”-“l” 或者读作 “sequel”。↩︎\n通常，这是你从客户端包中唯一需要使用的函数，因此我们建议使用::来提取这个函数，而不是使用library()来加载完整的软件包。↩︎\n令人困惑的是，根据上下文，SELECT既可以是语句也可以是子句。为 了避免这种混淆，我们通常会使用SELECT查询而不是SELECT语句。↩︎\n从技术上来说，只有SELECT是必需的，因为你可以编写像SELECT 1+1这样的查询来进行基本的计算。但 如果你想要处理数据（你总是这样做的！），你也需要一个FROM子句。↩︎\n这并非巧合:dplyr函数名称的灵感来自SQL子句。↩︎",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "arrow.html",
    "href": "arrow.html",
    "title": "22  Arrow",
    "section": "",
    "text": "22.1 引言\nCSV 文件设计得易于人类阅读。它 们是一种很好的交换格式，因为它们非常简单，并且可以被任何工具读取。但 是 CSV 文件并不是非常高效，你需要做很多工作才能将数据读入 R。在 本章中，你将了解一个强大的替代方案：parquet 格式，这是一种基于开放标准的大数据系统广泛使用的格式。\n我们将把 parquet 文件与 Apache Arrow 配对使用，Apache Arrow 是一个为大型数据集的高效分析和传输而设计的多语言工具箱。我 们将通过 arrow 包来使用 Apache Arrow，它提供了一个 dplyr 后端，允许你使用熟悉的 dplyr 语法来分析大于内存的数据集。作 为一个额外的优势，arrow 极其快速：你将在本章后面看到一些示例。\narrow 和 dbplyr 都提供了 dplyr 后端，所以你可能会想知道什么时候使用哪一个。在 许多情况下，这个选择已经为你做出了，因为数据已经存储在数据库中或 parquet 文件中，你会想要保持现状进行工作。但 是如果你从自己的数据（可能是 CSV 文件）开始，你可以将其加载到数据库中或将其转换为 parquet。一 般来说，很难知道哪种方法效果最好，所以在分析的早期阶段，我们鼓励你尝试两者，并选择最适合你的那一种。\n（特别感谢 Danielle Navarro 贡献了本章的初始版本。）",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#引言",
    "href": "arrow.html#引言",
    "title": "22  Arrow",
    "section": "",
    "text": "22.1.1 必要条件\n在本章中，我们将继续使用 tidyverse，特别是 dplyr，但我们将它与 arrow 包结合使用，arrow 包是专门为处理大数据而设计的。\n\nlibrary(tidyverse)\nlibrary(arrow)\n\n在本章的后面部分，我们还将看到 arrow 和 duckdb 之间的一些联系，因此我们还需要使用 dbplyr 和 duckdb。\n\nlibrary(dbplyr, warn.conflicts = FALSE)\nlibrary(duckdb)\n#&gt; Loading required package: DBI",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#获取数据",
    "href": "arrow.html#获取数据",
    "title": "22  Arrow",
    "section": "22.2 获取数据",
    "text": "22.2 获取数据\n我们首先获取一个值得使用这些工具的数据集：西雅图公共图书馆的图书借阅数据集，可以在线获取，地址为 data.seattle.gov/Community/Checkouts-by-Title/tmmm-ytt6。这 个数据集包含了 41,389,465 行数据，记录了从 2005 年 4 月到 2022 年 10 月每个月每本书的借阅次数。\n以下代码将为你获取数据的缓存副本。数 据是一个 9GB 的 CSV 文件，因此下载需要一些时间。我 强烈推荐使用 curl::multi_download() 来获取非常大的文件，因为它正是为此目的而构建的：它提供了一个进度条，并且如果下载中断，它可以恢复下载。\n\ndir.create(\"data\", showWarnings = FALSE)\n\ncurl::multi_download(\n  \"https://r4ds.s3.us-west-2.amazonaws.com/seattle-library-checkouts.csv\",\n  \"data/seattle-library-checkouts.csv\",\n  resume = TRUE\n)",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#打开数据集",
    "href": "arrow.html#打开数据集",
    "title": "22  Arrow",
    "section": "22.3 打开数据集",
    "text": "22.3 打开数据集\n首先来查看一下数据。由 于该文件有 9GB，足够大，因此我们可能不想将整个文件加载到内存中。一 个很好的经验法则是，你通常希望至少有数据大小两倍的内存，而许多笔记本电脑的内存容量上限为16GB。这 意味着我们要避免使用 read_csv()，而是使用 arrow::open_dataset()：\n\nseattle_csv &lt;- open_dataset(\n  sources = \"data/seattle-library-checkouts.csv\", \n  col_types = schema(ISBN = string()),\n  format = \"csv\"\n)\n\n运行这段代码时发生了什么？o pen_dataset() 会扫描几千行数据以确定数据集的结构。I SBN 列在前 80,000 行中包含空值，因此我们必须指定列类型以帮助 arrow 确定数据结构。一 旦 open_dataset() 扫描了数据，它就会记录所发现的内容并停止；只有当你特别请求时，它才会进一步读取其他行。如 果我们输出seattle_csv，所看到的正是这些元数据。\n\nseattle_csv\n#&gt; FileSystemDataset with 1 csv file\n#&gt; 12 columns\n#&gt; UsageClass: string\n#&gt; CheckoutType: string\n#&gt; MaterialType: string\n#&gt; CheckoutYear: int64\n#&gt; CheckoutMonth: int64\n#&gt; Checkouts: int64\n#&gt; Title: string\n#&gt; ISBN: string\n#&gt; Creator: string\n#&gt; Subjects: string\n#&gt; Publisher: string\n#&gt; PublicationYear: string\n\n输出的第一行告诉你 seattle_csv 作为单个 CSV 文件存储在本地磁盘上；它只会在需要时加载到内存中。输 出的其余部分告诉你 arrow 为每一列推断出的列类型。\n我们可以使用 glimpse() 来查看实际内容。这 会显示大约有 4100 万行和 12 列，并展示一些值。\n\nseattle_csv |&gt; glimpse()\n#&gt; FileSystemDataset with 1 csv file\n#&gt; 129,967 rows x 12 columns\n#&gt; $ UsageClass      &lt;string&gt; \"Physical\", \"Physical\", \"Digital\", \"Physical\", \"Ph…\n#&gt; $ CheckoutType    &lt;string&gt; \"Horizon\", \"Horizon\", \"OverDrive\", \"Horizon\", \"Hor…\n#&gt; $ MaterialType    &lt;string&gt; \"BOOK\", \"BOOK\", \"EBOOK\", \"BOOK\", \"SOUNDDISC\", \"BOO…\n#&gt; $ CheckoutYear     &lt;int64&gt; 2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016, 20…\n#&gt; $ CheckoutMonth    &lt;int64&gt; 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,…\n#&gt; $ Checkouts        &lt;int64&gt; 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 2, 3, 2, 1, 3, 2,…\n#&gt; $ Title           &lt;string&gt; \"Super rich : a guide to having it all / Russell S…\n#&gt; $ ISBN            &lt;string&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"…\n#&gt; $ Creator         &lt;string&gt; \"Simmons, Russell\", \"Barclay, James, 1965-\", \"Tim …\n#&gt; $ Subjects        &lt;string&gt; \"Self realization, Conduct of life, Attitude Psych…\n#&gt; $ Publisher       &lt;string&gt; \"Gotham Books,\", \"Pyr,\", \"Random House, Inc.\", \"Di…\n#&gt; $ PublicationYear &lt;string&gt; \"c2011.\", \"2010\", \"2015\", \"2005\", \"c2004.\", \"c2005…\n\n我们可以开始使用 dplyr 的函数来操作这个数据集，使用 collect() 来强制 arrow 执行计算并返回一些数据。例 如，以下代码会告诉我们每年图书的总借阅次数：\n\nseattle_csv |&gt; \n  group_by(CheckoutYear) |&gt; \n  summarise(Checkouts = sum(Checkouts)) |&gt; \n  arrange(CheckoutYear) |&gt; \n  collect()\n#&gt; # A tibble: 2 × 2\n#&gt;   CheckoutYear Checkouts\n#&gt;          &lt;int&gt;     &lt;int&gt;\n#&gt; 1         2016    411739\n#&gt; 2         2022         1\n\n由于使用了arrow，这段代码无论基础数据集有多大都能正常工作。但 目前的运行速度相当慢：在 Hadley 的电脑上，运行这段代码大约需要 10 秒。考 虑到我们处理的数据量，这不算太慢，但我们可以通过切换到更好的格式来使其更快。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#sec-parquet",
    "href": "arrow.html#sec-parquet",
    "title": "22  Arrow",
    "section": "22.4 parquet 格式",
    "text": "22.4 parquet 格式\n为了让这些数据更易于处理，我们将切换到 parquet 文件格式，并将其拆分成多个文件。接 下来的部分将首先向你介绍 parquet 和分区，然后将我们学到的知识应用于西雅图图书馆数据。\n\n22.4.1 parquet 的优势\n和 CSV 一样，parquet 用于矩形数据，但它不是任何文件编辑器都可以读取的文本格式，而是一个专门为大数据需求设计的自定义二进制格式。这 意味着：\n\nparquet 文件通常比等效的 CSV 文件小。Parquet 依赖于efficient encodings来减小文件大小，并支持文件压缩。这有助于使 parquet 文件更快，因为从磁盘移动到内存的数据更少。\nparquet 文件具有丰富的类型系统。正如我们在 小节 7.3 讨论的那样，CSV 文件不提供有关列类型的任何信息。例如CSV 阅读器必须猜测 \"08-10-2022\" 是否应被解析为字符串或日期。相反，parquet 文件以将数据与其类型一起记录的方式存储数据。\nparquet 文件是“面向列的”。这意味着它们是按列组织的，类似于 R 的数据框。与按行组织的 CSV 文件相比，这通常会导致数据分析任务具有更好的性能。\nparquet 文件是“分块的”，这使得可以在同一时间处理文件的不同部分，如果幸运的话，甚至可以完全跳过一些块。\n\nParquet 文件有一个主要缺点：它们不再是“人类可读”的，即如果你使用 readr::read_file() 查看 Parquet 文件，你将只能看到一堆乱码。\n\n\n22.4.2 分区\n随着数据集变得越来越大，将所有数据存储在一个文件中变得越来越困难，而且将大型数据集拆分成多个文件通常很有用。当 这种结构化操作进行得足够智能时，这种策略可以显著提高性能，因为许多分析只需要文件的一个子集。\n关于如何对你的数据集进行分区，没有严格的规定：结果将取决于你的数据、访问模式以及读取数据的系统。在 找到适合你的理想分区之前，可能需要进行一些实验。作 为粗略的指导，arrow 建议避免使用小于 20MB 和大于 2GB 的文件，并避免产生超过 10,000 个文件的分区。你 还应该尝试按你筛选的变量进行分区；如你稍后将看到的那样，这允许 arrow 仅读取相关文件，从而节省大量工作。\n\n\n22.4.3 重写西雅图图书馆数据\n让我们将这些想法应用于西雅图图书馆数据，以了解它们在实际操作中的表现。我 们将按 CheckoutYear 进行分区，因为某些分析可能只想查看最近的数据，并且按年份分区可以产生 18 个大小合理的块。\n为了重写数据，我们使用 dplyr::group_by() 定义分区，然后使用 arrow::write_dataset() 将分区保存到目录中。w rite_dataset() 有两个重要参数：一个是用于创建文件的目录，一个是将使用的文件格式。\n\npq_path &lt;- \"data/seattle-library-checkouts\"\n\n\nseattle_csv |&gt;\n  group_by(CheckoutYear) |&gt;\n  write_dataset(path = pq_path, format = \"parquet\")\n\n这大约需要一分钟来运行；正如我们稍后将看到的，这是一项初始投资，通过使未来的操作变得更快而得到回报。\n让我们来看看刚刚生成了什么：\n\ntibble(\n  files = list.files(pq_path, recursive = TRUE),\n  size_MB = file.size(file.path(pq_path, files)) / 1024^2\n)\n#&gt; # A tibble: 2 × 2\n#&gt;   files                             size_MB\n#&gt;   &lt;chr&gt;                               &lt;dbl&gt;\n#&gt; 1 CheckoutYear=2016/part-0.parquet 14.0    \n#&gt; 2 CheckoutYear=2022/part-0.parquet  0.00434\n\n我们原本 9GB 的 CSV 文件已经被重写为 18 个 parquet 文件。这 些文件名采用了 Apache Hive项目使用的“自描述”约定。H ive 风格的分区使用“key=value”约定来命名文件夹，所以正如你猜测的那样，名为 CheckoutYear=2005 的目录包含了所有 CheckoutYear 为 2005 的数据。每 个文件的大小在 100MB 到 300MB 之间，总大小现在大约是 4GB，略多于原始 CSV 文件大小的一半。这 是我们所期望的，因为 parquet 是一种更加高效的格式。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#使用-dplyr-与-arrow",
    "href": "arrow.html#使用-dplyr-与-arrow",
    "title": "22  Arrow",
    "section": "22.5 使用 dplyr 与 arrow",
    "text": "22.5 使用 dplyr 与 arrow\n现在我们已经创建了这些 parquet 文件，接下来我们需要再次读取它们。我 们再次使用 open_dataset()，但这次我们给它提供一个目录：\n\nseattle_pq &lt;- open_dataset(pq_path)\n\n现在我们可以编写我们的 dplyr 管道了。例 如，我们可以计算过去五年内每个月借出的书籍总数：\n\nquery &lt;- seattle_pq |&gt; \n  filter(CheckoutYear &gt;= 2018, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutYear, CheckoutMonth) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(CheckoutYear, CheckoutMonth)\n\n为 arrow 数据编写 dplyr 代码的概念与 章节 21 中的dbplyr 类似：你编写 dplyr 代码，这些代码会自动转换为 Apache Arrow C++ 库能够理解的查询，然后在调用 collect() 时执行。如 果我们输出查询对象，我们可以看到一些关于执行时我们期望 Arrow 返回的信息：\n\nquery\n#&gt; FileSystemDataset (query)\n#&gt; CheckoutYear: int32\n#&gt; CheckoutMonth: int64\n#&gt; TotalCheckouts: int64\n#&gt; \n#&gt; * Grouped by CheckoutYear\n#&gt; * Sorted by CheckoutYear [asc], CheckoutMonth [asc]\n#&gt; See $.data for the source Arrow object\n\n我们可以通过调用collect()来获取结果:\n\nquery |&gt; collect()\n#&gt; # A tibble: 0 × 3\n#&gt; # Groups:   CheckoutYear [0]\n#&gt; # ℹ 3 variables: CheckoutYear &lt;int&gt;, CheckoutMonth &lt;int&gt;,\n#&gt; #   TotalCheckouts &lt;int&gt;\n\n与 dbplyr 一样，arrow 只理解某些 R 表达式，因此你可能无法编写与通常完全一样的代码。但 是，所支持的操作和函数列表相当广泛且不断扩展；您可以在?acero中找到当前支持的函数的完整列表。\n\n22.5.1 性能\n让我们快速看一下从 CSV 切换到 parquet 对性能的影响。首 先，让我们计算一下当数据作为单个大型 CSV 存储时，计算 2021 年每个月借出的书籍数量所需的时间：\n\nseattle_csv |&gt; \n  filter(CheckoutYear == 2021, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutMonth) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(desc(CheckoutMonth)) |&gt;\n  collect() |&gt; \n  system.time()\n#&gt;    user  system elapsed \n#&gt;   0.065   0.004   0.065\n\n现在，让我们使用数据集的新版本，其中西雅图图书馆的借阅数据已经被分区为 18 个较小的 parquet 文件：\n\nseattle_pq |&gt; \n  filter(CheckoutYear == 2021, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutMonth) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(desc(CheckoutMonth)) |&gt;\n  collect() |&gt; \n  system.time()\n#&gt;    user  system elapsed \n#&gt;   0.018   0.002   0.022\n\n大约100倍性能的提升可归因于两个因素：多文件分区和单个文件的格式：\n\n分区提高了性能，因为这个查询使用 CheckoutYear == 2021 来筛选数据，而 arrow 足够智能，能够识别出它只需要读取 18 个 parquet 文件中的 1 个。\nparquet 格式提高了性能，因为它将数据以可以直接读入内存的二进制格式存储。列式格式和丰富的元数据意味着 arrow 只需要读取查询中实际使用的四列（CheckoutYear、MaterialType、CheckoutMonth 和 Checkouts）。\n\n这种性能上的巨大差异说明为什么将大型 CSV 转换为 parquet 是值得的！\n\n\n22.5.2 使用duckdb与arrow\nparquet 和 arrow 的最后一个优势是，通过调用arrow::to_duckdb()可以非常轻松地将arrow 数据集转换为 DuckDB 数据库（ 参见 章节 21 ）。\nThere’s one last advantage of parquet and arrow — it’s very easy to turn an arrow dataset into a DuckDB database (章节 21) by calling arrow::to_duckdb():\n\nseattle_pq |&gt; \n  to_duckdb() |&gt;\n  filter(CheckoutYear &gt;= 2018, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutYear) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(desc(CheckoutYear)) |&gt;\n  collect()\n#&gt; Warning: Missing values are always removed in SQL aggregation functions.\n#&gt; Use `na.rm = TRUE` to silence this warning\n#&gt; This warning is displayed once every 8 hours.\n#&gt; # A tibble: 0 × 2\n#&gt; # ℹ 2 variables: CheckoutYear &lt;int&gt;, TotalCheckouts &lt;dbl&gt;\n\nto_duckdb()的巧妙之处在于，这种转换不涉及任何内存复制，并体现了 arrow 生态系统的目标：实现从一个计算环境到另一个计算环境的无缝过渡。\n\n\n22.5.3 练习\n\n找出每年最受欢迎的书。\n西雅图图书馆系统中哪位作者的书最多？\n在过去的10年里，纸质书与电子书的借阅情况是如何变化的？",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#小结",
    "href": "arrow.html#小结",
    "title": "22  Arrow",
    "section": "22.6 小结",
    "text": "22.6 小结\n在本章中，你已经初步了解了arrow包，它提供了用于处理大型磁盘上数据集的 dplyr 后端。它 可以处理 CSV 文件，但如果您将数据转换为 parquet 格式，它会快得多。P arquet 是一种二进制数据格式，专为现代计算机上的数据分析而设计。与 CSV 相比，能够处理 parquet 文件的工具要少得多，但其分区、压缩和列式存储结构使得分析更加高效。\n接下来，您将学习关于第一个非矩形数据源的知识，您将使用 tidyr 包提供的工具来处理它。我 们将重点关注来自 JSON 文件的数据，但一般原则适用于任何来源的树状数据。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "rectangling.html",
    "href": "rectangling.html",
    "title": "23  层次数据",
    "section": "",
    "text": "23.1 引言\n在这一章中，你将学习数据规整 (data rectangling) 的艺术：将本质上具有层次结构或树形结构的数据转换为由行和列组成的矩形数据框。这 一点非常重要，因为层次结构数据非常普遍，特别是在处理来自网络的数据时。\n为了学习数据规整，你首先需要了解列表，这种数据结构使得层次结构数据成为可能。接 着，你将学习两个关键的tidyr包函数：tidyr::unnest_longer()和tidyr::unnest_wider()。然 后，我们将向你展示几个案例研究，反复使用这些简单的函数来解决实际问题。最 后，我们将讨论JSON，它是层次数据集最常见的来源，也是网络上数据交换的一种常见格式。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>层次数据</span>"
    ]
  },
  {
    "objectID": "rectangling.html#引言",
    "href": "rectangling.html#引言",
    "title": "23  层次数据",
    "section": "",
    "text": "23.1.1 必要条件\n在本章中，我们将使用tidyverse核心成员之一的tidyr包中的许多函数。我 们还将使用repurrrsive来提供一些有趣的数据集以进行规整练习，最后我们将使用jsonlite来将JSON文件读取为R中的列表。\n\nlibrary(tidyverse)\nlibrary(repurrrsive)\nlibrary(jsonlite)",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>层次数据</span>"
    ]
  },
  {
    "objectID": "rectangling.html#列表",
    "href": "rectangling.html#列表",
    "title": "23  层次数据",
    "section": "23.2 列表",
    "text": "23.2 列表\n到目前为止，你已经使用包含简单向量（如整数、数字、字符、日期-时间以及因子）的数据框进行了工作。这 些向量之所以简单，是因为它们是同质的，每个元素都是相同的数据类型。如 果想在同一向量中存储不同类型的元素，你将需要一个列表，使用list()函数来创建它。\n\nx1 &lt;- list(1:4, \"a\", TRUE)\nx1\n#&gt; [[1]]\n#&gt; [1] 1 2 3 4\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"a\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] TRUE\n\n给列表的元素或子项命名通常很方便，您可以像给tibble的列命名一样进行此操作：\n\nx2 &lt;- list(a = 1:2, b = 1:3, c = 1:4)\nx2\n#&gt; $a\n#&gt; [1] 1 2\n#&gt; \n#&gt; $b\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $c\n#&gt; [1] 1 2 3 4\n\n即使对于这些非常简单的列表，输出也会占用相当多的空间。一 个有用的替代方法是str()函数，它生成结构的紧凑显示，减少对内容的强调：\n\nstr(x1)\n#&gt; List of 3\n#&gt;  $ : int [1:4] 1 2 3 4\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi TRUE\nstr(x2)\n#&gt; List of 3\n#&gt;  $ a: int [1:2] 1 2\n#&gt;  $ b: int [1:3] 1 2 3\n#&gt;  $ c: int [1:4] 1 2 3 4\n\n正如你所看到的，str()在单独的行上显示列表的每个元素。如 果元素有名称，它会先显示名称 (如果有)，然后是类型的缩写，然后是前几个值。\n\n23.2.1 分层\n列表可以包含任何类型的对象，包括其他列表。 这使得它们适合表示层次(树状)结构：\n\nx3 &lt;- list(list(1, 2), list(3, 4))\nstr(x3)\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 3\n#&gt;   ..$ : num 4\n\n这与c()函数明显不同，因为c()生成的是一个扁平化的向量：\n\nc(c(1, 2), c(3, 4))\n#&gt; [1] 1 2 3 4\n\nx4 &lt;- c(list(1, 2), list(3, 4))\nstr(x4)\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\n列表变得更复杂，str()就会变得更有用，因为它能让你一眼就看到层次结构：\n\nx5 &lt;- list(1, list(2, list(3, list(4, list(5)))))\nstr(x5)\n#&gt; List of 2\n#&gt;  $ : num 1\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 2\n#&gt;   ..$ :List of 2\n#&gt;   .. ..$ : num 3\n#&gt;   .. ..$ :List of 2\n#&gt;   .. .. ..$ : num 4\n#&gt;   .. .. ..$ :List of 1\n#&gt;   .. .. .. ..$ : num 5\n\n当列表变得更大和更复杂时，str()最终会开始失效，这时你需要切换到View()1。 图 23.1 展示了调用View(x5)的结果。 查看器首先只显示列表的顶层，但你可以交互地展开任何元素以查看更多内容，如 图 23.2 所示。 RStudio 还会显示你需要访问该元素的代码，如 图 23.3 所示。 我们将在 小节 27.3 查看这段代码是如何工作的。\n\n\n\n\n\n\n\n\n图 23.1: The RStudio view lets you interactively explore a complex list. The viewer opens showing only the top level of the list.\n\n\n\n\n\n\n\n\n\n\n\n\n\n图 23.2: Clicking on the rightward facing triangle expands that component of the list so that you can also see its children.\n\n\n\n\n\n\n\n\n\n\n\n\n\n图 23.3: You can repeat this operation as many times as needed to get to the data you’re interested in. Note the bottom-left corner: if you click an element of the list, RStudio will give you the subsetting code needed to access it, in this case x5[[2]][[2]][[2]].\n\n\n\n\n\n\n\n23.2.2 列表列\n列表也可存在于tibble中，我们称其为列表列 (list-columns)。 列表列很有用，因为它们允许你将通常不属于tibble的对象放置在其中。特 别是，在 tidymodels 生态系统中列表列被广泛使用，因为它们允许你在数据框中存储模型的输出或重采样等数据。\n下面是一个列表列的简单示例：\n\ndf &lt;- tibble(\n  x = 1:2, \n  y = c(\"a\", \"b\"),\n  z = list(list(1, 2), list(3, 4, 5))\n)\ndf\n#&gt; # A tibble: 2 × 3\n#&gt;       x y     z         \n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;list&gt;    \n#&gt; 1     1 a     &lt;list [2]&gt;\n#&gt; 2     2 b     &lt;list [3]&gt;\n\n代码中的列表没有什么特别之处，它们的行为和其他列一样:\n\ndf |&gt; \n  filter(x == 1)\n#&gt; # A tibble: 1 × 3\n#&gt;       x y     z         \n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;list&gt;    \n#&gt; 1     1 a     &lt;list [2]&gt;\n\n处理列表列比较困难，这是因为利用列表进行计算通常就比较困难；我们将会在 章节 26 回到这个话题。在 本章，我们将专注于将列表列展开为常规变量，这样你就可以使用现有的工具来处理它们。\n默认的输出方法只是显示内容的大致汇总。列 表列可能非常复杂，因此没有很好的输出方式。如 果你想查看它，需要单独提取出列表列，并应用你已经学过的某种方法，比如df |&gt; pull(z) |&gt; str() 或 df |&gt; pull(z) |&gt; View()。\n\n\n\n\n\n\n基础 R\n\n\n\n可以将列表放入数据框的某一列中，但这样做会比较繁琐，因为data.frame()函数将列表视为列的列表:\n\ndata.frame(x = list(1:3, 3:5))\n#&gt;   x.1.3 x.3.5\n#&gt; 1     1     3\n#&gt; 2     2     4\n#&gt; 3     3     5\n\n你可以通过将列表封装在I()函数中来强制data.frame()将列表视为行的列表，但这样得到的结果输出效果并不好：\n\ndata.frame(\n  x = I(list(1:2, 3:5)), \n  y = c(\"1, 2\", \"3, 4, 5\")\n)\n#&gt;         x       y\n#&gt; 1    1, 2    1, 2\n#&gt; 2 3, 4, 5 3, 4, 5\n\n使用tibble中的列表列更为简单，因为tibble()将列表视为向量，并且输出方法也是专门为处理列表而设计的。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>层次数据</span>"
    ]
  },
  {
    "objectID": "rectangling.html#解嵌套",
    "href": "rectangling.html#解嵌套",
    "title": "23  层次数据",
    "section": "23.3 解嵌套",
    "text": "23.3 解嵌套\n现在你已经学习了列表和列表列的基础知识，让我们来探索如何将它们转回为常规的行和列。在 这里，我们将使用非常简单的示例数据来帮助你理解基本概念；在下一节中，我们将切换到真实的数据。\n列表列通常有两种基本形式：命名和未命名。当 元素被命名时，它们往往在每一行中都有相同的名称。例 如，在df1中，列表列y的每一个元素都有两个名为a和b的元素。命 名的列表列自然地被解嵌套 (unnest) 为列：每个命名的元素都会变成一个新的命名列。\n\ndf1 &lt;- tribble(\n  ~x, ~y,\n  1, list(a = 11, b = 12),\n  2, list(a = 21, b = 22),\n  3, list(a = 31, b = 32),\n)\n\n当元素未被命名时，元素的数量往往因行而异。例 如，在df2中，列表列y的元素未被命名，且长度从一到三不等。未 命名的列表列自然会解嵌套为行：你会为每个元素得到一行。\n\n\ndf2 &lt;- tribble(\n  ~x, ~y,\n  1, list(11, 12, 13),\n  2, list(21),\n  3, list(31, 32),\n)\n\ntidyr包为这两种情况提供了两个函数：unnest_wider()和unnest_longer()。以 下部分将解释它们是如何工作的。\n\n23.3.1 unnest_wider()\n当每一行都有相同数量且名称相同的元素时，就像df1一样，很自然地将每个组件放入它自己的列中，这可以通过使用unnest_wider()来实现：\n\ndf1 |&gt; \n  unnest_wider(y)\n#&gt; # A tibble: 3 × 3\n#&gt;       x     a     b\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    11    12\n#&gt; 2     2    21    22\n#&gt; 3     3    31    32\n\n默认情况下，新列的名称仅来自列表元素的名称，但你可以使用names_sep参数来请求将列名和元素名组合起来。这 在消除重复名称的歧义时很有用。\n\ndf1 |&gt; \n  unnest_wider(y, names_sep = \"_\")\n#&gt; # A tibble: 3 × 3\n#&gt;       x   y_a   y_b\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    11    12\n#&gt; 2     2    21    22\n#&gt; 3     3    31    32\n\n\n\n23.3.2 unnest_longer()\n当每一行都包含一个未命名的列表时，最自然的做法是将每个元素放入它自己的行中，这可以通过使用unnest_longer()来实现：\n\ndf2 |&gt; \n  unnest_longer(y)\n#&gt; # A tibble: 6 × 2\n#&gt;       x     y\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    11\n#&gt; 2     1    12\n#&gt; 3     1    13\n#&gt; 4     2    21\n#&gt; 5     3    31\n#&gt; 6     3    32\n\n请注意，对于y中的每个元素x都被重复了：我们为列表列中的每个元素都输出了一行。但 是，如果其中一个元素是空的，就像下面的例子那样，会发生什么呢？\n\ndf6 &lt;- tribble(\n  ~x, ~y,\n  \"a\", list(1, 2),\n  \"b\", list(3),\n  \"c\", list()\n)\ndf6 |&gt; unnest_longer(y)\n#&gt; # A tibble: 3 × 2\n#&gt;   x         y\n#&gt;   &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 a         1\n#&gt; 2 a         2\n#&gt; 3 b         3\n\n在输出中，我们会得到零行，所以那一行实际上会消失。如 果你想要保留那一行，可以在y中添加NA，并设置keep_empty = TRUE。\nWe get zero rows in the output, so the row effectively disappears. If you want to preserve that row, adding NA in y, set keep_empty = TRUE.\n\n\n23.3.3 类型不一致\n如果你解嵌套一个包含不同类型向量的列表列，会发生什么？例 如，考虑以下数据集，其中列表列y包含两个数字、一个字符和一个逻辑值，它们通常不能混合在同一个列中。\n\ndf4 &lt;- tribble(\n  ~x, ~y,\n  \"a\", list(1),\n  \"b\", list(\"a\", TRUE, 5)\n)\n\nunnest_longer()总是保持列集不变，同时改变行数。那 么这时会发生什么呢？u nnest_longer()是如何在保持y中所有内容的同时产生五行的呢？\n\ndf4 |&gt; \n  unnest_longer(y)\n#&gt; # A tibble: 4 × 2\n#&gt;   x     y        \n#&gt;   &lt;chr&gt; &lt;list&gt;   \n#&gt; 1 a     &lt;dbl [1]&gt;\n#&gt; 2 b     &lt;chr [1]&gt;\n#&gt; 3 b     &lt;lgl [1]&gt;\n#&gt; 4 b     &lt;dbl [1]&gt;\n\n如你所见，输出包含了一个列表列，但列表列的每个元素都包含一个单一元素。因 为unnest_longer()不能找到一个通用的向量类型，所以它保留了列表列中的原始类型。你 可能会想，这是否违反了列中每个元素都必须是相同类型的规则。其 实并没有：每个元素都是一个列表，尽管它们的内容类型不同。\n处理不一致的类型是一个挑战，具体细节取决于问题的本质和你的目标，但你最有可能需要来自 章节 26 的工具。\n\n\n23.3.4 其他函数\ntidyr还有一些其他有用的规整函数，我们不打算在本书中介绍：\n\nunnest_auto()根据列表列的结构自动选择使用unnest_longer()还是unnest_wider()。这对于快速探索非常有用，但最终不是一个好主意，因为它不会迫使你了解你的数据结构，并且会让你的代码更难理解。\nunnest()同时扩展行和列。当你有一个列表列，它包含二维结构（如数据框）时，这个函数很有用，虽然你在本书中看不到这种情况，但如果你使用 tidymodels 生态系统，可能会遇到它。\n\n了解这些函数是很有必要的，因为当你在阅读其他人代码或自己解决一些不太常见的数据规整挑战时可能会遇到它们。\n\n\n23.3.5 练习\n\n当你对像df2这样的未命名列表列使用unnest_wider()时会发生什么？现 在需要哪个参数？缺 失值会如何处理？\n当你对像df1这样的命名列表列使用unnest_longer()时会发生什么？输 出中你会得到哪些额外的信息？如 何抑制这些额外的信息？\n你会时不时地遇到包含多个列表列且值相互对应的数据框。例 如，在以下数据框中y和z的值是对应的（即每行中y和z的长度总是相同，y的第一个值对应于z的第一个值）。如 果你对这个数据框连续使用两次unnest_longer()调用会发生什么？如 何保持x和y之间的关系？( 提示: 仔细阅读文档)。\n\ndf4 &lt;- tribble(\n  ~x, ~y, ~z,\n  \"a\", list(\"y-a-1\", \"y-a-2\"), list(\"z-a-1\", \"z-a-2\"),\n  \"b\", list(\"y-b-1\", \"y-b-2\", \"y-b-3\"), list(\"z-b-1\", \"z-b-2\", \"z-b-3\")\n)",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>层次数据</span>"
    ]
  },
  {
    "objectID": "rectangling.html#案例研究",
    "href": "rectangling.html#案例研究",
    "title": "23  层次数据",
    "section": "23.4 案例研究",
    "text": "23.4 案例研究\n我们上面使用的简单示例与真实数据之间的主要区别在于，真实数据通常包含多个嵌套级别，这需要多次调用unnest_longer()和/或unnest_wider()。为 了展示这一点，本节将通过使用repurrrsive包中的数据集解决三个真实的规整挑战。\n\n23.4.1 很宽的数据\n我们将从gh_repos开始。这 是一个列表，其中包含使用GitHub API检索的一组GitHub存储库的数据。它 是一个深度嵌套的列表，因此在本书中很难展示其结构；我们建议在继续之前，你自己使用View(gh_repos)稍微探索一下。\ngh_repos是一个列表，但我们的工具处理的是列表列，所以我们首先将其放入一个tibble中。我 们将其列命名为json，稍后我们会解释原因。\n\nrepos &lt;- tibble(json = gh_repos)\nrepos\n#&gt; # A tibble: 6 × 1\n#&gt;   json       \n#&gt;   &lt;list&gt;     \n#&gt; 1 &lt;list [30]&gt;\n#&gt; 2 &lt;list [30]&gt;\n#&gt; 3 &lt;list [30]&gt;\n#&gt; 4 &lt;list [26]&gt;\n#&gt; 5 &lt;list [30]&gt;\n#&gt; 6 &lt;list [30]&gt;\n\n这个tibble包含6行，每一行对应gh_repos的一个元素。每 一行包含一个未命名的列表，该列表包含26行或30行。由 于这些列表是未命名的，我们将首先使用unnest_longer()将每个子元素放在它自己的行中：\n\nrepos |&gt; \n  unnest_longer(json)\n#&gt; # A tibble: 176 × 1\n#&gt;   json             \n#&gt;   &lt;list&gt;           \n#&gt; 1 &lt;named list [68]&gt;\n#&gt; 2 &lt;named list [68]&gt;\n#&gt; 3 &lt;named list [68]&gt;\n#&gt; 4 &lt;named list [68]&gt;\n#&gt; 5 &lt;named list [68]&gt;\n#&gt; 6 &lt;named list [68]&gt;\n#&gt; # ℹ 170 more rows\n\n乍一看，情况似乎并没有改善：虽然我们有了更多的行（从6行增加到176行），但json中的每个元素仍然是一个列表。然 而，有一个重要的区别：现在每个元素都是一个命名列表，因此我们可以使用unnest_wider()将每个元素放入它自己的列中。\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) \n#&gt; # A tibble: 176 × 68\n#&gt;         id name        full_name         owner        private html_url       \n#&gt;      &lt;int&gt; &lt;chr&gt;       &lt;chr&gt;             &lt;list&gt;       &lt;lgl&gt;   &lt;chr&gt;          \n#&gt; 1 61160198 after       gaborcsardi/after &lt;named list&gt; FALSE   https://github…\n#&gt; 2 40500181 argufy      gaborcsardi/argu… &lt;named list&gt; FALSE   https://github…\n#&gt; 3 36442442 ask         gaborcsardi/ask   &lt;named list&gt; FALSE   https://github…\n#&gt; 4 34924886 baseimports gaborcsardi/base… &lt;named list&gt; FALSE   https://github…\n#&gt; 5 61620661 citest      gaborcsardi/cite… &lt;named list&gt; FALSE   https://github…\n#&gt; 6 33907457 clisymbols  gaborcsardi/clis… &lt;named list&gt; FALSE   https://github…\n#&gt; # ℹ 170 more rows\n#&gt; # ℹ 62 more variables: description &lt;chr&gt;, fork &lt;lgl&gt;, url &lt;chr&gt;, …\n\n这个方法奏效了，但结果有点令人眼花缭乱：列太多了，tibble甚至没有全部输出！我 们可以用names()函数查看所有列；这里我们查看前10列：\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) |&gt; \n  names() |&gt; \n  head(10)\n#&gt;  [1] \"id\"          \"name\"        \"full_name\"   \"owner\"       \"private\"    \n#&gt;  [6] \"html_url\"    \"description\" \"fork\"        \"url\"         \"forks_url\"\n\n让我们挑选一些看起来很有趣的:\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) |&gt; \n  select(id, full_name, owner, description)\n#&gt; # A tibble: 176 × 4\n#&gt;         id full_name               owner             description             \n#&gt;      &lt;int&gt; &lt;chr&gt;                   &lt;list&gt;            &lt;chr&gt;                   \n#&gt; 1 61160198 gaborcsardi/after       &lt;named list [17]&gt; Run Code in the Backgro…\n#&gt; 2 40500181 gaborcsardi/argufy      &lt;named list [17]&gt; Declarative function ar…\n#&gt; 3 36442442 gaborcsardi/ask         &lt;named list [17]&gt; Friendly CLI interactio…\n#&gt; 4 34924886 gaborcsardi/baseimports &lt;named list [17]&gt; Do we get warnings for …\n#&gt; 5 61620661 gaborcsardi/citest      &lt;named list [17]&gt; Test R package and repo…\n#&gt; 6 33907457 gaborcsardi/clisymbols  &lt;named list [17]&gt; Unicode symbols for CLI…\n#&gt; # ℹ 170 more rows\n\n你可以利用这个信息反推gh_repos的结构：每个元素都是一个GitHub用户，包含他们创建的最多30个GitHub存储库的列表。\nowner是另一个列表列，因为它包含了一个命名列表，所以我们可以使用unnest_wider()来获取这些值：\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) |&gt; \n  select(id, full_name, owner, description) |&gt; \n  unnest_wider(owner)\n#&gt; Error in `unnest_wider()`:\n#&gt; ! Can't duplicate names between the affected columns and the original\n#&gt;   data.\n#&gt; ✖ These names are duplicated:\n#&gt;   ℹ `id`, from `owner`.\n#&gt; ℹ Use `names_sep` to disambiguate using the column name.\n#&gt; ℹ Or use `names_repair` to specify a repair strategy.\n\n呃，这个列表列也包含一个id列，而我们不能在同一数据框中有两个id列。正 如建议的那样，让我们使用names_sep来解决这个问题：\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) |&gt; \n  select(id, full_name, owner, description) |&gt; \n  unnest_wider(owner, names_sep = \"_\")\n#&gt; # A tibble: 176 × 20\n#&gt;         id full_name               owner_login owner_id owner_avatar_url     \n#&gt;      &lt;int&gt; &lt;chr&gt;                   &lt;chr&gt;          &lt;int&gt; &lt;chr&gt;                \n#&gt; 1 61160198 gaborcsardi/after       gaborcsardi   660288 https://avatars.gith…\n#&gt; 2 40500181 gaborcsardi/argufy      gaborcsardi   660288 https://avatars.gith…\n#&gt; 3 36442442 gaborcsardi/ask         gaborcsardi   660288 https://avatars.gith…\n#&gt; 4 34924886 gaborcsardi/baseimports gaborcsardi   660288 https://avatars.gith…\n#&gt; 5 61620661 gaborcsardi/citest      gaborcsardi   660288 https://avatars.gith…\n#&gt; 6 33907457 gaborcsardi/clisymbols  gaborcsardi   660288 https://avatars.gith…\n#&gt; # ℹ 170 more rows\n#&gt; # ℹ 15 more variables: owner_gravatar_id &lt;chr&gt;, owner_url &lt;chr&gt;, …\n\n这给出了另一个宽数据集，但你可以感觉到owner似乎包含了很多关于“拥有”存储库的人的额外数据。\n\n\n23.4.2 关系型数据\n嵌套数据有时被用于表示分散在多个数据框中的数据。例 如，got_chars包含有关在《权力的游戏》书籍和电视剧中出现的角色数据。和 gh_repos一样，它是一个列表，所以我们首先将其转换为一个tibble的列表列：\n\nchars &lt;- tibble(json = got_chars)\nchars\n#&gt; # A tibble: 30 × 1\n#&gt;   json             \n#&gt;   &lt;list&gt;           \n#&gt; 1 &lt;named list [18]&gt;\n#&gt; 2 &lt;named list [18]&gt;\n#&gt; 3 &lt;named list [18]&gt;\n#&gt; 4 &lt;named list [18]&gt;\n#&gt; 5 &lt;named list [18]&gt;\n#&gt; 6 &lt;named list [18]&gt;\n#&gt; # ℹ 24 more rows\n\njson列包含具有名称的元素，因此我们首先将其拓宽：\n\nchars |&gt; \n  unnest_wider(json)\n#&gt; # A tibble: 30 × 18\n#&gt;   url                    id name            gender culture    born           \n#&gt;   &lt;chr&gt;               &lt;int&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;          \n#&gt; 1 https://www.anapio…  1022 Theon Greyjoy   Male   \"Ironborn\" \"In 278 AC or …\n#&gt; 2 https://www.anapio…  1052 Tyrion Lannist… Male   \"\"         \"In 273 AC, at…\n#&gt; 3 https://www.anapio…  1074 Victarion Grey… Male   \"Ironborn\" \"In 268 AC or …\n#&gt; 4 https://www.anapio…  1109 Will            Male   \"\"         \"\"             \n#&gt; 5 https://www.anapio…  1166 Areo Hotah      Male   \"Norvoshi\" \"In 257 AC or …\n#&gt; 6 https://www.anapio…  1267 Chett           Male   \"\"         \"At Hag's Mire\"\n#&gt; # ℹ 24 more rows\n#&gt; # ℹ 12 more variables: died &lt;chr&gt;, alive &lt;lgl&gt;, titles &lt;list&gt;, …\n\n然后选择几列以便更容易阅读：\n\ncharacters &lt;- chars |&gt; \n  unnest_wider(json) |&gt; \n  select(id, name, gender, culture, born, died, alive)\ncharacters\n#&gt; # A tibble: 30 × 7\n#&gt;      id name              gender culture    born              died           \n#&gt;   &lt;int&gt; &lt;chr&gt;             &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;             &lt;chr&gt;          \n#&gt; 1  1022 Theon Greyjoy     Male   \"Ironborn\" \"In 278 AC or 27… \"\"             \n#&gt; 2  1052 Tyrion Lannister  Male   \"\"         \"In 273 AC, at C… \"\"             \n#&gt; 3  1074 Victarion Greyjoy Male   \"Ironborn\" \"In 268 AC or be… \"\"             \n#&gt; 4  1109 Will              Male   \"\"         \"\"                \"In 297 AC, at…\n#&gt; 5  1166 Areo Hotah        Male   \"Norvoshi\" \"In 257 AC or be… \"\"             \n#&gt; 6  1267 Chett             Male   \"\"         \"At Hag's Mire\"   \"In 299 AC, at…\n#&gt; # ℹ 24 more rows\n#&gt; # ℹ 1 more variable: alive &lt;lgl&gt;\n\n该数据集也包含许多列表列:\n\nchars |&gt; \n  unnest_wider(json) |&gt; \n  select(id, where(is.list))\n#&gt; # A tibble: 30 × 8\n#&gt;      id titles    aliases    allegiances books     povBooks tvSeries playedBy\n#&gt;   &lt;int&gt; &lt;list&gt;    &lt;list&gt;     &lt;list&gt;      &lt;list&gt;    &lt;list&gt;   &lt;list&gt;   &lt;list&gt;  \n#&gt; 1  1022 &lt;chr [2]&gt; &lt;chr [4]&gt;  &lt;chr [1]&gt;   &lt;chr [3]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 2  1052 &lt;chr [2]&gt; &lt;chr [11]&gt; &lt;chr [1]&gt;   &lt;chr [2]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 3  1074 &lt;chr [2]&gt; &lt;chr [1]&gt;  &lt;chr [1]&gt;   &lt;chr [3]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 4  1109 &lt;chr [1]&gt; &lt;chr [1]&gt;  &lt;NULL&gt;      &lt;chr [1]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 5  1166 &lt;chr [1]&gt; &lt;chr [1]&gt;  &lt;chr [1]&gt;   &lt;chr [3]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 6  1267 &lt;chr [1]&gt; &lt;chr [1]&gt;  &lt;NULL&gt;      &lt;chr [2]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; # ℹ 24 more rows\n\n让我们探索titles列。它 是一个未命名的列表列，因此我们将它展开成行：\n\nchars |&gt; \n  unnest_wider(json) |&gt; \n  select(id, titles) |&gt; \n  unnest_longer(titles)\n#&gt; # A tibble: 59 × 2\n#&gt;      id titles                                              \n#&gt;   &lt;int&gt; &lt;chr&gt;                                               \n#&gt; 1  1022 Prince of Winterfell                                \n#&gt; 2  1022 Lord of the Iron Islands (by law of the green lands)\n#&gt; 3  1052 Acting Hand of the King (former)                    \n#&gt; 4  1052 Master of Coin (former)                             \n#&gt; 5  1074 Lord Captain of the Iron Fleet                      \n#&gt; 6  1074 Master of the Iron Victory                          \n#&gt; # ℹ 53 more rows\n\n你可能希望看到这个数据放在它自己的表中，因为当需要时它们可以很容易地与角色数据连接起来。我 们来做这个操作，这需要很少的清理工作：移除包含空字符串的行，并将titles重命名为title，因为现在每行只包含一个标题。\n\ntitles &lt;- chars |&gt; \n  unnest_wider(json) |&gt; \n  select(id, titles) |&gt; \n  unnest_longer(titles) |&gt; \n  filter(titles != \"\") |&gt; \n  rename(title = titles)\ntitles\n#&gt; # A tibble: 52 × 2\n#&gt;      id title                                               \n#&gt;   &lt;int&gt; &lt;chr&gt;                                               \n#&gt; 1  1022 Prince of Winterfell                                \n#&gt; 2  1022 Lord of the Iron Islands (by law of the green lands)\n#&gt; 3  1052 Acting Hand of the King (former)                    \n#&gt; 4  1052 Master of Coin (former)                             \n#&gt; 5  1074 Lord Captain of the Iron Fleet                      \n#&gt; 6  1074 Master of the Iron Victory                          \n#&gt; # ℹ 46 more rows\n\n你可以想象为每一个列表列创建像这样的表，然后根据需要，使用连接操作将它们与角色数据结合起来。\n\n\n23.4.3 深度嵌套\n我们将以一个深度嵌套的列表列作为这些案例研究的结尾，这需要反复使用unnest_wider()和unnest_longer()函数来展开。g maps_cities是一个包含两列的 tibble，包含五个城市名称以及使用谷歌地理编码API确定的城市位置：\n\ngmaps_cities\n#&gt; # A tibble: 5 × 2\n#&gt;   city       json            \n#&gt;   &lt;chr&gt;      &lt;list&gt;          \n#&gt; 1 Houston    &lt;named list [2]&gt;\n#&gt; 2 Washington &lt;named list [2]&gt;\n#&gt; 3 New York   &lt;named list [2]&gt;\n#&gt; 4 Chicago    &lt;named list [2]&gt;\n#&gt; 5 Arlington  &lt;named list [2]&gt;\n\njson是一个具有内部名称的列表列，因此我们先从unnest_wider()开始：\n\ngmaps_cities |&gt; \n  unnest_wider(json)\n#&gt; # A tibble: 5 × 3\n#&gt;   city       results    status\n#&gt;   &lt;chr&gt;      &lt;list&gt;     &lt;chr&gt; \n#&gt; 1 Houston    &lt;list [1]&gt; OK    \n#&gt; 2 Washington &lt;list [2]&gt; OK    \n#&gt; 3 New York   &lt;list [1]&gt; OK    \n#&gt; 4 Chicago    &lt;list [1]&gt; OK    \n#&gt; 5 Arlington  &lt;list [2]&gt; OK\n\n这给我们提供了 status 和 results 两个变量。由 于它们都是OK状态，所以可以删除状态列；在真实的分析中，你还希望捕获所有status != \"OK\"的行，并找出哪里出了问题。r esults是一个未命名的列表，包含一个或两个元素（我们稍后会看到原因），因此我们将它展开成行：\n\ngmaps_cities |&gt; \n  unnest_wider(json) |&gt; \n  select(-status) |&gt; \n  unnest_longer(results)\n#&gt; # A tibble: 7 × 2\n#&gt;   city       results         \n#&gt;   &lt;chr&gt;      &lt;list&gt;          \n#&gt; 1 Houston    &lt;named list [5]&gt;\n#&gt; 2 Washington &lt;named list [5]&gt;\n#&gt; 3 Washington &lt;named list [5]&gt;\n#&gt; 4 New York   &lt;named list [5]&gt;\n#&gt; 5 Chicago    &lt;named list [5]&gt;\n#&gt; 6 Arlington  &lt;named list [5]&gt;\n#&gt; # ℹ 1 more row\n\n现在 results 是一个命名的列表, 所以使用 unnest_wider():\n\nlocations &lt;- gmaps_cities |&gt; \n  unnest_wider(json) |&gt; \n  select(-status) |&gt; \n  unnest_longer(results) |&gt; \n  unnest_wider(results)\nlocations\n#&gt; # A tibble: 7 × 6\n#&gt;   city       address_components formatted_address   geometry        \n#&gt;   &lt;chr&gt;      &lt;list&gt;             &lt;chr&gt;               &lt;list&gt;          \n#&gt; 1 Houston    &lt;list [4]&gt;         Houston, TX, USA    &lt;named list [4]&gt;\n#&gt; 2 Washington &lt;list [2]&gt;         Washington, USA     &lt;named list [4]&gt;\n#&gt; 3 Washington &lt;list [4]&gt;         Washington, DC, USA &lt;named list [4]&gt;\n#&gt; 4 New York   &lt;list [3]&gt;         New York, NY, USA   &lt;named list [4]&gt;\n#&gt; 5 Chicago    &lt;list [4]&gt;         Chicago, IL, USA    &lt;named list [4]&gt;\n#&gt; 6 Arlington  &lt;list [4]&gt;         Arlington, TX, USA  &lt;named list [4]&gt;\n#&gt; # ℹ 1 more row\n#&gt; # ℹ 2 more variables: place_id &lt;chr&gt;, types &lt;list&gt;\n\n现在我们可以理解为什么两个城市得到了两个结果：华盛顿州（Washington state）和华盛顿特区（Washington, DC）都匹配了华盛顿，而阿灵顿（Arlington）则匹配了弗吉尼亚州的阿灵顿（Arlington, Virginia）和德克萨斯州的阿灵顿（Arlington, Texas）。\n接下来我们可以有几个不同的选择。我 们可能想要确定匹配的确切位置，这些信息被存储在geometry列表列中：\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  unnest_wider(geometry)\n#&gt; # A tibble: 7 × 6\n#&gt;   city       formatted_address   bounds           location     location_type\n#&gt;   &lt;chr&gt;      &lt;chr&gt;               &lt;list&gt;           &lt;list&gt;       &lt;chr&gt;        \n#&gt; 1 Houston    Houston, TX, USA    &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 2 Washington Washington, USA     &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 3 Washington Washington, DC, USA &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 4 New York   New York, NY, USA   &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 5 Chicago    Chicago, IL, USA    &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 6 Arlington  Arlington, TX, USA  &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; # ℹ 1 more row\n#&gt; # ℹ 1 more variable: viewport &lt;list&gt;\n\n这给我们提供了新的bounds（一个矩形区域）和location（一个点）变量。我 们可以展开位置列来查看纬度（lat）和经度（lng）：\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  unnest_wider(geometry) |&gt; \n  unnest_wider(location)\n#&gt; # A tibble: 7 × 7\n#&gt;   city       formatted_address   bounds             lat    lng location_type\n#&gt;   &lt;chr&gt;      &lt;chr&gt;               &lt;list&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;        \n#&gt; 1 Houston    Houston, TX, USA    &lt;named list [2]&gt;  29.8  -95.4 APPROXIMATE  \n#&gt; 2 Washington Washington, USA     &lt;named list [2]&gt;  47.8 -121.  APPROXIMATE  \n#&gt; 3 Washington Washington, DC, USA &lt;named list [2]&gt;  38.9  -77.0 APPROXIMATE  \n#&gt; 4 New York   New York, NY, USA   &lt;named list [2]&gt;  40.7  -74.0 APPROXIMATE  \n#&gt; 5 Chicago    Chicago, IL, USA    &lt;named list [2]&gt;  41.9  -87.6 APPROXIMATE  \n#&gt; 6 Arlington  Arlington, TX, USA  &lt;named list [2]&gt;  32.7  -97.1 APPROXIMATE  \n#&gt; # ℹ 1 more row\n#&gt; # ℹ 1 more variable: viewport &lt;list&gt;\n\n提取边界需要更多的步骤:\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  unnest_wider(geometry) |&gt; \n  # focus on the variables of interest\n  select(!location:viewport) |&gt;\n  unnest_wider(bounds)\n#&gt; # A tibble: 7 × 4\n#&gt;   city       formatted_address   northeast        southwest       \n#&gt;   &lt;chr&gt;      &lt;chr&gt;               &lt;list&gt;           &lt;list&gt;          \n#&gt; 1 Houston    Houston, TX, USA    &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 2 Washington Washington, USA     &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 3 Washington Washington, DC, USA &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 4 New York   New York, NY, USA   &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 5 Chicago    Chicago, IL, USA    &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 6 Arlington  Arlington, TX, USA  &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; # ℹ 1 more row\n\n然后，我们重命名 southwest和 northeast（矩形的两个角），这样我们就可以使用names_sep来创建简短但有意义的名称：\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  unnest_wider(geometry) |&gt; \n  select(!location:viewport) |&gt;\n  unnest_wider(bounds) |&gt; \n  rename(ne = northeast, sw = southwest) |&gt; \n  unnest_wider(c(ne, sw), names_sep = \"_\") \n#&gt; # A tibble: 7 × 6\n#&gt;   city       formatted_address   ne_lat ne_lng sw_lat sw_lng\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 Houston    Houston, TX, USA      30.1  -95.0   29.5  -95.8\n#&gt; 2 Washington Washington, USA       49.0 -117.    45.5 -125. \n#&gt; 3 Washington Washington, DC, USA   39.0  -76.9   38.8  -77.1\n#&gt; 4 New York   New York, NY, USA     40.9  -73.7   40.5  -74.3\n#&gt; 5 Chicago    Chicago, IL, USA      42.0  -87.5   41.6  -87.9\n#&gt; 6 Arlington  Arlington, TX, USA    32.8  -97.0   32.6  -97.2\n#&gt; # ℹ 1 more row\n\n请注意我们是如何通过向unnest_wider()提供变量名向量来同时展开两列的。\n一旦找到了到达你感兴趣元素的路径，你可以使用另一个tidyr函数 hoist() 来直接提取它们：\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  hoist(\n    geometry,\n    ne_lat = c(\"bounds\", \"northeast\", \"lat\"),\n    sw_lat = c(\"bounds\", \"southwest\", \"lat\"),\n    ne_lng = c(\"bounds\", \"northeast\", \"lng\"),\n    sw_lng = c(\"bounds\", \"southwest\", \"lng\"),\n  )\n\n如果这些案例研究已经激起了你对更多真实生活中数据规整化操作的兴趣，你可以在vignette(\"rectangling\", package = \"tidyr\") 中看到更多示例。\n\n\n23.4.4 练习\n\n粗略估计gh_repos的创建时间。为 什么你只能粗略估计日期？\ngh_repo的owner列包含了很多重复的信息，因为每个拥有者可以有多个仓库。你 能构造一个owners数据框，让其中每个拥有者只有一行吗？( 提示: distinct()函数能处理列表列吗？)\n按照 titles 的步骤为《权力的游戏》角色的aliases、allegiances、books和TV series创建类似的表格。\n逐行解释以下代码。为 什么它很有趣？为 什么它对got_chars有效但可能不适用于一般情况？\n\ntibble(json = got_chars) |&gt; \n  unnest_wider(json) |&gt; \n  select(id, where(is.list)) |&gt; \n  pivot_longer(\n    where(is.list), \n    names_to = \"name\", \n    values_to = \"value\"\n  ) |&gt;  \n  unnest_longer(value)\n\n在gmaps_cities中，address_components包含的内容是什么？为 什么长度行与行之间的长度不同？请 适当地将其展开以找出答案。（ 提示:types字段似乎总是包含两个元素。unnest_wider()是否比unnest_longer()更容易处理？）",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>层次数据</span>"
    ]
  },
  {
    "objectID": "rectangling.html#json",
    "href": "rectangling.html#json",
    "title": "23  层次数据",
    "section": "23.5 JSON",
    "text": "23.5 JSON\n前面各部分的所有案例研究都来原始的JSON数据。J SON是javascript object notation的缩写，是大多数Web API返回数据的方式。理 解它很重要，因为虽然JSON和R的数据类型非常相似，但它们之间并没有完美的1对1映射关系，所以如果出现问题，了解一点JSON是有帮助的。\n\n23.5.1 数据类型\nJSON 是一种简单的格式，设计的目的是让机器（而非人类）能够轻松地读取和写入。它 有六种主要的数据类型，其中四种是标量：\n\n最简单的类型是 null，它与 R 中的 NA 角色相同，表示数据的缺失。\nstring 与 R 中的字符串非常相似，但必须始终使用双引号。\nnumber 与 R 中的数字类似：它们可以使用整数（例如，123）、小数（例如，123.45）或科学记数法（例如，1.23e3）表示。JSON 不支持 Inf、-Inf 或 NaN。\nboolean 与 R 中的 TRUE 和 FALSE 类似，但使用小写 true 和 false。\n\nJSON 的字符串 (strings)、数字 (numbers) 和布尔值 (booleans) 相当接近于 R 中的字符、数值和逻辑向量。主 要区别在于 JSON 的标量只能表示单个值，要表示多个值，你需要使用剩下的两种类型之一：数组 (arrays) 和对象 (objects)。\n数组和对象都与 R 中的列表类似，区别在于它们是否有名字。数 组类似于未命名的列表，使用 [] 表示。例 如，[1, 2, 3] 是一个包含三个数字的数组，[null, 1, \"string\", false] 是一个包含空值、一个数字、一个字符串和一个布尔值的数组。对 象类似于命名的列表，使用 {} 表示。名 称（在 JSON 术语中称为键）是字符串，因此必须用引号括起来。例 如，{\"x\": 1, \"y\": 2} 是一个将 x 映射到 1、y 映射到 2 的对象。\n请注意，JSON 没有任何原生方式来表示日期或日期-时间，因此它们通常作为字符串存储，你需要使用 readr::parse_date() 或 readr::parse_datetime() 将它们转换为正确的数据结构。类 似地，JSON 中表示浮点数的规则有些不精确，因此有时你也会发现数字以字符串形式存储。在 需要时，应用 readr::parse_double() 来获取正确的变量类型。\n\n\n23.5.2 jsonlite\n要将 JSON 转换为 R 数据结构，我们推荐使用 Jeroen Ooms 的 jsonlite 包。我 们将使用 jsonlite 的两个函数 read_json()和parse_json()。在 实际应用中，你会使用read_json()从磁盘读取 JSON 文件。例 如，repurrsive包也提供了gh_user的数据源作为 JSON 文件，你可以使用read_json()来读取它：\n\n# A path to a json file inside the package:\ngh_users_json()\n#&gt; [1] \"/Users/runner/work/_temp/renv/cache/v5/macos/R-4.4/aarch64-apple-darwin20/repurrrsive/1.1.0/83cf8bf4ada1dca8cfe94111c2a691d7/repurrrsive/extdata/gh_users.json\"\n\n# Read it with read_json()\ngh_users2 &lt;- read_json(gh_users_json())\n\n# Check it's the same as the data we were using previously\nidentical(gh_users, gh_users2)\n#&gt; [1] TRUE\n\n在本书中, 我们还将使用parse_json()，因为它接受一个包含 JSON 的字符串，这使得它非常适合生成简单的示例。为 了开始，这里有三个简单的 JSON 数据集，首先以一个数字开始，然后将几个数字放入一个数组中，最后将该数组放入一个对象中：\n\nstr(parse_json('1'))\n#&gt;  int 1\nstr(parse_json('[1, 2, 3]'))\n#&gt; List of 3\n#&gt;  $ : int 1\n#&gt;  $ : int 2\n#&gt;  $ : int 3\nstr(parse_json('{\"x\": [1, 2, 3]}'))\n#&gt; List of 1\n#&gt;  $ x:List of 3\n#&gt;   ..$ : int 1\n#&gt;   ..$ : int 2\n#&gt;   ..$ : int 3\n\njsonlite还有一个重要的函数叫做fromJSON()。我 们在这里不使用它，因为它执行自动简化（simplifyVector = TRUE）。这 在很多情况下都能很好地工作，特别是简单的情况，但我们认为你自己进行规整化（即将 JSON 数据转换成适合 R 使用的格式）会更好，这样你就能确切地知道发生了什么，并且能更容易地处理最复杂的嵌套结构。\n\n\n23.5.3 开始规整化过程\n在大多数情况下，JSON 文件包含一个顶层数组，因为它们被设计为提供关于多个“事物”的数据，例如多个页面、多条记录或多个结果。在 这种情况下，你将使用tibble(json)开始你的规整化操作，这样每个元素都会成为一行：\n\njson &lt;- '[\n  {\"name\": \"John\", \"age\": 34},\n  {\"name\": \"Susan\", \"age\": 27}\n]'\ndf &lt;- tibble(json = parse_json(json))\ndf\n#&gt; # A tibble: 2 × 1\n#&gt;   json            \n#&gt;   &lt;list&gt;          \n#&gt; 1 &lt;named list [2]&gt;\n#&gt; 2 &lt;named list [2]&gt;\n\ndf |&gt; \n  unnest_wider(json)\n#&gt; # A tibble: 2 × 2\n#&gt;   name    age\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 John     34\n#&gt; 2 Susan    27\n\n在极少数情况下，JSON 文件由一个单一的顶层 JSON 对象组成，代表一个“事物”。在 这种情况下，你需要在将其放入tibble之前先将其封装在一个列表中，以启动规整化过程。\n\njson &lt;- '{\n  \"status\": \"OK\", \n  \"results\": [\n    {\"name\": \"John\", \"age\": 34},\n    {\"name\": \"Susan\", \"age\": 27}\n ]\n}\n'\ndf &lt;- tibble(json = list(parse_json(json)))\ndf\n#&gt; # A tibble: 1 × 1\n#&gt;   json            \n#&gt;   &lt;list&gt;          \n#&gt; 1 &lt;named list [2]&gt;\n\ndf |&gt; \n  unnest_wider(json) |&gt; \n  unnest_longer(results) |&gt; \n  unnest_wider(results)\n#&gt; # A tibble: 2 × 3\n#&gt;   status name    age\n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n#&gt; 1 OK     John     34\n#&gt; 2 OK     Susan    27\n\n或者，你可以深入到解析后的 JSON 中，从你真正关心的部分开始：\n\ndf &lt;- tibble(results = parse_json(json)$results)\ndf |&gt; \n  unnest_wider(results)\n#&gt; # A tibble: 2 × 2\n#&gt;   name    age\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 John     34\n#&gt; 2 Susan    27\n\n\n\n23.5.4 练习\n\n将下面的df_col和df_row进行规整。它 们代表了将数据框编码为 JSON 的两种方式。\n\njson_col &lt;- parse_json('\n  {\n    \"x\": [\"a\", \"x\", \"z\"],\n    \"y\": [10, null, 3]\n  }\n')\njson_row &lt;- parse_json('\n  [\n    {\"x\": \"a\", \"y\": 10},\n    {\"x\": \"x\", \"y\": null},\n    {\"x\": \"z\", \"y\": 3}\n  ]\n')\n\ndf_col &lt;- tibble(json = list(json_col)) \ndf_row &lt;- tibble(json = json_row)",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>层次数据</span>"
    ]
  },
  {
    "objectID": "rectangling.html#小结",
    "href": "rectangling.html#小结",
    "title": "23  层次数据",
    "section": "23.6 小结",
    "text": "23.6 小结\n在本章中，你学习了列表是什么，如何从 JSON 文件中生成它们，以及如何将它们转换为矩形数据框。令 人惊讶的是，我们只需要两个新函数：unnest_longer()将列表元素放入行中，unnest_wider()将列表元素放入列中。不 论列表列嵌套有多深，你只需要反复调用这两个函数。\nJSON 是 Web API 返回的最常见的数据格式。如 果网站没有 API，但你可以在网站上看到你想要的数据，那该怎么办呢？这 就是下一章的主题：网页抓取，从 HTML 网页中提取数据。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>层次数据</span>"
    ]
  },
  {
    "objectID": "rectangling.html#footnotes",
    "href": "rectangling.html#footnotes",
    "title": "23  层次数据",
    "section": "",
    "text": "这是RStudio的一个特性。↩︎",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>层次数据</span>"
    ]
  },
  {
    "objectID": "webscraping.html",
    "href": "webscraping.html",
    "title": "24  网页抓取",
    "section": "",
    "text": "24.1 引言\n本章将向您介绍使用 rvest 进行网页抓取 (web scraping) 的基础知识。网 页抓取是一种非常有用的工具，用于从网页中提取数据。一 些网站会提供 API，这是一组结构化的 HTTP 请求，其返回JSON 格式的数据，你可以使用 章节 23 中介绍的规整化方法来处理这些数据。在 可能的情况下，你应该使用 API1，因为它通常会提供更可靠的数据。 然而，不幸的是，使用 Web API 编程超出了本书的范围。 相反，我们将教授网页抓取技术，这是一种无论网站是否提供 API 都适用的技术。\n在本章中，我们首先会讨论网页抓取的伦理道德和合法性，然后再深入探讨 HTML 的基础知识。接 下来，学习 CSS 选择器的基础知识，以定位页面上的特定元素，以及如何使用rvest函数从 HTML 的文本和属性中提取数据并将其导入 R 。之 后，我们将讨论一些技巧，以确定你需要针对要抓取的页面使用哪个 CSS 选择器。最 后，我们将通过几个案例研究和一个关于动态网站的简短讨论来结束本章。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "webscraping.html#引言",
    "href": "webscraping.html#引言",
    "title": "24  网页抓取",
    "section": "",
    "text": "24.1.1 必要条件\n在本章中，我们将重点关注rvest提供的工具。r vest是tidyverse的一个成员，但不是核心成员，因此你需要显式地加载它。我 们还将加载完整的tidyverse，因为在我们处理已抓取的数据时，它通常会很有用。\n\nlibrary(tidyverse)\nlibrary(rvest)",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "webscraping.html#网页抓取的道德与法律",
    "href": "webscraping.html#网页抓取的道德与法律",
    "title": "24  网页抓取",
    "section": "24.2 网页抓取的道德与法律",
    "text": "24.2 网页抓取的道德与法律\n在我们开始讨论进行网页抓取所需的代码之前，我们需要讨论你是否有权合法且合乎道德地这样做。总 的来说，这两个方面的情况都相当复杂。\n合法性在很大程度上取决于你住在哪里。然 而，作为一般原则，如果数据是公开的、非个人的和真实的，那么你可能是安全的2。 这三个因素很重要，因为它们与网站的条款和条件、个人身份信息和版权有关，我们将在下面讨论。\n如果数据不是公开的、非个人的或真实的，或者你是专门为了赚钱而抓取这些数据，那么你需要咨询律师。最 重要的是，在任何情况下你都应该尊重托管你正在抓取的页面的服务器资源。这 意味着如果你正在抓取许多页面，你应该确保在每个请求之间稍微等待一下。一 个简单的方法是使用 Dmytro Perepolkin 的polite包，它会自动在请求之间暂停并缓存结果，这样你就不会两次请求相同的页面。\n\n24.2.1 服务条款\n如果仔细观察，你会发现许多网站在页面上的某个位置包含了一个“条款和条件”或“服务条款”的链接。如 果你仔细阅读该页面，通常会发现该网站明确禁止网页抓取。这 些页面企业往往会进行法律上的“圈地运动”，对其提出非常宽泛的权利主张。在 可能的情况下，尊重这些服务条款是一种礼貌，但对任何声明都应该持保留态度。\n美国法院普遍认为，仅仅将服务条款放在网站的页脚不足以使你受到它们的约束，例如HiQ Labs v. LinkedIn一案。一 般来说，要受服务条款的约束，你必须采取一些明确的行动，如创建账户或勾选复选框。这 就是为什么数据是否公开很重要；如果你不需要账户就可以访问它们，那么你不太可能受到服务条款的约束。但 请注意，欧洲的情况则有所不同，法院认为即使你没有明确表示同意，服务条款也是有强制性的。\n\n\n24.2.2 个人信息\n即使数据是公开的，你也应该极其小心地抓取个人身份信息，如姓名、电子邮件地址、电话号码、出生日期等。欧 洲对收集或存储此类数据有特别严格的法律 (GDPR)，无论你住在哪里，你都有可能陷入道德困境。例 如在2016年有研究人员从约会网站OkCupid上抓取了约7万人的公开个人信息资料（如用户名、年龄、性别、地点等），并公开地发布了这些数据，没有任何匿名化尝试。虽 然研究人员认为既然数据已经是公开的，这样做就没什么错，但是由于对数据集中发布的用户身份信息的伦理担忧，这项工作受到了广泛谴责。如 果你的工作涉及抓取个人身份信息，我们强烈建议你阅读OkCupid研究3以及涉及获取和发布个人身份信息的类似研究，这些研究的伦理都存在问题。\n\n\n24.2.3 版权\n最后，您还需要担心版权法。版 权法很复杂，但值得一看的是美国法律对受保护内容的描述：“[…]以任何有形表达媒介固定的原创作品[…]”。接 着，它描述了其适用的具体类别，如文学作品、音乐作品、电影等。值 得注意的是，数据并不受版权保护，这意味着只要你只收集事实，版权保护就不适用。( 但请注意，欧洲有一个单独的“sui generis”权利来保护数据库。)\n举个简单的例子，在美国，配料表和说明是不受版权保护的，所以版权不能用来保护食谱。但 是，如果该食谱列表伴有大量新颖的文学内容，那么这些内容是受版权保护的。这 就是为什么当你在网上寻找食谱时，之前总是有那么多内容。\n如果你确实需要抓取原创内容（如文本或图像），你可能仍然受到合理使用原则的保护。合 理使用不是一个严格的规则，而是权衡了多个因素。如 果你出于研究或非商业目的收集数据，并且仅抓取所需内容，那么合理使用原则更可能适用。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "webscraping.html#html基础",
    "href": "webscraping.html#html基础",
    "title": "24  网页抓取",
    "section": "24.3 HTML基础",
    "text": "24.3 HTML基础\n要抓取网页，你首先需要稍微了解HTML (HyperText Markup Language) ，一种描述网页的语言。H TML 代表超文本标记语言，看起来像这样：\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Page title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1 id='first'&gt;A heading&lt;/h1&gt;\n  &lt;p&gt;Some text &amp; &lt;b&gt;some bold text.&lt;/b&gt;&lt;/p&gt;\n  &lt;img src='myimg.png' width='100' height='100'&gt;\n&lt;/body&gt;\nHTML具有由元素形成的层次结构，这些元素包括开始标签（例如，&lt;tag&gt;）、可选属性（id='first'）、结束标签4（如&lt;/tag&gt;）和内容（开始标签和结束标签之间的所有内容）。\n由于&lt;和&gt;用于开始和结束标签，因此不能直接书写它们。相 反，你必须使用HTML转义字符&gt; (大于)和&lt; (小于)。并 且因为这些转义字符使用了&，如果你想要一个实际的&符号，你必须将其转义为&amp;。虽 然存在许多可能的HTML转义字符，但你不需要过分担心它们，因为rvest会自动为你处理它们。\n网页抓取之所以可能，是因为大多数包含你想要抓取的数据的页面通常都具有一致的结构。\n\n24.3.1 元素\nHTML有超过100个元素。其 中最重要的是:\n\n每个HTML页面都必须位于&lt;html&gt;元素中，还必须包含两个子元素：&lt;head&gt;，其中包含文档元数据，如页面标题，以及&lt;body&gt;，其中包含你在浏览器中看到的内容。\n诸如&lt;h1&gt; (标题1)、&lt;section&gt; (部分)、&lt;p&gt; (段落) 和 &lt;ol&gt; (有序列表) 之类的块标签构成了页面的整体结构。\n诸如&lt;b&gt; (粗体)、&lt;i&gt; (斜体) 和 &lt;a&gt; (链接) 之类的内联标签用以格式化块标签内的文本。\n\n如果您遇到从未见过的标签，可以通过谷歌搜索来发现它的作用。另 一个不错的起点是 MDN Web Docs，它描述了网络编程的各个方面。\n大多数元素都可以在开始和结束标签之间包含内容。这 些内容可以是文本或其他元素。例 如，以下HTML包含一段文本，其中一个词为粗体。\n&lt;p&gt;\n  Hi! My &lt;b&gt;name&lt;/b&gt; is Hadley.\n&lt;/p&gt;\n上面的&lt;p&gt;元素有一个子元素，即&lt;b&gt;元素，&lt;b&gt;元素没有子元素，但是它有内容 (文本“name”)。子 元素是它包含的其他元素。\n\n\n24.3.2 属性\n标签可以有命名属性，看起来像这样：name1='value1' name2='value2'，其中两个最重要的属性是id和class，它们与 CSS（层叠样式表）一起使用，以控制页面的视觉外观。在 抓取页面数据时，这些属性通常很有用。属 性也用于记录链接的目标（&lt;a&gt;元素的href属性）和图像的来源（&lt;img&gt;元素的src属性）。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "webscraping.html#提取数据",
    "href": "webscraping.html#提取数据",
    "title": "24  网页抓取",
    "section": "24.4 提取数据",
    "text": "24.4 提取数据\n要开始抓取数据，你需要抓取的页面的URL，这通常可以从你的网页浏览器中进行复制。然 后，使用read_html()函数将该页面的HTML读取到R中。这 会返回一个xml_document5 对象，之后你将使用rvest函数来操作这个对象：\n\nhtml &lt;- read_html(\"http://rvest.tidyverse.org/\")\nhtml\n#&gt; {html_document}\n#&gt; &lt;html lang=\"en\"&gt;\n#&gt; [1] &lt;head&gt;\\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UT ...\n#&gt; [2] &lt;body&gt;\\n    &lt;a href=\"#container\" class=\"visually-hidden-focusable\"&gt;Ski ...\n\nrevest还包含一个函数，允许你编写内联HTML。在 本章中，我们会用一些简单的例子来讲解各种函数的工作原理。\n\nhtml &lt;- minimal_html(\"\n  &lt;p&gt;This is a paragraph&lt;/p&gt;\n  &lt;ul&gt;\n    &lt;li&gt;This is a bulleted list&lt;/li&gt;\n  &lt;/ul&gt;\n\")\nhtml\n#&gt; {html_document}\n#&gt; &lt;html&gt;\n#&gt; [1] &lt;head&gt;\\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UT ...\n#&gt; [2] &lt;body&gt;\\n&lt;p&gt;This is a paragraph&lt;/p&gt;\\n  &lt;ul&gt;\\n&lt;li&gt;This is a bulleted lis ...\n\n现在已经有了用R编写的HTML，是时候提取感兴趣的数据了。你 将首先了解CSS选择器，它允许你识别感兴趣的元素和用于从中提取数据的rvest 函数。然 后我们将简要介绍HTML表，它有一些特殊的工具。\n\n24.4.1 查找元素\nCSS 是层叠样式表（Cascading Style Sheets）的缩写，是一个定义HTML文档视觉样式的工具。C SS包含了一种在页面上选择元素的小型语言，称为CSS选择器 (CSS selectors)。C SS选择器定义了定位HTML元素的模式，对于抓取数据来说非常有用，因为它们提供了一种简洁的方式来描述你想要提取哪些元素。\n我们将在 小节 24.5 更详细地讨论CSS选择器，但幸运的是，你只需要掌握以下三种选择器就可以走得很远了：\n\np 选择所有 &lt;p&gt; 元素；\n.title 选择所有带有类名 “title” 的元素；\n#title 选择 id 属性等于 “title” 的元素。i d 属性在文档内必须是唯一的，因此这只会选择一个元素。\n\n让我们通过一个简单的例子来尝试一下这些选择器：:\n\nhtml &lt;- minimal_html(\"\n  &lt;h1&gt;This is a heading&lt;/h1&gt;\n  &lt;p id='first'&gt;This is a paragraph&lt;/p&gt;\n  &lt;p class='important'&gt;This is an important paragraph&lt;/p&gt;\n\")\n\n使用html_elements()来查找与选择器匹配的所有元素：\n\nhtml |&gt; html_elements(\"p\")\n#&gt; {xml_nodeset (2)}\n#&gt; [1] &lt;p id=\"first\"&gt;This is a paragraph&lt;/p&gt;\n#&gt; [2] &lt;p class=\"important\"&gt;This is an important paragraph&lt;/p&gt;\nhtml |&gt; html_elements(\".important\")\n#&gt; {xml_nodeset (1)}\n#&gt; [1] &lt;p class=\"important\"&gt;This is an important paragraph&lt;/p&gt;\nhtml |&gt; html_elements(\"#first\")\n#&gt; {xml_nodeset (1)}\n#&gt; [1] &lt;p id=\"first\"&gt;This is a paragraph&lt;/p&gt;\n\n另一个重要的函数是html_element()，它总是返回与输入相同数量的输出。如 果你将它应用于整个文档，它将返回第一个匹配的元素：\n\nhtml |&gt; html_element(\"p\")\n#&gt; {html_node}\n#&gt; &lt;p id=\"first\"&gt;\n\n当你使用不匹配任何元素的选择器时，html_element()和html_elements()之间有一个重要的区别。h tml_elements()返回一个长度为 0 的向量，而html_element()返回一个缺失值。这 在稍后的内容中会变得重要。\n\nhtml |&gt; html_elements(\"b\")\n#&gt; {xml_nodeset (0)}\nhtml |&gt; html_element(\"b\")\n#&gt; {xml_missing}\n#&gt; &lt;NA&gt;\n\n\n\n24.4.2 嵌套选择\n在大多数情况下，你会一起使用html_elements()和html_element()。通 常首先使用html_elements()来识别将成为观测值的元素，然后使用html_element()来查找将成为变量的元素。让 我们通过一个简单的例子来看看这是如何操作的。这 里我们有一个无序列表（&lt;ul&gt;），其中每个列表项（&lt;li&gt;）都包含《星球大战》中四个角色的信息：\n\nhtml &lt;- minimal_html(\"\n  &lt;ul&gt;\n    &lt;li&gt;&lt;b&gt;C-3PO&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class='weight'&gt;167 kg&lt;/span&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;b&gt;R4-P17&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;b&gt;R2-D2&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class='weight'&gt;96 kg&lt;/span&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;b&gt;Yoda&lt;/b&gt; weighs &lt;span class='weight'&gt;66 kg&lt;/span&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n  \")\n\n我们可以使用html_elements()创建一个向量，其中每个元素对应一个不同的字符:\n\ncharacters &lt;- html |&gt; html_elements(\"li\")\ncharacters\n#&gt; {xml_nodeset (4)}\n#&gt; [1] &lt;li&gt;\\n&lt;b&gt;C-3PO&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class=\"weight\"&gt; ...\n#&gt; [2] &lt;li&gt;\\n&lt;b&gt;R4-P17&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt;\\n&lt;/li&gt;\n#&gt; [3] &lt;li&gt;\\n&lt;b&gt;R2-D2&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class=\"weight\"&gt; ...\n#&gt; [4] &lt;li&gt;\\n&lt;b&gt;Yoda&lt;/b&gt; weighs &lt;span class=\"weight\"&gt;66 kg&lt;/span&gt;\\n&lt;/li&gt;\n\n要提取每个角色的名字，我们使用html_element()，因为当应用于html_elements()的输出时，它保证每个元素返回一个响应:\n\ncharacters |&gt; html_element(\"b\")\n#&gt; {xml_nodeset (4)}\n#&gt; [1] &lt;b&gt;C-3PO&lt;/b&gt;\n#&gt; [2] &lt;b&gt;R4-P17&lt;/b&gt;\n#&gt; [3] &lt;b&gt;R2-D2&lt;/b&gt;\n#&gt; [4] &lt;b&gt;Yoda&lt;/b&gt;\n\n对于名字来说，html_element()和html_elements()之间的区别并不重要，但对于体重来说就很重要了。我 们想要为每个角色获取一个体重，即使没有体重的&lt;span&gt;标签。这 正是html_element()所做的：\n\ncharacters |&gt; html_element(\".weight\")\n#&gt; {xml_nodeset (4)}\n#&gt; [1] &lt;span class=\"weight\"&gt;167 kg&lt;/span&gt;\n#&gt; [2] NA\n#&gt; [3] &lt;span class=\"weight\"&gt;96 kg&lt;/span&gt;\n#&gt; [4] &lt;span class=\"weight\"&gt;66 kg&lt;/span&gt;\n\nhtml_elements()查找所有作为characters子元素的体重&lt;span&gt;标签。但 这样的标签只有三个，所以我们失去了名字和体重之间的关联：\n\ncharacters |&gt; html_elements(\".weight\")\n#&gt; {xml_nodeset (3)}\n#&gt; [1] &lt;span class=\"weight\"&gt;167 kg&lt;/span&gt;\n#&gt; [2] &lt;span class=\"weight\"&gt;96 kg&lt;/span&gt;\n#&gt; [3] &lt;span class=\"weight\"&gt;66 kg&lt;/span&gt;\n\n既然已经选择了感兴趣的元素，接下来需要从文本内容或某些属性中提取数据。\n\n\n24.4.3 文本和属性\nhtml_text2()6 提取HTML元素的纯文本内容:\n\ncharacters |&gt; \n  html_element(\"b\") |&gt; \n  html_text2()\n#&gt; [1] \"C-3PO\"  \"R4-P17\" \"R2-D2\"  \"Yoda\"\n\ncharacters |&gt; \n  html_element(\".weight\") |&gt; \n  html_text2()\n#&gt; [1] \"167 kg\" NA       \"96 kg\"  \"66 kg\"\n\n注意，任何转义都将被自动处理，你只会在源HTML中看到HTML转义，而不会在rvest返回的数据中看到。\nhtml_attr() 从属性中提取数据:\n\nhtml &lt;- minimal_html(\"\n  &lt;p&gt;&lt;a href='https://en.wikipedia.org/wiki/Cat'&gt;cats&lt;/a&gt;&lt;/p&gt;\n  &lt;p&gt;&lt;a href='https://en.wikipedia.org/wiki/Dog'&gt;dogs&lt;/a&gt;&lt;/p&gt;\n\")\n\nhtml |&gt; \n  html_elements(\"p\") |&gt; \n  html_element(\"a\") |&gt; \n  html_attr(\"href\")\n#&gt; [1] \"https://en.wikipedia.org/wiki/Cat\" \"https://en.wikipedia.org/wiki/Dog\"\n\nhtml_attr() 总是返回一个字符串，所以如果要提取数字或日期，需要做一些后处理。\n\n\n24.4.4 表格\n如果你很幸运，你的数据已经存储在 HTML 表格中，那么只需要从该表格中读取数据即可。在 浏览器中识别表格通常很简单：它会有一个由行和列组成的矩形结构，你可以将其复制并粘贴到像 Excel 这样的工具中。\nHTML 表格由四个主要元素组成：&lt;table&gt; (表格)、&lt;tr&gt; (表格行)、&lt;th&gt; (表格标题)和 &lt;td&gt; (表格数据)。下 面是一个包含两列三行的简单 HTML 表格示例：\n\nhtml &lt;- minimal_html(\"\n  &lt;table class='mytable'&gt;\n    &lt;tr&gt;&lt;th&gt;x&lt;/th&gt;   &lt;th&gt;y&lt;/th&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;1.5&lt;/td&gt; &lt;td&gt;2.7&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;4.9&lt;/td&gt; &lt;td&gt;1.3&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;7.2&lt;/td&gt; &lt;td&gt;8.1&lt;/td&gt;&lt;/tr&gt;\n  &lt;/table&gt;\n  \")\n\nrvest 提供了一个html_table()函数来读取这种类型的数据。它 返回一个列表，其中包含页面上找到的每个表格的一个 tibble。使 用html_element()来识别你想要提取的表格：\n\nhtml |&gt; \n  html_element(\".mytable\") |&gt; \n  html_table()\n#&gt; # A tibble: 3 × 2\n#&gt;       x     y\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1   1.5   2.7\n#&gt; 2   4.9   1.3\n#&gt; 3   7.2   8.1\n\n请注意，x 和 y 已经自动被转换为数字。这 种自动转换并不总是有效，因此在更复杂的场景中，你可能想通过设置 convert = FALSE 来关闭它，然后进行自己的转换。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "webscraping.html#sec-css-selectors",
    "href": "webscraping.html#sec-css-selectors",
    "title": "24  网页抓取",
    "section": "24.5 找到正确的选择器",
    "text": "24.5 找到正确的选择器\n确定数据对应的选择器通常是这个问题中最困难的部分。你 通常需要做一些尝试来找到一个既特异（即不选择你不关心的内容）又敏感（即选择你关心的所有内容）的选择器。大 量的尝试和错误是这个过程的正常部分！有 两个主要工具可以帮助你完成这个过程：SelectorGadget 和浏览器的开发者工具。\nSelectorGadget 是一个 JavaScript 书签工具，它基于你提供的正面和反面示例来自动生成 CSS 选择器。它 并不总是有效，但当它成功时，它就像神奇魔法一样！你 可以通过阅读 https://rvest.tidyverse.org/articles/selectorgadget.html 或观看 Mine 的视频 https://www.youtube.com/watch?v=PetWV5g1Xsc 来学习如何安装和使用 SelectorGadget。\n每个现代浏览器都带有一些开发者工具包，但我们推荐使用 Chrome，即使它不是你的常用浏览器。它 的网络开发者工具是最好的，而且立即可用。在 页面上的一个元素上右键单击并选择Inspect，这将打开一个可扩展的完整 HTML 页面视图，以你刚刚点击的元素为中心。你 可以使用它来探索页面并了解哪些选择器可能有效。特 别注意 class 和 id 属性，因为这些属性通常用于形成页面的视觉结构，因此是提取你正在寻找的数据的好工具。\n在“元素”视图中，你还可以右键单击一个元素并选择Copy as Selector以生成一个将唯一标识感兴趣元素的选择器。\n如果 SelectorGadget 或 Chrome DevTools 生成了你不理解的 CSS 选择器，请尝试使用 Selectors Explained，它将 CSS 选择器翻译成简单的英语。如 果你发现自己经常这样做，你可能想要更深入地了解 CSS 选择器。我 们推荐你从有趣的 CSS dinner 教程开始，然后参考 MDN web docs。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "webscraping.html#整合",
    "href": "webscraping.html#整合",
    "title": "24  网页抓取",
    "section": "24.6 整合",
    "text": "24.6 整合\n让我们将这些内容整合起来以抓取一些网站。这 些示例在你运行它们时可能不再有效，这是网页抓取的基本挑战；如果网站的结构发生变化，那么你就需要更改你的抓取代码。\n\n24.6.1 星球大战\nrvest在vignette(\"starwars\")中包含一个非常简单的示例。这 是一个简单的页面，HTML 内容很少，所以它是一个很好的起点。我 鼓励你现在就导航到那个页面，并使用”Inspect Element” 来检查一个标题，该标题是星球大战电影的名称。使 用键盘或鼠标探索 HTML 的层次结构，看看你是否能感觉到每部电影使用的共享结构。\n你应该能够看到每部电影都有一个共享的结构，看起来像这样：\n&lt;section&gt;\n  &lt;h2 data-id=\"1\"&gt;The Phantom Menace&lt;/h2&gt;\n  &lt;p&gt;Released: 1999-05-19&lt;/p&gt;\n  &lt;p&gt;Director: &lt;span class=\"director\"&gt;George Lucas&lt;/span&gt;&lt;/p&gt;\n  \n  &lt;div class=\"crawl\"&gt;\n    &lt;p&gt;...&lt;/p&gt;\n    &lt;p&gt;...&lt;/p&gt;\n    &lt;p&gt;...&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/section&gt;\n我们的目标是将这些数据转换为一个包含7行的数据框，变量包括 title、year、director和 intro。首 先，我们将读取HTML并提取所有的&lt;section&gt;元素：\n\nurl &lt;- \"https://rvest.tidyverse.org/articles/starwars.html\"\nhtml &lt;- read_html(url)\n\nsection &lt;- html |&gt; html_elements(\"section\")\nsection\n#&gt; {xml_nodeset (7)}\n#&gt; [1] &lt;section&gt;&lt;h2 data-id=\"1\"&gt;\\nThe Phantom Menace\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 1 ...\n#&gt; [2] &lt;section&gt;&lt;h2 data-id=\"2\"&gt;\\nAttack of the Clones\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: ...\n#&gt; [3] &lt;section&gt;&lt;h2 data-id=\"3\"&gt;\\nRevenge of the Sith\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased:  ...\n#&gt; [4] &lt;section&gt;&lt;h2 data-id=\"4\"&gt;\\nA New Hope\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 1977-05-2 ...\n#&gt; [5] &lt;section&gt;&lt;h2 data-id=\"5\"&gt;\\nThe Empire Strikes Back\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleas ...\n#&gt; [6] &lt;section&gt;&lt;h2 data-id=\"6\"&gt;\\nReturn of the Jedi\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 1 ...\n#&gt; [7] &lt;section&gt;&lt;h2 data-id=\"7\"&gt;\\nThe Force Awakens\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 20 ...\n\n这获取了与页面上找到的七部电影相匹配的七个元素，这表明使用section作为选择器是合适的。由 于数据总是在文本中找到，提取单个元素是很直接的，只是需要找到正确的选择器：\n\nsection |&gt; html_element(\"h2\") |&gt; html_text2()\n#&gt; [1] \"The Phantom Menace\"      \"Attack of the Clones\"   \n#&gt; [3] \"Revenge of the Sith\"     \"A New Hope\"             \n#&gt; [5] \"The Empire Strikes Back\" \"Return of the Jedi\"     \n#&gt; [7] \"The Force Awakens\"\n\nsection |&gt; html_element(\".director\") |&gt; html_text2()\n#&gt; [1] \"George Lucas\"     \"George Lucas\"     \"George Lucas\"    \n#&gt; [4] \"George Lucas\"     \"Irvin Kershner\"   \"Richard Marquand\"\n#&gt; [7] \"J. J. Abrams\"\n\n一旦我们对每个组件都完成了这些操作，我们就可以将所有结果包装成一个tibble：\n\ntibble(\n  title = section |&gt; \n    html_element(\"h2\") |&gt; \n    html_text2(),\n  released = section |&gt; \n    html_element(\"p\") |&gt; \n    html_text2() |&gt; \n    str_remove(\"Released: \") |&gt; \n    parse_date(),\n  director = section |&gt; \n    html_element(\".director\") |&gt; \n    html_text2(),\n  intro = section |&gt; \n    html_element(\".crawl\") |&gt; \n    html_text2()\n)\n#&gt; # A tibble: 7 × 4\n#&gt;   title                   released   director         intro                  \n#&gt;   &lt;chr&gt;                   &lt;date&gt;     &lt;chr&gt;            &lt;chr&gt;                  \n#&gt; 1 The Phantom Menace      1999-05-19 George Lucas     \"Turmoil has engulfed …\n#&gt; 2 Attack of the Clones    2002-05-16 George Lucas     \"There is unrest in th…\n#&gt; 3 Revenge of the Sith     2005-05-19 George Lucas     \"War! The Republic is …\n#&gt; 4 A New Hope              1977-05-25 George Lucas     \"It is a period of civ…\n#&gt; 5 The Empire Strikes Back 1980-05-17 Irvin Kershner   \"It is a dark time for…\n#&gt; 6 Return of the Jedi      1983-05-25 Richard Marquand \"Luke Skywalker has re…\n#&gt; # ℹ 1 more row\n\n我们对released进行了一些额外的处理，以便得到一个变量，这个变量将在我们后续的分析中更容易使用。\n\n\n24.6.2 IMDB 顶级电影\n对于下一个任务，我们将解决一个稍微棘手一点的问题，即从互联网电影数据库（IMDb）中提取前250部电影。在 我们撰写本章时，该页面看起来像这样 图 24.1 。\n\n\n\n\n\n\n\n\n图 24.1: Screenshot of the IMDb top movies web page taken on 2022-12-05.\n\n\n\n\n\n这些数据有一个清晰的表格结构，所以值得从html_table()开始:\n\n# url &lt;- \"https://web.archive.org/web/20220201012049/https://www.imdb.com/chart/top/\"\n# html &lt;- read_html(url)\n# \n# table &lt;- html |&gt; \n#   html_element(\"table\") |&gt; \n#   html_table()\n# table\n\n这包括一些空列，但总体上很好地捕获了表格中的信息。然 而，为了使它更容易使用，我们需要进行更多的处理。首 先，我们将重命名列以便于操作，并删除排名和标题中的多余空格。我 们将使用select()（而不是rename()）来一步完成这两个列的重命名和选择。然 后我们将删除换行符和多余的空格，接着使用separate_wider_regex()（来自 小节 15.3.4 ）来将标题、年份和排名提取到它们自己的变量中。\n\n# ratings &lt;- table |&gt;\n#   select(\n#     rank_title_year = `Rank & Title`,\n#     rating = `IMDb Rating`\n#   ) |&gt; \n#   mutate(\n#     rank_title_year = str_replace_all(rank_title_year, \"\\n +\", \" \")\n#   ) |&gt; \n#   separate_wider_regex(\n#     rank_title_year,\n#     patterns = c(\n#       rank = \"\\\\d+\", \"\\\\. \",\n#       title = \".+\", \" +\\\\(\",\n#       year = \"\\\\d+\", \"\\\\)\"\n#     )\n#   )\n# ratings\n\n即使在这种情况下，大部分数据都来自表格单元格，查看原始HTML仍然是有价值的。如 果你这样做，你会发现我们可以利用其中一个属性来添加一些额外的数据。这 正是值得花一点时间去探索页面源代码的原因之一；你可能会发现额外的数据，或者找到稍微简单一些的解析路径。\n\nhtml |&gt; \n  html_elements(\"td strong\") |&gt; \n  head() |&gt; \n  html_attr(\"title\")\n#&gt; character(0)\n\n我们可以将这与表格数据结合起来，并再次应用separate_wider_regex()函数来提取我们关心的数据部分：\n\n# ratings |&gt;\n#   mutate(\n#     rating_n = html |&gt; html_elements(\"td strong\") |&gt; html_attr(\"title\")\n#   ) |&gt; \n#   separate_wider_regex(\n#     rating_n,\n#     patterns = c(\n#       \"[0-9.]+ based on \",\n#       number = \"[0-9,]+\",\n#       \" user ratings\"\n#     )\n#   ) |&gt; \n#   mutate(\n#     number = parse_number(number)\n#   )",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "webscraping.html#动态网站",
    "href": "webscraping.html#动态网站",
    "title": "24  网页抓取",
    "section": "24.7 动态网站",
    "text": "24.7 动态网站\n到目前为止，我们主要关注的是那些html_elements()返回你在浏览器中看到的内容的网站，并讨论了如何解析这些返回的内容以及如何在整齐的数据框中组织这些信息。然 而，有时你会遇到html_elements()及其相关函数返回的内容与你在浏览器中看到的内容截然不同的情况。在 很多情况下，这是因为你试图抓取的是使用javascript动态生成页面内容的网站。这 在目前不能与rvest一起工作，因为rvest下载的是原始的HTML，并不运行任何javascript。\n尽管如此，仍然有可能抓取这些类型的网站，但rvest需要使用一个更复杂的过程：完全模拟网络浏览器，包括运行所有的javascript。在 撰写本文时，这一功能尚未可用，但这是我们正在积极开发的内容，并且可能在你阅读本文时已经可用。它 使用chromote 包，该包实际上在后台运行Chrome浏览器，并为你提供了与网站交互的额外工具，就像人类一样输入文本和点击按钮。更 多详细信息，请查看rvest website。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "webscraping.html#小结",
    "href": "webscraping.html#小结",
    "title": "24  网页抓取",
    "section": "24.8 小结",
    "text": "24.8 小结\n在本章中，你学习了从网页抓取数据的原因、为什么不可以以及如何抓取。首 先，学习了HTML的基础知识以及如何使用CSS选择器来引用特定的元素，然后学习了使用rvest包将HTML中的数据导入R。接 着，我们通过两个案例研究来展示网页抓取：一个更简单的场景是从rvest包网站抓取关于《星球大战》电影的数据，以及一个更复杂的场景是从IMDB抓取前250部电影的数据。\n从网页上抓取数据的技术细节可能会很复杂，尤其是当处理动态生成的网站时，但法律和道德考虑可能更为复杂。在 着手抓取数据之前，你需要对这两方面都有所了解。\n你已经学习了将数据从其原始位置（电子表格、数据库、JSON文件和网站）以整齐的形式导入R中的技术，这标志着我们完成了本书中关于数据导入的内容。现 在，是时候将目光投向一个新的主题了: 充分利用R作为一种编程语言。",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "webscraping.html#footnotes",
    "href": "webscraping.html#footnotes",
    "title": "24  网页抓取",
    "section": "",
    "text": "许多流行的API已经有CRAN包来封装它们，所以请先进行一些研究！↩︎\n显然，我们不是律师，这也不是法律建议。但 这是我们阅读了大量相关话题后能够给出的最佳总结。↩︎\n《连线》杂志发表了一篇关于OkCupid研究的文章 https://www.wired.com/2016/05/okcupid-study-reveals-perils-big-data-science.↩︎\n许多标签(包括&lt;p&gt;和&lt;li&gt;)不需要结束标签，但我们认为最好包含结束标签，因为这样可以更容易地查看HTML的结构。↩︎\n该类来自xml2包。x ml2是一种底层包，可以在其上进行构建。↩︎\nrvest 也提供了html_text()函数，但你几乎总是使用html_text2()，因为它在将嵌套的 HTML 转换为文本方面做得更好。↩︎",
    "crumbs": [
      "导入",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "25  函数",
    "section": "",
    "text": "25.1 引言\n数据科学家提高影响力的一种最佳方式就是编写函数。函 数允许你以一种更强大和通用的方式自动化常见任务，这比复制粘贴更为高效。与 复制粘贴相比，编写函数具有四大优势：\n一个经验法则是：当你复制粘贴一块代码超过两次时 (即现在有三份相同的代码) 就应该考虑编写一个函数。在 本章中，你将学习三种有用的函数类型：\n每个部分都包含了许多示例，以帮助你概括你看到的模式。没 有Twitter上朋友们的帮助，这些例子是不可能实现的，我们鼓励你点击评论中的链接查看原始灵感来源。你 可能还想阅读关于general functions和plotting functions的原始激励推文，以查看更多的函数示例。",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#引言",
    "href": "functions.html#引言",
    "title": "25  函数",
    "section": "",
    "text": "可以给函数起一个富有表现力的名字，使你的代码更容易理解。\n随着需求的变化，你只需要在一个地方更新代码，而不是在多个地方。\n消除了在复制粘贴时可能发生的偶然错误 (例如在一个地方更新了变量名，但在另一个地方没有) 。\n使得项目之间的工作重用变得更加容易，随着时间推移提高了生产效率。\n\n\n\n向量函数 接受一个或多个向量作为输入，并返回一个向量作为输出。\n数据框函数 接受一个数据框作为输入，并返回一个数据框作为输出。\n绘图函数 接受一个数据框作为输入，并返回一个图形作为输出。\n\n\n\n25.1.1 必要条件\n我们将整理来自tidyverse的各种函数。同 时，我们还将使用nycflights13数据集作为熟悉的数据源来使用我们的函数。\n\nlibrary(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#向量函数",
    "href": "functions.html#向量函数",
    "title": "25  函数",
    "section": "25.2 向量函数",
    "text": "25.2 向量函数\n我们从向量函数开始:接受一个或多个向量并返回一个向量结果的函数。例 如，请看下面的代码。它 是做什么的?\n\ndf &lt;- tibble(\n  a = rnorm(5),\n  b = rnorm(5),\n  c = rnorm(5),\n  d = rnorm(5),\n)\n\ndf |&gt; mutate(\n  a = (a - min(a, na.rm = TRUE)) / \n    (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)),\n  b = (b - min(b, na.rm = TRUE)) / \n    (max(b, na.rm = TRUE) - min(b, na.rm = TRUE)),\n  c = (c - min(c, na.rm = TRUE)) / \n    (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),\n  d = (d - min(d, na.rm = TRUE)) / \n    (max(d, na.rm = TRUE) - min(d, na.rm = TRUE)),\n)\n#&gt; # A tibble: 5 × 4\n#&gt;       a     b     c     d\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 0.339 1     0.291 0    \n#&gt; 2 0.880 0     0.611 0.557\n#&gt; 3 0     0.530 1     0.752\n#&gt; 4 0.795 0.531 0     1    \n#&gt; 5 1     0.518 0.580 0.394\n\n你可能能猜出这段代码将每一列重新缩放，使其范围在0到1之间。但 你有没有发现错误？当 Hadley写这段代码时，他在复制粘贴时犯了一个错误，忘记把字母a改成b。防 止这种错误是学习如何编写函数的一个非常好的理由。\n\n25.2.1 编写函数\n要编写一个函数，你首先需要分析你的重复代码，以弄清楚哪些部分是固定的，哪些部分是变化的。如 果我们把上面的代码从mutate()中提取出来，因为每次重复现在都在一行上，所以更容易看出模式：\n\n(a - min(a, na.rm = TRUE)) / (max(a, na.rm = TRUE) - min(a, na.rm = TRUE))\n(b - min(b, na.rm = TRUE)) / (max(b, na.rm = TRUE) - min(b, na.rm = TRUE))\n(c - min(c, na.rm = TRUE)) / (max(c, na.rm = TRUE) - min(c, na.rm = TRUE))\n(d - min(d, na.rm = TRUE)) / (max(d, na.rm = TRUE) - min(d, na.rm = TRUE))  \n\n为了更清楚一点，我们可以用█来替换变化的位:\n\n(█ - min(█, na.rm = TRUE)) / (max(█, na.rm = TRUE) - min(█, na.rm = TRUE))\n\n要将其转换为一个函数，你需要三样东西：\n\n一个名称。这里我们将使用rescale01，因为这个函数将向量重新缩放到0和1之间。\n参数。参数是在函数调用中变化的东西，上面的分析告诉我们只有一个，将它命名为x，因为这是数值向量的常规名称。\n函数体。函数体是在所有调用中重复的代码。\n\n然后，你按照下面的模板来创建一个函数：\n\nname &lt;- function(arguments) {\n  body\n}\n\n针对这种情况，其结果是：\n\nrescale01 &lt;- function(x) {\n  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n}\n\n此时，你可能会用几个简单的输入进行测试，以确保你已经正确地捕捉到了逻辑：\n\nrescale01(c(-10, 0, 10))\n#&gt; [1] 0.0 0.5 1.0\nrescale01(c(1, 2, 3, NA, 5))\n#&gt; [1] 0.00 0.25 0.50   NA 1.00\n\n然后你可以将mutate()的调用重写为:\n\ndf |&gt; mutate(\n  a = rescale01(a),\n  b = rescale01(b),\n  c = rescale01(c),\n  d = rescale01(d),\n)\n#&gt; # A tibble: 5 × 4\n#&gt;       a     b     c     d\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 0.339 1     0.291 0    \n#&gt; 2 0.880 0     0.611 0.557\n#&gt; 3 0     0.530 1     0.752\n#&gt; 4 0.795 0.531 0     1    \n#&gt; 5 1     0.518 0.580 0.394\n\n( 章节 26, 你将学习如何使用across()来进一步减少重复，这样你只需要写df |&gt; mutate(across(a:d, rescale01))就可以了).\n\n\n25.2.2 改进函数\n你可能注意到rescale01()函数做了一些不必要的工作，们不需要计算两次min()和一次max()，相反，我们可以用range()函数在一步中同时计算出最小值和最大值。\n\nrescale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\n或者，你可能试图在包含无穷大值的向量上尝试这个函数：\n\nx &lt;- c(1:10, Inf)\nrescale01(x)\n#&gt;  [1]   0   0   0   0   0   0   0   0   0   0 NaN\n\n这个结果不是特别有用，所以我们可以让range()函数忽略无穷大值：\n\nrescale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE, finite = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\nrescale01(x)\n#&gt;  [1] 0.0000000 0.1111111 0.2222222 0.3333333 0.4444444 0.5555556 0.6666667\n#&gt;  [8] 0.7777778 0.8888889 1.0000000       Inf\n\n这些改变说明了函数的一个重要好处：因为我们把重复的代码移到了函数中，所以我们只需要在一个地方做出改变。\n\n\n25.2.3 Mutate 函数\n既然你已经掌握了函数的基本概念，让我们来看一系列的例子。我 们首先从“mutate”函数开始，也就是那些在mutate()和filter()内部工作得很好的函数，因为它们返回的输出长度与输入相同。\n让我们从rescale01()函数的一个简单变体开始。也 许你想计算Z分数，即将一个向量重新缩放到均值为0，标准差为1：\n\nz_score &lt;- function(x) {\n  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)\n}\n\n或者，你可能想要封装一个简单的case_when()，并给它一个有用的名字。例 如，这个clamp()函数确保向量的所有值都位于最小值和最大值之间：\n\nclamp &lt;- function(x, min, max) {\n  case_when(\n    x &lt; min ~ min,\n    x &gt; max ~ max,\n    .default = x\n  )\n}\n\nclamp(1:10, min = 3, max = 7)\n#&gt;  [1] 3 3 3 4 5 6 7 7 7 7\n\n当然，函数不仅仅需要处理数值变量，你可能需要进行一些重复的字符串操作。比 如，可能需要将字符串的第一个字符转换为大写：\n\nfirst_upper &lt;- function(x) {\n  str_sub(x, 1, 1) &lt;- str_to_upper(str_sub(x, 1, 1))\n  x\n}\n\nfirst_upper(\"hello\")\n#&gt; [1] \"Hello\"\n\n或者，你可能想在将字符串转换为数字之前，去掉其中的百分号、逗号和美元符号：\n\n# https://twitter.com/NVlabormarket/status/1571939851922198530\nclean_number &lt;- function(x) {\n  is_pct &lt;- str_detect(x, \"%\")\n  num &lt;- x |&gt; \n    str_remove_all(\"%\") |&gt; \n    str_remove_all(\",\") |&gt; \n    str_remove_all(fixed(\"$\")) |&gt; \n    as.numeric()\n  if_else(is_pct, num / 100, num)\n}\n\nclean_number(\"$12,300\")\n#&gt; [1] 12300\nclean_number(\"45%\")\n#&gt; [1] 0.45\n\n有时，你的函数将专门用于某个数据分析步骤。例 如，如果你有一堆变量，它们将缺失值记录为997、998或999，你可能想编写一个函数来将这些值替换为NA：\n\nfix_na &lt;- function(x) {\n  if_else(x %in% c(997, 998, 999), NA, x)\n}\n\n我们主要关注只接受单个向量的例子，因为我们认为它们是最常见的。但 是，你的函数没有理由不能接受多个向量输入。\n\n\n25.2.4 汇总函数\n另一类重要的向量函数是汇总函数 (summary functions)，这些函数返回一个单一的值，用于summarize()函数中。有 时，这仅仅是设置一两个默认参数的问题：\n\ncommas &lt;- function(x) {\n  str_flatten(x, collapse = \", \", last = \" and \")\n}\n\ncommas(c(\"cat\", \"dog\", \"pigeon\"))\n#&gt; [1] \"cat, dog and pigeon\"\n\n或者，你可能想封装一个简单的计算，比如变异系数，它是通过标准差除以均数来计算的：\n\ncv &lt;- function(x, na.rm = FALSE) {\n  sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)\n}\n\ncv(runif(100, min = 0, max = 50))\n#&gt; [1] 0.5196276\ncv(runif(100, min = 0, max = 500))\n#&gt; [1] 0.5652554\n\n或者你可能只是想通过给它一个易于记忆的名字来让常见的模式更容易被记住：\n\n# https://twitter.com/gbganalyst/status/1571619641390252033\nn_missing &lt;- function(x) {\n  sum(is.na(x))\n} \n\n你还可以编写具有多个向量输入的函数。例 如，你可能想要计算平均绝对百分比误差来帮助你比较模型预测值与实际值：\n\n# https://twitter.com/neilgcurrie/status/1571607727255834625\nmape &lt;- function(actual, predicted) {\n  sum(abs((actual - predicted) / actual)) / length(actual)\n}\n\n\n\n\n\n\n\nRStudio\n\n\n\n当你开始编写函数时，有两个RStudio的快捷键非常有用：\n\n要查找你已编写的函数的定义，请将光标放在函数名上，然后按F2；\n要快速跳转到某个函数，请按Ctrl + . 打开模糊的文件和函数查找器，并输入你的函数名的前几个字母。你 还可以导航到文件、Quarto部分等，这使它成为一个非常方便的导航工具。\n\n\n\n\n\n25.2.5 练习\n\n练习将以下代码片段转换为函数。考 虑每个函数的作用。你 怎么称呼它？它 需要多少个参数?\n\nmean(is.na(x))\nmean(is.na(y))\nmean(is.na(z))\n\nx / sum(x, na.rm = TRUE)\ny / sum(y, na.rm = TRUE)\nz / sum(z, na.rm = TRUE)\n\nround(x / sum(x, na.rm = TRUE) * 100, 1)\nround(y / sum(y, na.rm = TRUE) * 100, 1)\nround(z / sum(z, na.rm = TRUE) * 100, 1)\n\n在rescale01()函数的第二个版本中，无穷值保持不变。你 能重写rescale01()函数，使得-Inf被映射到0，而Inf被映射到1吗？\n给定一个出生日期向量，编写一个函数来计算年龄 (以年为单位)。\n编写你自己的函数来计算数值向量的方差和偏度。你 可以在维基百科或其他地方查找这些定义。\n编写both_na()函数，这是一个汇总函数，它接收两个相同长度的向量，并返回两个向量中都有NA值的位置数量。\n阅读文档来了解以下函数的作用。尽 管它们很短，为什么仍然很有用？\n\nis_directory &lt;- function(x) {\n  file.info(x)$isdir\n}\nis_readable &lt;- function(x) {\n  file.access(x, 4) == 0\n}",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#数据框函数",
    "href": "functions.html#数据框函数",
    "title": "25  函数",
    "section": "25.3 数据框函数",
    "text": "25.3 数据框函数\n向量函数对于从dplyr函数中提取重复代码很有用。但 是，你通常会重复这些函数本身，特别是在大型管道中。当 你发现自己多次复制和粘贴多个函数时，你可能会考虑编写一个数据框函数。数 据框函数的工作方式与dplyr函数类似：它们将数据框作为第一个参数，一些额外的参数说明如何处理它，并返回一个数据框或向量。\n为了让你编写一个使用dplyr操作函数的函数，我们将首先向你介绍间接引用的问题以及如何通过使用{ }来克服它。掌 握了这些理论之后，我们将向你展示一堆示例来说明你可以用它做什么。\n\n25.3.1 间接引用和整齐评估\n当你开始编写使用dplyr函数的函数时，你会很快遇到间接引用 (indirection) 的问题。让 我们用一个非常简单的函数grouped_mean()来说明这个问题。这 个函数的目的是计算按group_var分组后mean_var的均数：\n\ngrouped_mean &lt;- function(df, group_var, mean_var) {\n  df |&gt; \n    group_by(group_var) |&gt; \n    summarize(mean(mean_var))\n}\n\n如果我们尝试使用它，就会得到一个错误:\n\ndiamonds |&gt; grouped_mean(cut, carat)\n#&gt; Error in `group_by()`:\n#&gt; ! Must group by variables found in `.data`.\n#&gt; ✖ Column `group_var` is not found.\n\n为了使问题更清楚，我们可以使用一个合成的数据框:\n\ndf &lt;- tibble(\n  mean_var = 1,\n  group_var = \"g\",\n  group = 1,\n  x = 10,\n  y = 100\n)\n\ndf |&gt; grouped_mean(group, x)\n#&gt; # A tibble: 1 × 2\n#&gt;   group_var `mean(mean_var)`\n#&gt;   &lt;chr&gt;                &lt;dbl&gt;\n#&gt; 1 g                        1\ndf |&gt; grouped_mean(group, y)\n#&gt; # A tibble: 1 × 2\n#&gt;   group_var `mean(mean_var)`\n#&gt;   &lt;chr&gt;                &lt;dbl&gt;\n#&gt; 1 g                        1\n\n无论我们如何调用grouped_mean()函数，它总是执行df |&gt; group_by(group_var) |&gt; summarize(mean(mean_var))，而不是df |&gt; group_by(group) |&gt; summarize(mean(x))或df |&gt; group_by(group) |&gt; summarize(mean(y))。这 是一个间接性的问题，它产生的原因是dplyr使用整齐评估（tidy evaluation）来允许你在不经过任何特殊处理的情况下引用数据框中的变量名。\n整齐评估在95%的情况下都很有用，因为它使你的数据分析非常简洁，因为你永远不需要说明变量来自哪个数据框；从上下文中就可以明显看出。然 而，整齐评估的缺点出现在我们想要将重复的tidyverse代码封装到函数中时。在 这里，我们需要一种方式来告诉group_by()和summarize()不要将group_var和mean_var当作变量的名字，而是查看它们内部我们实际想要使用的变量。\n整齐评估包括一个解决这个问题的方案，叫做“拥抱”（embracing）。拥 抱一个变量意味着用花括号将它包裹起来，例如var变成{ var }。拥 抱一个变量告诉dplyr使用参数内部存储的值，而不是将参数作为字面变量名。一 种记住这种操作的方法是想象{ }是向下看一个隧道，{ var }会使dplyr函数查看var内部的内容，而不是寻找一个名为var的变量。\n因此，为了让grouped_mean()函数正常工作，我们需要用{ }将group_var和mean_var包围起来。\n\ngrouped_mean &lt;- function(df, group_var, mean_var) {\n  df |&gt; \n    group_by({{ group_var }}) |&gt; \n    summarize(mean({{ mean_var }}))\n}\n\ndf |&gt; grouped_mean(group, x)\n#&gt; # A tibble: 1 × 2\n#&gt;   group `mean(x)`\n#&gt;   &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1     1        10\n\n成功了!\n\n\n25.3.2 什么时候拥抱?\n因此，在编写数据框函数时，主要挑战在于确定哪些参数需要被包含。幸 运的是，这很简单，因为你可以从文档中找到答案😊。在 文档中，有两个术语与最常见的整齐评估子类型相对应：\n\n数据屏蔽（Data-masking）：这用于如arrange()、filter()和summarize()等函数，它们使用变量进行计算。\n整齐选择（Tidy-selection）：这用于如select()、relocate()和rename()等函数，它们用于选择变量。\n\n对于哪些参数使用整齐评估，你的直觉应该足以应对许多常见函数——只需考虑你是否可以计算（例如，x + 1）或选择（例如，a:x）。\n在以下部分，我们将探讨一旦你理解了拥抱的概念后，你可能会编写的各种实用函数。\n\n\n25.3.3 常见用例\n如果你在进行初步数据探索时经常执行相同的汇总操作，你可能会考虑将它们封装成一个辅助函数：\n\nsummary6 &lt;- function(data, var) {\n  data |&gt; summarize(\n    min = min({{ var }}, na.rm = TRUE),\n    mean = mean({{ var }}, na.rm = TRUE),\n    median = median({{ var }}, na.rm = TRUE),\n    max = max({{ var }}, na.rm = TRUE),\n    n = n(),\n    n_miss = sum(is.na({{ var }})),\n    .groups = \"drop\"\n  )\n}\n\ndiamonds |&gt; summary6(carat)\n#&gt; # A tibble: 1 × 6\n#&gt;     min  mean median   max     n n_miss\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1   0.2 0.798    0.7  5.01 53940      0\n\n(每当你在辅助函数中封装summarize()时，我们认为将.groups = \"drop\"设置为避免消息并将数据保持在未分组状态是一个好习惯。)\n这个函数的优点在于，因为它封装了summarize()，所以你可以对分组数据使用它：\n\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summary6(carat)\n#&gt; # A tibble: 5 × 7\n#&gt;   cut         min  mean median   max     n n_miss\n#&gt;   &lt;ord&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1 Fair       0.22 1.05    1     5.01  1610      0\n#&gt; 2 Good       0.23 0.849   0.82  3.01  4906      0\n#&gt; 3 Very Good  0.2  0.806   0.71  4    12082      0\n#&gt; 4 Premium    0.2  0.892   0.86  4.01 13791      0\n#&gt; 5 Ideal      0.2  0.703   0.54  3.5  21551      0\n\n此外，由于传递给summarize的参数也使用数据屏蔽，这意味着summary6()函数中的var参数也使用数据屏蔽。这 意味着你还可以对计算后的变量进行汇总：\n\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summary6(log10(carat))\n#&gt; # A tibble: 5 × 7\n#&gt;   cut          min    mean  median   max     n n_miss\n#&gt;   &lt;ord&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1 Fair      -0.658 -0.0273  0      0.700  1610      0\n#&gt; 2 Good      -0.638 -0.133  -0.0862 0.479  4906      0\n#&gt; 3 Very Good -0.699 -0.164  -0.149  0.602 12082      0\n#&gt; 4 Premium   -0.699 -0.125  -0.0655 0.603 13791      0\n#&gt; 5 Ideal     -0.699 -0.225  -0.268  0.544 21551      0\n\n要对多个变量进行汇总，你需要等到 小节 26.2 ，在那里你将学习如何使用across()函数。\n另一个流行的summarize()辅助函数是count()的一个版本，它还会计算比例：\n\n# https://twitter.com/Diabb6/status/1571635146658402309\ncount_prop &lt;- function(df, var, sort = FALSE) {\n  df |&gt;\n    count({{ var }}, sort = sort) |&gt;\n    mutate(prop = n / sum(n))\n}\n\ndiamonds |&gt; count_prop(clarity)\n#&gt; # A tibble: 8 × 3\n#&gt;   clarity     n   prop\n#&gt;   &lt;ord&gt;   &lt;int&gt;  &lt;dbl&gt;\n#&gt; 1 I1        741 0.0137\n#&gt; 2 SI2      9194 0.170 \n#&gt; 3 SI1     13065 0.242 \n#&gt; 4 VS2     12258 0.227 \n#&gt; 5 VS1      8171 0.151 \n#&gt; 6 VVS2     5066 0.0939\n#&gt; # ℹ 2 more rows\n\n这个函数有三个参数：df、var 和 sort，其中只有 var 需要被包含在括号中，因为它被传递给 count() 函数，该函数对所有变量使用数据屏蔽。请 注意，我们为 sort 设置了一个默认值，因此如果用户不提供自己的值，它将默认为 FALSE。\n或者，你可能想为数据的子集找到一个变量的已排序的唯一值，而不是提供一个变量和一个值来进行筛选，我们将允许用户提供一个条件。\n\nunique_where &lt;- function(df, condition, var) {\n  df |&gt; \n    filter({{ condition }}) |&gt; \n    distinct({{ var }}) |&gt; \n    arrange({{ var }})\n}\n\n# Find all the destinations in December\nflights |&gt; unique_where(month == 12, dest)\n#&gt; # A tibble: 96 × 1\n#&gt;   dest \n#&gt;   &lt;chr&gt;\n#&gt; 1 ABQ  \n#&gt; 2 ALB  \n#&gt; 3 ATL  \n#&gt; 4 AUS  \n#&gt; 5 AVL  \n#&gt; 6 BDL  \n#&gt; # ℹ 90 more rows\n\n在这里，我们将 condition 放在括号中，因为它被传递给 filter() 函数；而 var 被放在括号中，因为它被传递给 distinct() 和 arrange() 函数。\n我们已经使所有这些示例都将数据框作为第一个参数，但如果你反复使用相同的数据，那么将数据硬编码到函数中可能是有意义的。例 如，下面的函数总是与 flights 数据集一起工作，并且总是选择 time_hour、carrier 和 flight，因为它们构成了复合主键，使你能够标识一行。\n\nsubset_flights &lt;- function(rows, cols) {\n  flights |&gt; \n    filter({{ rows }}) |&gt; \n    select(time_hour, carrier, flight, {{ cols }})\n}\n\n\n\n25.3.4 数据屏蔽与整齐选择\n有时你想在使用数据屏蔽的函数内部选择变量。例 如，你想编写一个名为count_missing()的函数，用于计算行中缺失观测值的数量。你 可能会尝试编写如下内容：\n\ncount_missing &lt;- function(df, group_vars, x_var) {\n  df |&gt; \n    group_by({{ group_vars }}) |&gt; \n    summarize(\n      n_miss = sum(is.na({{ x_var }})),\n      .groups = \"drop\"\n    )\n}\n\nflights |&gt; \n  count_missing(c(year, month, day), dep_time)\n#&gt; Error in `group_by()`:\n#&gt; ℹ In argument: `c(year, month, day)`.\n#&gt; Caused by error:\n#&gt; ! `c(year, month, day)` must be size 336776 or 1, not 1010328.\n\n这不起作用，因为group_by()使用的是数据屏蔽，而不是整齐选择。我 们可以通过使用方便的pick()函数来绕过这个问题，该函数允许你在数据屏蔽函数内部使用整齐选择：\n\ncount_missing &lt;- function(df, group_vars, x_var) {\n  df |&gt; \n    group_by(pick({{ group_vars }})) |&gt; \n    summarize(\n      n_miss = sum(is.na({{ x_var }})),\n      .groups = \"drop\"\n  )\n}\n\nflights |&gt; \n  count_missing(c(year, month, day), dep_time)\n#&gt; # A tibble: 365 × 4\n#&gt;    year month   day n_miss\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1  2013     1     1      4\n#&gt; 2  2013     1     2      8\n#&gt; 3  2013     1     3     10\n#&gt; 4  2013     1     4      6\n#&gt; 5  2013     1     5      3\n#&gt; 6  2013     1     6      1\n#&gt; # ℹ 359 more rows\n\npick()的另一个方便的用途是制作二维计数表。在 这里，我们使用行和列中的所有变量进行计数，然后使用pivot_wider()将计数重新排列成网格形式：\n\n# https://twitter.com/pollicipes/status/1571606508944719876\ncount_wide &lt;- function(data, rows, cols) {\n  data |&gt; \n    count(pick(c({{ rows }}, {{ cols }}))) |&gt; \n    pivot_wider(\n      names_from = {{ cols }}, \n      values_from = n,\n      names_sort = TRUE,\n      values_fill = 0\n    )\n}\n\ndiamonds |&gt; count_wide(c(clarity, color), cut)\n#&gt; # A tibble: 56 × 7\n#&gt;   clarity color  Fair  Good `Very Good` Premium Ideal\n#&gt;   &lt;ord&gt;   &lt;ord&gt; &lt;int&gt; &lt;int&gt;       &lt;int&gt;   &lt;int&gt; &lt;int&gt;\n#&gt; 1 I1      D         4     8           5      12    13\n#&gt; 2 I1      E         9    23          22      30    18\n#&gt; 3 I1      F        35    19          13      34    42\n#&gt; 4 I1      G        53    19          16      46    16\n#&gt; 5 I1      H        52    14          12      46    38\n#&gt; 6 I1      I        34     9           8      24    17\n#&gt; # ℹ 50 more rows\n\n虽然我们的示例主要关注了 dplyr，但整齐评估也是 tidyr 的基础。如 果你查看pivot_wider()的文档，你会看到names_from参数使用了整齐选择。\n\n\n25.3.5 练习\n\n使用来自nycflights13的数据集，编写如下函数:\n\n找到所有被取消的航班 (即到达时间为空值is.na(arr_time)) 或延误超过一个小时的航班。\n\nflights |&gt; filter_severe()\n\n计算被取消的航班数量以及延误超过一个小时的航班数量。\n\nflights |&gt; group_by(dest) |&gt; summarize_severe()\n\n找到所有被取消或延误超过用户指定小时数的航班：\n\nflights |&gt; filter_severe(hours = 2)\n\n根据用户提供的变量，汇总天气数据以计算最小值、平均值和最大值：\n\nweather |&gt; summarize_weather(temp)\n\n将用户提供的使用时钟时间 (例如，出发时间dep_time、到达时间arr_time等) 的变量转换为十进制时间 (即小时 + (分钟 / 60))。\n\nflights |&gt; standardize_time(sched_dep_time)\n\n\n对于以下每个函数，列出所有使用整齐评估的参数，并描述它们是否使用数据屏蔽或整齐选择: distinct(), count(), group_by(), rename_with(), slice_min(), slice_sample()。\n将以下函数泛化，以便你可以提供任意数量的变量进行计数。\n\ncount_prop &lt;- function(df, var, sort = FALSE) {\n  df |&gt;\n    count({{ var }}, sort = sort) |&gt;\n    mutate(prop = n / sum(n))\n}",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#绘图函数",
    "href": "functions.html#绘图函数",
    "title": "25  函数",
    "section": "25.4 绘图函数",
    "text": "25.4 绘图函数\n有时你可能希望返回一个图，而不是返回一个数据框。幸 运的是，你可以使用ggplot2中的相同技术，因为aes()是一个数据屏蔽函数。例 如，假设你要制作很多直方图：\n\ndiamonds |&gt; \n  ggplot(aes(x = carat)) +\n  geom_histogram(binwidth = 0.1)\n\ndiamonds |&gt; \n  ggplot(aes(x = carat)) +\n  geom_histogram(binwidth = 0.05)\n\n如果你能将这个封装成一个直方图函数，那不是很好吗？一 旦你知道aes()是一个数据屏蔽函数，并且你需要接受这个事实，那么这易如反掌。\n\nhistogram &lt;- function(df, var, binwidth = NULL) {\n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth)\n}\n\ndiamonds |&gt; histogram(carat, 0.1)\n\n\n\n\n\n\n\n\n请注意，histogram()返回一个ggplot2图，这意味着如果你想要的话，你仍然可以在上面添加额外的组件。只 是记得将|&gt;切换为+：\n\ndiamonds |&gt; \n  histogram(carat, 0.1) +\n  labs(x = \"Size (in carats)\", y = \"Number of diamonds\")\n\n\n25.4.1 更多变量\n向组合中添加更多变量非常直接。例 如，你可能想要通过叠加一条平滑线和一条直线来轻松查看数据集是否为线性：\n\n# https://twitter.com/tyler_js_smith/status/1574377116988104704\nlinearity_check &lt;- function(df, x, y) {\n  df |&gt;\n    ggplot(aes(x = {{ x }}, y = {{ y }})) +\n    geom_point() +\n    geom_smooth(method = \"loess\", formula = y ~ x, color = \"red\", se = FALSE) +\n    geom_smooth(method = \"lm\", formula = y ~ x, color = \"blue\", se = FALSE) \n}\n\nstarwars |&gt; \n  filter(mass &lt; 1000) |&gt; \n  linearity_check(mass, height)\n\n\n\n\n\n\n\n\n或者，对于大型数据集的过度绘图，你可能想要使用彩色散点图作为替代方案：\n\n# https://twitter.com/ppaxisa/status/1574398423175921665\nhex_plot &lt;- function(df, x, y, z, bins = 20, fun = \"mean\") {\n  df |&gt; \n    ggplot(aes(x = {{ x }}, y = {{ y }}, z = {{ z }})) + \n    stat_summary_hex(\n      aes(color = after_scale(fill)), # make border same color as fill\n      bins = bins, \n      fun = fun,\n    )\n}\n\ndiamonds |&gt; hex_plot(carat, price, depth)\n\n\n\n\n\n\n\n\n\n\n25.4.2 与tidyverse其他组件结合\n一些最有用的辅助工具将数据处理与ggplot2结合使用。例 如，如果你想要制作一个垂直条形图，并使用fct_infreq()自动按频数顺序对条形进行排序。由 于条形图是垂直的，因此我们还需要反转通常的顺序，以便最高的值位于顶部：\n\nsorted_bars &lt;- function(df, var) {\n  df |&gt; \n    mutate({{ var }} := fct_rev(fct_infreq({{ var }})))  |&gt;\n    ggplot(aes(y = {{ var }})) +\n    geom_bar()\n}\n\ndiamonds |&gt; sorted_bars(clarity)\n\n\n\n\n\n\n\n\n在这里，我们必须使用一个新的操作符 :=（通常被称为“海象操作符”），因为我们基于用户提供的数据生成变量名。变 量名放在 = 的左侧，但 R 的语法不允许除了单个字面名称之外的任何东西放在 = 的左侧。为 了解决这个问题，我们使用特殊操作符 :=，tidy 评估将其视为与 = 完全相同。\n或者，你可能想要轻松地只为数据的一个子集绘制条形图：\n\nconditional_bars &lt;- function(df, condition, var) {\n  df |&gt; \n    filter({{ condition }}) |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_bar()\n}\n\ndiamonds |&gt; conditional_bars(cut == \"Good\", clarity)\n\n\n\n\n\n\n\n\n你也可以发挥创造力，以其他方式显示数据汇总。你 可以在https://gist.github.com/GShotwell/b19ef520b6d56f61a830fabb3454965b找到一个很酷的应用；它使用坐标轴标签来显示最高值。随 着你对ggplot2的了解越来越多，你的函数功能将会继续增强。\n最后，我们将用一个更复杂的案例来结束：标记你创建的图。\n\n\n25.4.3 标记\n还记得我们之前展示的直方图函数吗？\n\nhistogram &lt;- function(df, var, binwidth = NULL) {\n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth)\n}\n\n如果我们能够用所使用的变量和组距来标记输出，那不是很好吗？要 做到这一点，我们将不得不深入了解整齐评估，并使用我们尚未提及的rlang包中的一个函数。r lang是一个底层包，tidyverse中的几乎每个其他包都使用它，因为它实现了整齐评估 (以及其他许多有用的工具)。\n为了解决标记问题，我们可以使用rlang::englue()（注意：实际函数名应该是rlang::glue()）。它 的工作原理类似于str_glue()，所以任何被大括号{}包裹的值都会被插入到字符串中。但 它也理解{{}}，会自动插入适当的变量名：\n\nhistogram &lt;- function(df, var, binwidth) {\n  label &lt;- rlang::englue(\"A histogram of {{var}} with binwidth {binwidth}\")\n  \n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth) + \n    labs(title = label)\n}\n\ndiamonds |&gt; histogram(carat, 0.1)\n\n\n\n\n\n\n\n\n你可以在ggplot2图的任何需要提供字符串的地方使用相同的方法。\n\n\n25.4.4 练习\n通过逐步实施以下每个步骤，构建一个功能丰富的绘图函数：\n\n给定数据集和x、y变量，绘制散点图。\n添加最佳拟合线（即没有标准误差的线性模型）。\n添加标题。",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#风格",
    "href": "functions.html#风格",
    "title": "25  函数",
    "section": "25.5 风格",
    "text": "25.5 风格\nR不关心你的函数或参数叫什么，但这些名称对人们来说非常重要。理 想情况下，你的函数名应该简短，但又能清楚地表达函数的功能。这 很难！但 清晰比简短更重要，因为 RStudio 的自动补全功能使得输入长名称变得相对容易。\n一般来说，函数名应该是动词，参数应该是名词。但 也有一些例外：如果函数计算的是一个非常知名的名词 (比如mean()比compute_mean()更好)，或者访问对象的某个属性(比如coef()比get_coefficients()更好)，那么使用名词也是可以的。请 根据你的最佳判断来命名，如果后来发现更好的名称，不要担心重命名函数。\n\n# Too short\nf()\n\n# Not a verb, or descriptive\nmy_awesome_function()\n\n# Long, but clear\nimpute_missing()\ncollapse_years()\n\nR 也不关心你在函数中使用空格的方式，但未来的读者会关心。请 继续遵循 章节 4 中的规则。此 外，function()后面应该始终跟着花括号（{}），并且其内容应该额外缩进两个空格。这 样，通过浏览左侧边距，可以更容易地看到代码中的层次结构。\n\n# Missing extra two spaces\ndensity &lt;- function(color, facets, binwidth = 0.1) {\ndiamonds |&gt; \n  ggplot(aes(x = carat, y = after_stat(density), color = {{ color }})) +\n  geom_freqpoly(binwidth = binwidth) +\n  facet_wrap(vars({{ facets }}))\n}\n\n# Pipe indented incorrectly\ndensity &lt;- function(color, facets, binwidth = 0.1) {\n  diamonds |&gt; \n  ggplot(aes(x = carat, y = after_stat(density), color = {{ color }})) +\n  geom_freqpoly(binwidth = binwidth) +\n  facet_wrap(vars({{ facets }}))\n}\n\n正如你所看到的，我们建议在{ }内部添加额外的空格。这 使得很容易看出异常的发生。\n\n25.5.1 练习\n\n阅读下面两个函数的源代码，弄清楚它们的作用，然后集思广益想出更好的名字。\n\nf1 &lt;- function(string, prefix) {\n  str_sub(string, 1, str_length(prefix)) == prefix\n}\n\nf3 &lt;- function(x, y) {\n  rep(y, length.out = length(x))\n}\n\n拿一个你最近写的函数，花5分钟头脑风暴为它和它的参数取一个更好的名字。\n讨论一下为什么norm_r(),norm_d()等会比rnorm(),dnorm()更好，并同时讨论相反的观点。然 后，我们来看看如何使这些名称更加清晰。",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#小结",
    "href": "functions.html#小结",
    "title": "25  函数",
    "section": "25.6 小结",
    "text": "25.6 小结\n在本章中，你学习了如何为三种有用的场景编写函数：创建向量、创建数据框或创建图形。在 此过程中，你看到了许多示例，希望这些示例能够激发你的创造力，并为你提供一些关于函数如何帮助你分析代码的想法。\n我们只向你展示了函数的基础知识，还有很多内容需要学习。以 下是一些深入学习的地方：\n\n要了解更多关于使用整齐评估进行编程的信息，请参阅 programming with dplyr 和 programming with tidyr 的有用方法，并在 What is data-masking and why do I need {{? 中了解更多关于理论的知识。\n要了解更多关于减少ggplot2代码中重复性的信息，请阅读ggplot2书籍中的Programming with ggplot2 章节。\n有关函数风格的更多建议，请参阅 tidyverse style guide。\n\n在下一章中，我们将深入探讨迭代，它为你提供了更多减少代码重复性的工具。",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "iteration.html",
    "href": "iteration.html",
    "title": "26  迭代",
    "section": "",
    "text": "26.1 引言\n在这一章中，你将学习到用于迭代的工具，即在不同对象上重复执行相同的操作。R 语言中的迭代通常看起来与其他编程语言有很大的不同，因为R语言中的很多迭代是隐式的，我们可以免费得到它。\n例如，如果你想在R中将数值向量x翻倍，只需写2 * x即可。而 在大多数其他语言中，你可能需要使用某种形式的for循环来明确地将x的每个元素翻倍。\n本书已经向你介绍了一些虽小但功能强大的工具，这些工具可以对多个“事物”执行相同的操作：\n现在是时候学习一些更通用的工具了，这些工具通常被称为函数式编程 (functional programming) 工具，因为它们建立在将其他函数作为输入的函数之上。学 习函数式编程可能会变得抽象化，但在本章中，我们将通过关注三个常见任务来使内容具体化：修改多个列、读取多个文件以及保存多个对象。",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>迭代</span>"
    ]
  },
  {
    "objectID": "iteration.html#引言",
    "href": "iteration.html#引言",
    "title": "26  迭代",
    "section": "",
    "text": "facet_wrap() 和 facet_grid() 为每个子集绘制一个图形；\ngroup_by() 加上 summarize() 为每个子集计算摘要统计统计量；\nunnest_wider() 和 unnest_longer() 为列表列中的每个元素创建新的行和列。\n\n\n\n26.1.1 必要条件\n在本章中，我们将重点关注由dplyr和purrr提供的工具，它们都是tidyverse的核心成员。你 之前已经见过dplyr，但purrr是新的。我 们本章只会使用purrr的几个函数，但随着你编程技能的提高，它是一个非常值得探索的包。\n\nlibrary(tidyverse)",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>迭代</span>"
    ]
  },
  {
    "objectID": "iteration.html#sec-across",
    "href": "iteration.html#sec-across",
    "title": "26  迭代",
    "section": "26.2 修改多列",
    "text": "26.2 修改多列\n想象一下你有一个简单的tibble，你想要计算每一列的观察值数量以及每一列的中位数。\n\ndf &lt;- tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\n你可以使用复制-粘贴:\n\ndf |&gt; summarize(\n  n = n(),\n  a = median(a),\n  b = median(b),\n  c = median(c),\n  d = median(d),\n)\n#&gt; # A tibble: 1 × 5\n#&gt;       n      a      b       c     d\n#&gt;   &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1    10 -0.246 -0.287 -0.0567 0.144\n\n这打破了我们的经验法则，即永远不要复制粘贴超过两次，你可以想象，如果你有数十甚至数百列，这将变得非常繁琐。相 反，你可以使用across():\n\ndf |&gt; summarize(\n  n = n(),\n  across(a:d, median),\n)\n#&gt; # A tibble: 1 × 5\n#&gt;       n      a      b       c     d\n#&gt;   &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1    10 -0.246 -0.287 -0.0567 0.144\n\nacross()函数有三个特别重要的参数，我们将在以下部分中详细讨论它们。每 次使用across()时，你都会使用前两个参数：第一个参数.cols指定你想要遍历的列，第二个参数.fns指定要对每一列执行的操作。当 你需要对输出列的名称进行额外控制时，可以使用.names参数，这在与mutate()函数一起使用across()时尤为重要。此 外，我们还将讨论两个重要的变体if_any()和if_all()，它们与filter()函数一起工作。\n\n26.2.1 使用.cols选择列\nacross()函数的第一个参数.cols用于选择要进行转换的列。这 与select()函数的指定方式相同，因此你可以使用像starts_with()和ends_with()这样的函数，根据列名来选择列。\n有两种额外的选择技术对于across()特别有用：everything()和where()。e verything()很简单：它选择所有（非分组）列：\n\ndf &lt;- tibble(\n  grp = sample(2, 10, replace = TRUE),\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\ndf |&gt; \n  group_by(grp) |&gt; \n  summarize(across(everything(), median))\n#&gt; # A tibble: 2 × 5\n#&gt;     grp       a       b     c     d\n#&gt;   &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1 -0.0935 -0.0163 0.363 0.364\n#&gt; 2     2  0.312  -0.0576 0.208 0.565\n\n注意，分组列（在此处为 grp）不会被包含在across()中，因为它们在summarize()中会被自动保留。\nwhere()允许你根据列的类型来选择列：\n\nwhere(is.numeric) 选择所有数值列。\nwhere(is.character) 选择所有字符串列。\nwhere(is.Date) 选择所有日期列。\nwhere(is.POSIXct) 选择所有日期时间列。\nwhere(is.logical) 选择所有逻辑列。\n\n就像其他选择器一样，你可以使用布尔代数将它们组合起来。例 如 !where(is.numeric) 选择所有非数值列，而 starts_with(\"a\") & where(is.logical) 选择所有名称以 “a” 开头的逻辑列。\n\n\n26.2.2 调用单个函数\nacross() 的第二个参数定义了将如何转换每一列。在 如上所述的简单例子中，这将是一个现有的函数。这 是 R 语言的一个非常特别的功能：我们将一个函数 (如 median、mean、str_flatten 等) 传递给另一个函数 (即across)。这 是使 R 成为一种函数式编程语言的特性之一。\n需要注意的是，我们将这个函数传递给across()，因此是across()来调用它，我们自己不直接调用它。这 意味着函数名后面不应该有括号 ()。如 果你忘记了这一点，将会得到一个错误：\n\ndf |&gt; \n  group_by(grp) |&gt; \n  summarize(across(everything(), median()))\n#&gt; Error in `summarize()`:\n#&gt; ℹ In argument: `across(everything(), median())`.\n#&gt; Caused by error in `median.default()`:\n#&gt; ! argument \"x\" is missing, with no default\n\n出现此错误是因为你在没有输入的情况下调用函数，例如:\n\nmedian()\n#&gt; Error in median.default(): argument \"x\" is missing, with no default\n\n\n\n26.2.3 调用多个函数\n在更复杂的情况下，你可能想要提供额外的参数或执行多个转换。让 我们用一个简单的例子来说明这个问题：如果我们的数据中有一些缺失值，会发生什么？m edian()函数会传播这些缺失值，导致我们得到一个次优的输出：\n\nrnorm_na &lt;- function(n, n_na, mean = 0, sd = 1) {\n  sample(c(rnorm(n - n_na, mean = mean, sd = sd), rep(NA, n_na)))\n}\n\ndf_miss &lt;- tibble(\n  a = rnorm_na(5, 1),\n  b = rnorm_na(5, 1),\n  c = rnorm_na(5, 2),\n  d = rnorm(5)\n)\ndf_miss |&gt; \n  summarize(\n    across(a:d, median),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b     c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1    NA    NA    NA  1.15     5\n\n如果我们能够将na.rm = TRUE传递给median()来移除这些缺失值，那将是非常好的。要 做到这一点，我们需要创建一个新函数，该函数以期望的参数调用median()，而不是直接调用median()。\n\ndf_miss |&gt; \n  summarize(\n    across(a:d, function(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b      c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 0.139 -1.11 -0.387  1.15     5\n\n这样写有些冗长，所以 R 提供了一个方便的快捷方式：对于这种一次性或匿名函数1，你可以使用\\2来代替function。\n\ndf_miss |&gt; \n  summarize(\n    across(a:d, \\(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n\n在任何情况下，across()实际上都会展开为以下代码：\n\ndf_miss |&gt; \n  summarize(\n    a = median(a, na.rm = TRUE),\n    b = median(b, na.rm = TRUE),\n    c = median(c, na.rm = TRUE),\n    d = median(d, na.rm = TRUE),\n    n = n()\n  )\n\n当我们从median()中移除缺失值时，知道移除了多少值会很有用。我 们可以通过向across()提供两个函数来找出这一点：一个用于计算中位数，另一个用于计算缺失值的数量。你 可以通过向.fns提供一个命名列表来提供多个函数。\n\ndf_miss |&gt; \n  summarize(\n    across(a:d, list(\n      median = \\(x) median(x, na.rm = TRUE),\n      n_miss = \\(x) sum(is.na(x))\n    )),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 9\n#&gt;   a_median a_n_miss b_median b_n_miss c_median c_n_miss d_median d_n_miss\n#&gt;      &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1    0.139        1    -1.11        1   -0.387        2     1.15        0\n#&gt; # ℹ 1 more variable: n &lt;int&gt;\n\n如果你仔细观察，你可能会直觉地认为列名是使用类似{.col}_{.fn}的 glue 规范(小节 14.3.2) 来命名的，其中.col是原始列的名称，.fn是函数的名称。这 并不是巧合！正 如你将在下一节中学到的，你可以使用.names参数来提供你自己的 glue 规范。\n\n\n26.2.4 列名\nacross()函数的结果是根据.names参数中提供的规范来命名的。如 果我们想要函数的名字首先出现3，可以自己指定。\n\ndf_miss |&gt; \n  summarize(\n    across(\n      a:d,\n      list(\n        median = \\(x) median(x, na.rm = TRUE),\n        n_miss = \\(x) sum(is.na(x))\n      ),\n      .names = \"{.fn}_{.col}\"\n    ),\n    n = n(),\n  )\n#&gt; # A tibble: 1 × 9\n#&gt;   median_a n_miss_a median_b n_miss_b median_c n_miss_c median_d n_miss_d\n#&gt;      &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1    0.139        1    -1.11        1   -0.387        2     1.15        0\n#&gt; # ℹ 1 more variable: n &lt;int&gt;\n\n.names参数在你使用across()与mutate()一起时特别重要。默 认情况下，across()的输出会使用与输入相同的名称。这 意味着在mutate()内部的across()会替换现有的列。例 如，在这里我们使用coalesce()来将 NA 值替换为 0：\n\ndf_miss |&gt; \n  mutate(\n    across(a:d, \\(x) coalesce(x, 0))\n  )\n#&gt; # A tibble: 5 × 4\n#&gt;        a      b      c     d\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.434 -1.25   0     1.60 \n#&gt; 2  0     -1.43  -0.297 0.776\n#&gt; 3 -0.156 -0.980  0     1.15 \n#&gt; 4 -2.61  -0.683 -0.785 2.13 \n#&gt; 5  1.11   0     -0.387 0.704\n\n如果想要创建新的列，你可以使用.names参数来为输出指定新的名称：\n\ndf_miss |&gt; \n  mutate(\n    across(a:d, \\(x) coalesce(x, 0), .names = \"{.col}_na_zero\")\n  )\n#&gt; # A tibble: 5 × 8\n#&gt;        a      b      c     d a_na_zero b_na_zero c_na_zero d_na_zero\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1  0.434 -1.25  NA     1.60      0.434    -1.25      0         1.60 \n#&gt; 2 NA     -1.43  -0.297 0.776     0        -1.43     -0.297     0.776\n#&gt; 3 -0.156 -0.980 NA     1.15     -0.156    -0.980     0         1.15 \n#&gt; 4 -2.61  -0.683 -0.785 2.13     -2.61     -0.683    -0.785     2.13 \n#&gt; 5  1.11  NA     -0.387 0.704     1.11      0        -0.387     0.704\n\n\n\n26.2.5 筛选\nacross()非常适合与summarize()和mutate()一起使用，但是与filter()一起使用时则显得不太方便，因为你通常使用|或&来组合多个条件。显 然，across()可以帮助创建多个逻辑列，但接下来怎么做呢？因 此，dplyr 提供了across()的两个变体，分别叫做if_any()和if_all()：\n\n# same as df_miss |&gt; filter(is.na(a) | is.na(b) | is.na(c) | is.na(d))\ndf_miss |&gt; filter(if_any(a:d, is.na))\n#&gt; # A tibble: 4 × 4\n#&gt;        a      b      c     d\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.434 -1.25  NA     1.60 \n#&gt; 2 NA     -1.43  -0.297 0.776\n#&gt; 3 -0.156 -0.980 NA     1.15 \n#&gt; 4  1.11  NA     -0.387 0.704\n\n# same as df_miss |&gt; filter(is.na(a) & is.na(b) & is.na(c) & is.na(d))\ndf_miss |&gt; filter(if_all(a:d, is.na))\n#&gt; # A tibble: 0 × 4\n#&gt; # ℹ 4 variables: a &lt;dbl&gt;, b &lt;dbl&gt;, c &lt;dbl&gt;, d &lt;dbl&gt;\n\n\n\n26.2.6 函数中的 across()\nacross()在编程时特别有用，因为它允许你对多个列进行操作。例 如，Jacob Scott 使用了一个辅助函数，这个函数封装了一组lubridate函数，用于将所有日期列扩展为年、月和日列：\n\nexpand_dates &lt;- function(df) {\n  df |&gt; \n    mutate(\n      across(where(is.Date), list(year = year, month = month, day = mday))\n    )\n}\n\ndf_date &lt;- tibble(\n  name = c(\"Amy\", \"Bob\"),\n  date = ymd(c(\"2009-08-03\", \"2010-01-16\"))\n)\n\ndf_date |&gt; \n  expand_dates()\n#&gt; # A tibble: 2 × 5\n#&gt;   name  date       date_year date_month date_day\n#&gt;   &lt;chr&gt; &lt;date&gt;         &lt;dbl&gt;      &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1 Amy   2009-08-03      2009          8        3\n#&gt; 2 Bob   2010-01-16      2010          1       16\n\nacross()还使得在一个参数中提供多个列变得容易，因为第一个参数使用了整齐选择，你只需要记住要拥抱这个参数，正如我们在 小节 25.3.2 所讨论的。例 如，这个函数默认会计算数字列的均数。但 是，通过提供第二个参数，你可以选择仅汇总选定的列：\n\nsummarize_means &lt;- function(df, summary_vars = where(is.numeric)) {\n  df |&gt; \n    summarize(\n      across({{ summary_vars }}, \\(x) mean(x, na.rm = TRUE)),\n      n = n(),\n      .groups = \"drop\"\n    )\n}\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summarize_means()\n#&gt; # A tibble: 5 × 9\n#&gt;   cut       carat depth table price     x     y     z     n\n#&gt;   &lt;ord&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 Fair      1.05   64.0  59.1 4359.  6.25  6.18  3.98  1610\n#&gt; 2 Good      0.849  62.4  58.7 3929.  5.84  5.85  3.64  4906\n#&gt; 3 Very Good 0.806  61.8  58.0 3982.  5.74  5.77  3.56 12082\n#&gt; 4 Premium   0.892  61.3  58.7 4584.  5.97  5.94  3.65 13791\n#&gt; 5 Ideal     0.703  61.7  56.0 3458.  5.51  5.52  3.40 21551\n\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summarize_means(c(carat, x:z))\n#&gt; # A tibble: 5 × 6\n#&gt;   cut       carat     x     y     z     n\n#&gt;   &lt;ord&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 Fair      1.05   6.25  6.18  3.98  1610\n#&gt; 2 Good      0.849  5.84  5.85  3.64  4906\n#&gt; 3 Very Good 0.806  5.74  5.77  3.56 12082\n#&gt; 4 Premium   0.892  5.97  5.94  3.65 13791\n#&gt; 5 Ideal     0.703  5.51  5.52  3.40 21551\n\n\n\n26.2.7 与 pivot_longer() 比较\n在继续之前，值得一提的是across()和pivot_longer()之间的一个有趣联系 (小节 5.3)。在 许多情况下要执行相同的计算，你首先要重塑数据，然后按组(而不是按列)执行操作。以 下面这个多函数总汇总例:\n\ndf |&gt; \n  summarize(across(a:d, list(median = median, mean = mean)))\n#&gt; # A tibble: 1 × 8\n#&gt;   a_median a_mean b_median b_mean c_median c_mean d_median d_mean\n#&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1   0.0380  0.205  -0.0163 0.0910    0.260 0.0716    0.540  0.508\n\n我们可以通过将数据重塑为长格式，然后进行汇总计算得到相同的值：\n\nlong &lt;- df |&gt; \n  pivot_longer(a:d) |&gt; \n  group_by(name) |&gt; \n  summarize(\n    median = median(value),\n    mean = mean(value)\n  )\nlong\n#&gt; # A tibble: 4 × 3\n#&gt;   name   median   mean\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 a      0.0380 0.205 \n#&gt; 2 b     -0.0163 0.0910\n#&gt; 3 c      0.260  0.0716\n#&gt; 4 d      0.540  0.508\n\n如果你想要与across()相同的结构，你可以再次重塑:\n\nlong |&gt; \n  pivot_wider(\n    names_from = name,\n    values_from = c(median, mean),\n    names_vary = \"slowest\",\n    names_glue = \"{name}_{.value}\"\n  )\n#&gt; # A tibble: 1 × 8\n#&gt;   a_median a_mean b_median b_mean c_median c_mean d_median d_mean\n#&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1   0.0380  0.205  -0.0163 0.0910    0.260 0.0716    0.540  0.508\n\n了解这种技术是很有用的，因为有时你会遇到目前无法使用across()解决的问题：当有一组列，你想要同时对这些列进行计算时。例 如，假设我们的数据框同时包含值和权重，并且我们想要计算加权平均数：\n\ndf_paired &lt;- tibble(\n  a_val = rnorm(10),\n  a_wts = runif(10),\n  b_val = rnorm(10),\n  b_wts = runif(10),\n  c_val = rnorm(10),\n  c_wts = runif(10),\n  d_val = rnorm(10),\n  d_wts = runif(10)\n)\n\n目前无法使用across()4完成这个操作，但使用pivot_longer()相对来说比较直接：\n\ndf_long &lt;- df_paired |&gt; \n  pivot_longer(\n    everything(), \n    names_to = c(\"group\", \".value\"), \n    names_sep = \"_\"\n  )\ndf_long\n#&gt; # A tibble: 40 × 3\n#&gt;   group    val   wts\n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 a      0.715 0.518\n#&gt; 2 b     -0.709 0.691\n#&gt; 3 c      0.718 0.216\n#&gt; 4 d     -0.217 0.733\n#&gt; 5 a     -1.09  0.979\n#&gt; 6 b     -0.209 0.675\n#&gt; # ℹ 34 more rows\n\ndf_long |&gt; \n  group_by(group) |&gt; \n  summarize(mean = weighted.mean(val, wts))\n#&gt; # A tibble: 4 × 2\n#&gt;   group    mean\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1 a      0.126 \n#&gt; 2 b     -0.0704\n#&gt; 3 c     -0.360 \n#&gt; 4 d     -0.248\n\n如果需要，您可以将pivot_wider()返回到原始形式。\n\n\n26.2.8 练习\n\n通过以下方式练习你的 across()技能：\n\n计算palmerpenguins::penguins数据集中每一列的唯一值个数。\n计算mtcars中每一列的均数。\n按cut、clarity和color对diamonds进行分组，然后计算每个数值列的观测值个数以及均数。\n\n如果在across()中使用函数列表但没有为它们命名，会发生什么？输 出是如何命名的？\n调整expand_dates()函数，以便在日期列被扩展后自动删除它们。你 需要拥抱任何参数吗？\n解释这个函数中管道的每一步都做了什么。利 用了where()的什么特殊功能？\n\nshow_missing &lt;- function(df, group_vars, summary_vars = everything()) {\n  df |&gt; \n    group_by(pick({{ group_vars }})) |&gt; \n    summarize(\n      across({{ summary_vars }}, \\(x) sum(is.na(x))),\n      .groups = \"drop\"\n    ) |&gt;\n    select(where(\\(x) any(x &gt; 0)))\n}\nnycflights13::flights |&gt; show_missing(c(year, month, day))",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>迭代</span>"
    ]
  },
  {
    "objectID": "iteration.html#读取多个文件",
    "href": "iteration.html#读取多个文件",
    "title": "26  迭代",
    "section": "26.3 读取多个文件",
    "text": "26.3 读取多个文件\n在上一节中，学习了如何使用dplyr::across()对多列重复进行转换。在 本节中，你将学习如何使用purrr::map()对目录中的每个文件执行某项操作。让 我们从一个简单的动机开始：假设你有一个包含大量 Excel 表格的目录5，你想要读取它们。 可以使用复制和粘贴的方式来做这件事：\n\ndata2019 &lt;- readxl::read_excel(\"data/y2019.xlsx\")\ndata2020 &lt;- readxl::read_excel(\"data/y2020.xlsx\")\ndata2021 &lt;- readxl::read_excel(\"data/y2021.xlsx\")\ndata2022 &lt;- readxl::read_excel(\"data/y2022.xlsx\")\n\n然后可以使用dplyr::bind_rows()将它们合并在一起：\n\ndata &lt;- bind_rows(data2019, data2020, data2021, data2022)\n\n你可以想象，如果文件数量不是四个，而是成百上千个，那么这个过程很快就会变得繁琐。以 下部分将向你展示如何自动化此类任务。主 要有三个基本步骤：使用list.files()列出目录中的所有文件，然后使用purrr::map()将它们读入到一个列表中，接着使用purrr::list_rbind()将它们合并成一个单一的数据框。之 后，我们将讨论如何处理日益增加的异质性情况，即你不能对每个文件都执行完全相同的操作。\n\n26.3.1 列出目录中的文件\n顾名思义，list.files()会列出目录中的文件。你 总是会使用以下三个参数：\n\n第一个参数path是要查找的目录。\npattern是一个用于过滤文件名的正则表达式。最常见的模式是类似\\.xlsx$或\\.csv$这样的表达式，用于查找具有指定扩展名的所有文件。\nfull.names决定是否在输出中包含目录名。你通常希望这个参数为TRUE。\n\n为了让我们的动机示例具体化，这本书包含一个文件夹，其中包含来自gapminder包的 12 个 Excel 表格。每 个文件包含 142 个国家某一年的数据。我 们可以通过适当的list.files()调用列出所有这些文件：\n\npaths &lt;- list.files(\"data/gapminder\", pattern = \"[.]xlsx$\", full.names = TRUE)\npaths\n#&gt;  [1] \"data/gapminder/1952 2.xlsx\" \"data/gapminder/1952.xlsx\"  \n#&gt;  [3] \"data/gapminder/1957.xlsx\"   \"data/gapminder/1962.xlsx\"  \n#&gt;  [5] \"data/gapminder/1967.xlsx\"   \"data/gapminder/1972.xlsx\"  \n#&gt;  [7] \"data/gapminder/1977.xlsx\"   \"data/gapminder/1982.xlsx\"  \n#&gt;  [9] \"data/gapminder/1987.xlsx\"   \"data/gapminder/1992 2.xlsx\"\n#&gt; [11] \"data/gapminder/1992.xlsx\"   \"data/gapminder/1997.xlsx\"  \n#&gt; [13] \"data/gapminder/2002 2.xlsx\" \"data/gapminder/2002.xlsx\"  \n#&gt; [15] \"data/gapminder/2007 2.xlsx\" \"data/gapminder/2007.xlsx\"\n\n\n\n26.3.2 列表\n现在我们有了 12 个路径，我们可以调用read_excel() 12 次来得到 12 个数据框：\n\ngapminder_1952 &lt;- readxl::read_excel(\"data/gapminder/1952.xlsx\")\ngapminder_1957 &lt;- readxl::read_excel(\"data/gapminder/1957.xlsx\")\ngapminder_1962 &lt;- readxl::read_excel(\"data/gapminder/1962.xlsx\")\n ...,\ngapminder_2007 &lt;- readxl::read_excel(\"data/gapminder/2007.xlsx\")\n\n但是将每个工作表放入自己的变量中将使得在后续的步骤中处理它们变得困难。相 反，如果将它们放入一个单独的对象中，处理起来将更加方便。列 表是完成这项工作的完美工具：\n\nfiles &lt;- list(\n  readxl::read_excel(\"data/gapminder/1952.xlsx\"),\n  readxl::read_excel(\"data/gapminder/1957.xlsx\"),\n  readxl::read_excel(\"data/gapminder/1962.xlsx\"),\n  ...,\n  readxl::read_excel(\"data/gapminder/2007.xlsx\")\n)\n\n既然已经将这些数据框放入了一个列表中，如何从中取出一个呢？可 以使用files[[i]]来提取第i个元素：\n\nfiles[[3]]\n#&gt; # A tibble: 142 × 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         30.3  9240934      821.\n#&gt; 2 Albania     Europe       59.3  1476505     1942.\n#&gt; 3 Algeria     Africa       45.7 10270856     3014.\n#&gt; 4 Angola      Africa       32.0  4561361     3828.\n#&gt; 5 Argentina   Americas     64.4 19610538     6857.\n#&gt; 6 Australia   Oceania      70.3  9712569    10950.\n#&gt; # ℹ 136 more rows\n\n我们将在 小节 27.3 中更详细地讨论 [[ 。\n\n\n26.3.3 purrr::map() 和 list_rbind()\n手动将这些数据框收集到一个列表中的代码基本上和逐个读取文件的代码一样繁琐。幸 运的是，我们可以使用purrr::map()来更好地利用我们的路径向量。m ap()函数与across()类似，但map()是对向量中的每个元素进行操作，而不是对数据框中的每列进行操作。m ap(x, f)是以下操作的简写：\n\nlist(\n  f(x[[1]]),\n  f(x[[2]]),\n  ...,\n  f(x[[n]])\n)\n\n所以可以使用map()来获取一个包含12个数据框的列表:\n\nfiles &lt;- map(paths, readxl::read_excel)\nlength(files)\n#&gt; [1] 16\n\nfiles[[1]]\n#&gt; # A tibble: 142 × 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 Albania     Europe       55.2  1282697     1601.\n#&gt; 3 Algeria     Africa       43.1  9279525     2449.\n#&gt; 4 Angola      Africa       30.0  4232095     3521.\n#&gt; 5 Argentina   Americas     62.5 17876956     5911.\n#&gt; 6 Australia   Oceania      69.1  8691212    10040.\n#&gt; # ℹ 136 more rows\n\n(这是另一种数据结构，使用str()显示时可能不会特别紧凑，因此你可能希望将其加载到 RStudio 中并使用View()来检查它。)\n现在我们可以使用purrr::list_rbind()将这个数据框列表合并成一个单一的数据框：\n\nlist_rbind(files)\n#&gt; # A tibble: 2,272 × 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 Albania     Europe       55.2  1282697     1601.\n#&gt; 3 Algeria     Africa       43.1  9279525     2449.\n#&gt; 4 Angola      Africa       30.0  4232095     3521.\n#&gt; 5 Argentina   Americas     62.5 17876956     5911.\n#&gt; 6 Australia   Oceania      69.1  8691212    10040.\n#&gt; # ℹ 2,266 more rows\n\n我们也可以在管道中同时进行这两步:\n\npaths |&gt; \n  map(readxl::read_excel) |&gt; \n  list_rbind()\n\n如果想向read_excel()传递额外的参数怎么办？我 们可以使用与across()相同的方法。例 如，使用n_max = 1来查看数据的前几行通常很有用：\n\npaths |&gt; \n  map(\\(path) readxl::read_excel(path, n_max = 1)) |&gt; \n  list_rbind()\n#&gt; # A tibble: 16 × 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 Afghanistan Asia         28.8  8425333      779.\n#&gt; 3 Afghanistan Asia         30.3  9240934      821.\n#&gt; 4 Afghanistan Asia         32.0 10267083      853.\n#&gt; 5 Afghanistan Asia         34.0 11537966      836.\n#&gt; 6 Afghanistan Asia         36.1 13079460      740.\n#&gt; # ℹ 10 more rows\n\n这个很明显缺少了一些东西：没有year列，因为这个值记录在路径中，而不是单个文件中。接 下来我们将解决这个问题。\n\n\n26.3.4 路径中的数据\n有时，文件名本身就是数据的一部分。在 这个例子中，文件名包含了年份，而这个年份并没有在单个文件中被记录。要 将这一列添加到最终的数据框中，我们需要做两件事：\n首先，我们给路径向量命名。最 简单的方法是使用set_names()，该函数可以接受一个函数。在 这里，我们使用basename()函数从完整路径中提取仅包含文件名的部分：\n\npaths |&gt; set_names(basename) \n#&gt;                  1952 2.xlsx                    1952.xlsx \n#&gt; \"data/gapminder/1952 2.xlsx\"   \"data/gapminder/1952.xlsx\" \n#&gt;                    1957.xlsx                    1962.xlsx \n#&gt;   \"data/gapminder/1957.xlsx\"   \"data/gapminder/1962.xlsx\" \n#&gt;                    1967.xlsx                    1972.xlsx \n#&gt;   \"data/gapminder/1967.xlsx\"   \"data/gapminder/1972.xlsx\" \n#&gt;                    1977.xlsx                    1982.xlsx \n#&gt;   \"data/gapminder/1977.xlsx\"   \"data/gapminder/1982.xlsx\" \n#&gt;                    1987.xlsx                  1992 2.xlsx \n#&gt;   \"data/gapminder/1987.xlsx\" \"data/gapminder/1992 2.xlsx\" \n#&gt;                    1992.xlsx                    1997.xlsx \n#&gt;   \"data/gapminder/1992.xlsx\"   \"data/gapminder/1997.xlsx\" \n#&gt;                  2002 2.xlsx                    2002.xlsx \n#&gt; \"data/gapminder/2002 2.xlsx\"   \"data/gapminder/2002.xlsx\" \n#&gt;                  2007 2.xlsx                    2007.xlsx \n#&gt; \"data/gapminder/2007 2.xlsx\"   \"data/gapminder/2007.xlsx\"\n\n这些名称会自动被所有map函数保留，因此数据框列表将具有相同的名称：\n\nfiles &lt;- paths |&gt; \n  set_names(basename) |&gt; \n  map(readxl::read_excel)\n\n这使得对map()的调用简写为:\n\nfiles &lt;- list(\n  \"1952.xlsx\" = readxl::read_excel(\"data/gapminder/1952.xlsx\"),\n  \"1957.xlsx\" = readxl::read_excel(\"data/gapminder/1957.xlsx\"),\n  \"1962.xlsx\" = readxl::read_excel(\"data/gapminder/1962.xlsx\"),\n  ...,\n  \"2007.xlsx\" = readxl::read_excel(\"data/gapminder/2007.xlsx\")\n)\n\n你也可以使用[[按名称提取元素:\n\nfiles[[\"1962.xlsx\"]]\n#&gt; # A tibble: 142 × 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         32.0 10267083      853.\n#&gt; 2 Albania     Europe       64.8  1728137     2313.\n#&gt; 3 Algeria     Africa       48.3 11000948     2551.\n#&gt; 4 Angola      Africa       34    4826015     4269.\n#&gt; 5 Argentina   Americas     65.1 21283783     7133.\n#&gt; 6 Australia   Oceania      70.9 10794968    12217.\n#&gt; # ℹ 136 more rows\n\n然后，我们使用list_rbind()的names_to参数来告诉它将名称保存到一个名为year的新列中，并使用readr::parse_number()从字符串中提取数字。\n\npaths |&gt; \n  set_names(basename) |&gt; \n  map(readxl::read_excel) |&gt; \n  list_rbind(names_to = \"year\") |&gt; \n  mutate(year = parse_number(year))\n#&gt; # A tibble: 2,272 × 6\n#&gt;    year country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1  1952 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2  1952 Albania     Europe       55.2  1282697     1601.\n#&gt; 3  1952 Algeria     Africa       43.1  9279525     2449.\n#&gt; 4  1952 Angola      Africa       30.0  4232095     3521.\n#&gt; 5  1952 Argentina   Americas     62.5 17876956     5911.\n#&gt; 6  1952 Australia   Oceania      69.1  8691212    10040.\n#&gt; # ℹ 2,266 more rows\n\n在更复杂的情况下，可能有其他变量存储在目录名中，或者文件名可能包含多个数据部分。在 这种情况下，使用set_names()（不带任何参数）来记录完整路径，然后使用tidyr::separate_wider_delim()和相关函数将它们转换为有用的列。\n\npaths |&gt; \n  set_names() |&gt; \n  map(readxl::read_excel) |&gt; \n  list_rbind(names_to = \"year\") |&gt; \n  separate_wider_delim(year, delim = \"/\", names = c(NA, \"dir\", \"file\")) |&gt; \n  separate_wider_delim(file, delim = \".\", names = c(\"file\", \"ext\"))\n#&gt; # A tibble: 2,272 × 8\n#&gt;   dir       file   ext   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 gapminder 1952 2 xlsx  Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 gapminder 1952 2 xlsx  Albania     Europe       55.2  1282697     1601.\n#&gt; 3 gapminder 1952 2 xlsx  Algeria     Africa       43.1  9279525     2449.\n#&gt; 4 gapminder 1952 2 xlsx  Angola      Africa       30.0  4232095     3521.\n#&gt; 5 gapminder 1952 2 xlsx  Argentina   Americas     62.5 17876956     5911.\n#&gt; 6 gapminder 1952 2 xlsx  Australia   Oceania      69.1  8691212    10040.\n#&gt; # ℹ 2,266 more rows\n\n\n\n26.3.5 保存工作\n既然你已经完成了所有这些辛苦的工作，得到了一个整齐的数据框，现在是保存工作成果的好时机了：\n\ngapminder &lt;- paths |&gt; \n  set_names(basename) |&gt; \n  map(readxl::read_excel) |&gt; \n  list_rbind(names_to = \"year\") |&gt; \n  mutate(year = parse_number(year))\n\nwrite_csv(gapminder, \"gapminder.csv\")\n\n当你将来再次遇到这个问题时，你可以读取一个单独的 csv 文件。对 于大型的和更丰富的数据集，使用 parquet 可能是比 .csv 更好的选择，正如在 小节 22.4 中讨论的那样。\n如果你在一个项目中工作，我们建议你将执行这种数据准备工作的文件命名为类似 0-cleanup.R 的名字。文 件名中的 0 表示这应该在其他任何事情之前运行。\n如果你的输入数据文件随着时间的推移而发生变化，你可能需要考虑学习一个工具，如 targets，来设置你的数据清理代码，以便在输入文件之一被修改时自动重新运行。\n\n\n26.3.6 多个简单迭代\n在这里，我们只是直接从磁盘加载了数据，并幸运地得到了一个整齐的数据集。在 大多数情况下，你需要做一些额外的整理工作，有两个基本选项：你可以使用一个复杂的函数进行一轮迭代，或者使用简单的函数进行多轮迭代。根 据我们的经验，大多数人首先选择一个复杂的迭代，但通常使用多个简单迭代会更好。\n例如，假设你想读取一堆文件，过滤掉缺失值，进行重塑，然后合并。解 决这个问题的一个方法是编写一个函数，该函数接收一个文件并执行所有这些步骤，然后调用map()一次：\n\nprocess_file &lt;- function(path) {\n  df &lt;- read_csv(path)\n  \n  df |&gt; \n    filter(!is.na(id)) |&gt; \n    mutate(id = tolower(id)) |&gt; \n    pivot_longer(jan:dec, names_to = \"month\")\n}\n\npaths |&gt; \n  map(process_file) |&gt; \n  list_rbind()\n\n或者，你可以对每个文件执行process_file()中的每个步骤：\n\npaths |&gt; \n  map(read_csv) |&gt; \n  map(\\(df) df |&gt; filter(!is.na(id))) |&gt; \n  map(\\(df) df |&gt; mutate(id = tolower(id))) |&gt; \n  map(\\(df) df |&gt; pivot_longer(jan:dec, names_to = \"month\")) |&gt; \n  list_rbind()\n\n我们推荐这种方法，因为它阻止你在移动到其余文件之前只关注第一个文件的正确性。通 过在整理和清洗数据时考虑所有数据，你更有可能从整体上思考，并得出更高质量的结果。\n在这个特定的例子中，还有一个优化你可以做，那就是更早地将所有数据框绑定在一起。然 后，你可以依赖常规的 dplyr 行为：\n\npaths |&gt; \n  map(read_csv) |&gt; \n  list_rbind() |&gt; \n  filter(!is.na(id)) |&gt; \n  mutate(id = tolower(id)) |&gt; \n  pivot_longer(jan:dec, names_to = \"month\")\n\n\n\n26.3.7 异质数据\n不幸的是，有时无法直接从map()转到list_rbind()，因为数据框的异质性太强，导致list_rbind()失败或产生了一个不太有用的数据框。在 这种情况下，从加载所有文件开始仍然是有用的：\n\nfiles &lt;- paths |&gt; \n  map(readxl::read_excel) \n\n然后，一个有用的策略是捕获数据框的结构，以便你可以使用数据科学技能来探索它。这 样做的一种方法是使用下面这个df_types函数6，它返回一个 tibble，其中每列对应一行：\n\ndf_types &lt;- function(df) {\n  tibble(\n    col_name = names(df), \n    col_type = map_chr(df, vctrs::vec_ptype_full),\n    n_miss = map_int(df, \\(x) sum(is.na(x)))\n  )\n}\n\ndf_types(gapminder)\n#&gt; # A tibble: 6 × 3\n#&gt;   col_name  col_type  n_miss\n#&gt;   &lt;chr&gt;     &lt;chr&gt;      &lt;int&gt;\n#&gt; 1 year      double         0\n#&gt; 2 country   character      0\n#&gt; 3 continent character      0\n#&gt; 4 lifeExp   double         0\n#&gt; 5 pop       double         0\n#&gt; 6 gdpPercap double         0\n\n然后，你可以将这个函数应用于所有文件，并可能进行一些重塑操作，以便更容易地看到差异所在。例 如，这可以很容易地验证我们一直在使用的 gapminder 电子表格是否都是同质的：\n\nfiles |&gt; \n  map(df_types) |&gt; \n  list_rbind(names_to = \"file_name\") |&gt; \n  select(-n_miss) |&gt; \n  pivot_wider(names_from = col_name, values_from = col_type)\n#&gt; # A tibble: 16 × 6\n#&gt;   file_name   country   continent lifeExp pop    gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;    \n#&gt; 1 1952 2.xlsx character character double  double double   \n#&gt; 2 1952.xlsx   character character double  double double   \n#&gt; 3 1957.xlsx   character character double  double double   \n#&gt; 4 1962.xlsx   character character double  double double   \n#&gt; 5 1967.xlsx   character character double  double double   \n#&gt; 6 1972.xlsx   character character double  double double   \n#&gt; # ℹ 10 more rows\n\n如果文件的格式是异构的，那么在成功合并它们之前，你可能需要进行更多的处理。不 幸的是，接下来我们将让你自己去解决这个问题，但你可能想要阅读关于map_if()和map_at()的信息。m ap_if()允许你根据列表元素的值有选择地修改它们；map_at()允许你根据元素的名称有选择地修改它们。\n\n\n26.3.8 处理失败\n有时，你的数据结构可能极其复杂，以至于你甚至无法使用单个命令读取所有文件。然 后你就会遇到map()的一个缺点：要么整体成功，要么整体失败。m ap()要么成功地读取目录中的所有文件，要么因为错误而失败，一个文件都读不到。这 有点烦人：为什么一个失败就阻止你获得其他成功呢？\n幸运的是，purrr提供了一个辅助函数possibly()来解决这个问题。p ossibly()是一个函数操作符：它接受一个函数并返回一个行为经过修改过函数。具 体来说，possibly()会将函数从错误改为返回你指定的值。\n\nfiles &lt;- paths |&gt; \n  map(possibly(\\(path) readxl::read_excel(path), NULL))\n\ndata &lt;- files |&gt; list_rbind()\n\n这个做法在这里特别有效，因为list_rbind()（像许多 tidyverse 函数一样）会自动忽略 NULL 值。\n现在你已经有了所有可以轻松读取的数据，是时候解决困难的部分了，即弄清楚为什么一些文件加载失败以及该如何处理它们。首 先，获取那些失败的文件的路径：\n\nfailed &lt;- map_vec(files, is.null)\npaths[failed]\n#&gt; character(0)\n\n然后针对每个失败的文件再次调用导入函数，并找出哪里出了问题。",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>迭代</span>"
    ]
  },
  {
    "objectID": "iteration.html#保存多个输出",
    "href": "iteration.html#保存多个输出",
    "title": "26  迭代",
    "section": "26.4 保存多个输出",
    "text": "26.4 保存多个输出\n上一个部分学习了map()函数，它对于将多个文件读取到单个对象中非常有用。在 本部分，我们将探讨一个相反的问题：你如何能将一个或多个 R 对象保存到一个或多个文件中？我 们将通过三个例子来探索这个挑战：\n\n将多个数据框保存到一个数据库中。\n将多个数据框保存到多个 .csv 文件中。\n将多个图保存到多个 .png 文件中。\n\n\n26.4.1 写入数据库\n有时在同时处理许多文件时，不可能将所有数据一次性加载到内存中，因此你无法使用map(files, read_csv)。处 理这个问题的一种方法是将数据加载到数据库中，这样你就可以使用dbplyr仅访问你需要的部分。\n如果你很幸运，你所使用的数据库包会提供一个方便的函数，该函数接受一个路径向量并将它们全部加载到数据库中。这 就是duckdb的duckdb_read_csv()函数的情况。\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb())\nduckdb::duckdb_read_csv(con, \"gapminder\", paths)\n\n这种方法在这里会很有效，但我们没有 csv 文件，而是 Excel 电子表格，所以必须“手动”进行。当 你有一堆csv，而你正在使用的数据库没有一个函数可以将它们全部加载进来时，学习手工操作也会对你有所帮助。\n我们需要首先创建一个表来填充数据。最 简单的方法是通过创建一个模板，即一个包含我们想要的所有列但只包含样本数据的虚拟数据框。对 于 gapminder 数据，我们可以通过读取单个文件并向其添加年份来创建该模板：\n\ntemplate &lt;- readxl::read_excel(paths[[1]])\ntemplate$year &lt;- 1952\ntemplate\n#&gt; # A tibble: 142 × 6\n#&gt;   country     continent lifeExp      pop gdpPercap  year\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.  1952\n#&gt; 2 Albania     Europe       55.2  1282697     1601.  1952\n#&gt; 3 Algeria     Africa       43.1  9279525     2449.  1952\n#&gt; 4 Angola      Africa       30.0  4232095     3521.  1952\n#&gt; 5 Argentina   Americas     62.5 17876956     5911.  1952\n#&gt; 6 Australia   Oceania      69.1  8691212    10040.  1952\n#&gt; # ℹ 136 more rows\n\n现在我们可以连接到数据库，并使用DBI::dbCreateTable()将我们的模板转换为数据库表：\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb())\nDBI::dbCreateTable(con, \"gapminder\", template)\n\ndbCreateTable()并不使用template中的数据，而只是使用变量名和类型。所 以如果我们现在检查gapminder表，你会看到它是空的，但它具有我们需要的变量和预期的类型：\n\ncon |&gt; tbl(\"gapminder\")\n#&gt; # Source:   table&lt;gapminder&gt; [0 x 6]\n#&gt; # Database: DuckDB v1.0.0 [root@Darwin 23.6.0:R 4.4.1/:memory:]\n#&gt; # ℹ 6 variables: country &lt;chr&gt;, continent &lt;chr&gt;, lifeExp &lt;dbl&gt;, pop &lt;dbl&gt;,\n#&gt; #   gdpPercap &lt;dbl&gt;, year &lt;dbl&gt;\n\n接下来，我们需要一个函数，它接受一个单独的文件路径，将其读取到 R 中，并将结果添加到gapminder表中。我 们可以通过将read_excel()与DBI::dbAppendTable()结合使用来实现这一点：\n\nappend_file &lt;- function(path) {\n  df &lt;- readxl::read_excel(path)\n  df$year &lt;- parse_number(basename(path))\n  \n  DBI::dbAppendTable(con, \"gapminder\", df)\n}\n\n现在我们需要对paths中的每个元素调用一次append_file()函数。这 当然可以使用map()函数来实现：\n\npaths |&gt; map(append_file)\n\n但是我们并不关心append_file()的输出，所以与map()相比，使用walk()稍微更合适。w alk()的功能与map()相同，但它会丢弃输出：\n\npaths |&gt; walk(append_file)\n\n现在我们可以看看表中是否有所有的数据:\n\ncon |&gt; \n  tbl(\"gapminder\") |&gt; \n  count(year)\n#&gt; # Source:   SQL [?? x 2]\n#&gt; # Database: DuckDB v1.0.0 [root@Darwin 23.6.0:R 4.4.1/:memory:]\n#&gt;    year     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  1967   142\n#&gt; 2  1977   142\n#&gt; 3  1987   142\n#&gt; 4  1952   284\n#&gt; 5  1957   142\n#&gt; 6  1962   142\n#&gt; # ℹ more rows\n\n\n\n26.4.2 编写csv文件\n如果我们想要编写多个 csv 文件 (每个组一个) , 那么同样的基本原则也适用。让 我们想象一下，我们想要获取ggplot2::diamonds数据，并为每种clarity保存一个 csv 文件。首 先，我们需要创建这些单独的数据集。可 以通过多种方式做到这一点，但有一种我们特别喜欢的方法：group_nest()。\n\nby_clarity &lt;- diamonds |&gt; \n  group_nest(clarity)\n\nby_clarity\n#&gt; # A tibble: 8 × 2\n#&gt;   clarity               data\n#&gt;   &lt;ord&gt;   &lt;list&lt;tibble[,9]&gt;&gt;\n#&gt; 1 I1               [741 × 9]\n#&gt; 2 SI2            [9,194 × 9]\n#&gt; 3 SI1           [13,065 × 9]\n#&gt; 4 VS2           [12,258 × 9]\n#&gt; 5 VS1            [8,171 × 9]\n#&gt; 6 VVS2           [5,066 × 9]\n#&gt; # ℹ 2 more rows\n\n这会提供给我们一个新的tibble ，它有八行两列。c larity是我们的分组变量，而data是一个列表列，它包含每个clarity值对应的一个数据框：\n\nby_clarity$data[[1]]\n#&gt; # A tibble: 741 × 9\n#&gt;   carat cut       color depth table price     x     y     z\n#&gt;   &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.32 Premium   E      60.9    58   345  4.38  4.42  2.68\n#&gt; 2  1.17 Very Good J      60.2    61  2774  6.83  6.9   4.13\n#&gt; 3  1.01 Premium   F      61.8    60  2781  6.39  6.36  3.94\n#&gt; 4  1.01 Fair      E      64.5    58  2788  6.29  6.21  4.03\n#&gt; 5  0.96 Ideal     F      60.7    55  2801  6.37  6.41  3.88\n#&gt; 6  1.04 Premium   G      62.2    58  2801  6.46  6.41  4   \n#&gt; # ℹ 735 more rows\n\n在这里，让我们使用mutate()和str_glue()创建一个列来给出输出文件的名称：\n\nby_clarity &lt;- by_clarity |&gt; \n  mutate(path = str_glue(\"diamonds-{clarity}.csv\"))\n\nby_clarity\n#&gt; # A tibble: 8 × 3\n#&gt;   clarity               data path             \n#&gt;   &lt;ord&gt;   &lt;list&lt;tibble[,9]&gt;&gt; &lt;glue&gt;           \n#&gt; 1 I1               [741 × 9] diamonds-I1.csv  \n#&gt; 2 SI2            [9,194 × 9] diamonds-SI2.csv \n#&gt; 3 SI1           [13,065 × 9] diamonds-SI1.csv \n#&gt; 4 VS2           [12,258 × 9] diamonds-VS2.csv \n#&gt; 5 VS1            [8,171 × 9] diamonds-VS1.csv \n#&gt; 6 VVS2           [5,066 × 9] diamonds-VVS2.csv\n#&gt; # ℹ 2 more rows\n\n所以，如果要手工保存这些数据框，我们可以这样写:\n\nwrite_csv(by_clarity$data[[1]], by_clarity$path[[1]])\nwrite_csv(by_clarity$data[[2]], by_clarity$path[[2]])\nwrite_csv(by_clarity$data[[3]], by_clarity$path[[3]])\n...\nwrite_csv(by_clarity$by_clarity[[8]], by_clarity$path[[8]])\n\n这与我们之前使用map()的情况略有不同，因为有两个参数在变化，而不仅仅是一个。这 意味着我们需要一个新函数map2()，它同时改变第一和第二个参数。因 为我们同样不关心输出，所以想要使用walk2()而不是map2()。这 给了我们：\n\nwalk2(by_clarity$data, by_clarity$path, write_csv)\n\n\n\n26.4.3 保存图形\n我们可以采用相同的基本方法来创建许多图形。让 我们首先创建一个函数来绘制我们想要的图形:\n\ncarat_histogram &lt;- function(df) {\n  ggplot(df, aes(x = carat)) + geom_histogram(binwidth = 0.1)  \n}\n\ncarat_histogram(by_clarity$data[[1]])\n\n\n\n\n\n\n\n\n现在我们可以使用map()来创建一个包含多个图形7及其最终文件路径的列表：\n\nby_clarity &lt;- by_clarity |&gt; \n  mutate(\n    plot = map(data, carat_histogram),\n    path = str_glue(\"clarity-{clarity}.png\")\n  )\n\n然后使用walk2()和ggsave()来保存每个图形:\n\nwalk2(\n  by_clarity$path,\n  by_clarity$plot,\n  \\(path, plot) ggsave(path, plot, width = 6, height = 6)\n)\n\n这是以下内容的简写:\n\nggsave(by_clarity$path[[1]], by_clarity$plot[[1]], width = 6, height = 6)\nggsave(by_clarity$path[[2]], by_clarity$plot[[2]], width = 6, height = 6)\nggsave(by_clarity$path[[3]], by_clarity$plot[[3]], width = 6, height = 6)\n...\nggsave(by_clarity$path[[8]], by_clarity$plot[[8]], width = 6, height = 6)",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>迭代</span>"
    ]
  },
  {
    "objectID": "iteration.html#小结",
    "href": "iteration.html#小结",
    "title": "26  迭代",
    "section": "26.5 小结",
    "text": "26.5 小结\n在这一章中，你已经看到了如何使用显式迭代来解决在数据科学中经常遇到的三个问题：操作多个列、读取多个文件以及保存多个输出。但 一般来说，迭代是一种超能力：如果你知道正确的迭代方法，可以很容易地从解决一个问题转变为解决所有问题。一 旦你掌握了本章中的技术，我们强烈推荐你通过阅读《Advanced R》的 Functionals chapter 并查阅 purrr website 来进一步学习。\n如果你对其他语言中的迭代有所了解，可能会惊讶于我们没有讨论 for 循环。这 是因为 R 的数据分析导向改变了我们迭代的方式：在大多数情况下，你可以依靠现有的习惯用法来对每个列或每个组执行某些操作。而 当你不能这样做时，你通常可以使用像map()这样的函数式编程工具来对列表中的每个元素执行某些操作。然 而，你将在原始代码中看到 for 循环，因此你将在下一章中学习它们，届时我们将讨论一些重要的基础 R 工具。",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>迭代</span>"
    ]
  },
  {
    "objectID": "iteration.html#footnotes",
    "href": "iteration.html#footnotes",
    "title": "26  迭代",
    "section": "",
    "text": "匿名，是因为我们从未用&lt;-明确给它一个名称。程 序员用来称呼这种函数的另一个术语是“lambda 函数”。↩︎\n在旧版本的代码中，你可能会看到像~ .x + 1这样的语法。这 是编写匿名函数的另一种方式，但它只能在 tidyverse 函数内部使用，并且总是使用变量名.x。现 在我们推荐使用基础语法，即\\(x) x + 1。↩︎\n当前不能更改列的顺序，但可以在事后使用relocate()或类似的方法重新排序。↩︎\n也许有一天会有，但目前我们还不知道如何实现。↩︎\n如果你有一个包含相同格式 CSV 文件的目录，你可以使用 章节 20 中的方法。↩︎\n我们不会解释这个函数是如何工作的，但如果你查看所使用的函数的文档，应该能够自己弄清楚。↩︎\n你可以输出by_clarity$plot来得到一个粗略的动画——你会得到plots中每个元素的一个图形。注 意：这种情况并没有发生在我身上。↩︎",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>迭代</span>"
    ]
  },
  {
    "objectID": "base-R.html",
    "href": "base-R.html",
    "title": "27  R基础实用指南",
    "section": "",
    "text": "27.1 引言\n在编程部分的结尾，我们将快速介绍一些最重要的基础R函数，这些函数在本书中并没有讨论。这 些工具在你进行更多编程时会特别有用，并且会帮助你阅读在实际项目中遇到的代码。\n这是一个很好的时机来提醒你，tidyverse并不是解决数据科学问题的唯一方法。我 们在本书中教授tidyverse是因为tidyverse包共享一种共同的设计理念，增加了函数之间的一致性，并使每个新函数或包更容易学习和使用。不 使用基础R就无法使用tidyverse，因此实际上我们已经向你介绍了许多基础R函数：从library()来加载包，到sum()和mean()用于数值汇总，到factor、date和POSIXct数据类型，当然还有所有基本运算符如+、-、/、*、|、&和！。到 目前为止，我们还没有重点关注基础R工作流程，因此本章我们将重点介绍其中的一些。\n读完这本书后，你将学习使用基础R、data.table和其他包来解决相同问题的其他方法。当 你开始阅读其他人编写的R代码时，特别是如果你在使用StackOverflow时，你无疑会遇到这些其他方法。编 写使用多种方法的代码是完全可以的，不要让任何人告诉你不是这样！\n在本章中，我们将重点关注四个大主题：使用[进行子集选择，使用[[和$进行子集选择，apply函数族和for循环。最 后，我们将简要讨论两个基本的绘图函数。",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>R基础实用指南</span>"
    ]
  },
  {
    "objectID": "base-R.html#引言",
    "href": "base-R.html#引言",
    "title": "27  R基础实用指南",
    "section": "",
    "text": "27.1.1 必要条件\n这个包专注于R的基础功能，因此没有真正的必要条件，但为了解释一些差异，我们将加载tidyverse包。\n\nlibrary(tidyverse)",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>R基础实用指南</span>"
    ]
  },
  {
    "objectID": "base-R.html#sec-subset-many",
    "href": "base-R.html#sec-subset-many",
    "title": "27  R基础实用指南",
    "section": "27.2 利用 [ 选择多个元素",
    "text": "27.2 利用 [ 选择多个元素\n[用于从向量和数据框中提取子组件，其调用方式如x[i]或x[i, j]。在 本节中，我们将向您介绍[的强大功能，首先展示如何在向量中使用它，然后展示相同的原理如何直接扩展到二维（2d）结构，如数据框。之 后，我们将通过展示dplyr中的各种函数是如何作为[的特殊情况的例子来帮助你巩固这些知识。\n\n27.2.1 向量子集选择\n有五种主要的方式可以用来对向量进行子集选择，即可以利用作为x[i]中的i：\n\n正整数向量。使 用正整数进行子集选择会保留这些位置上的元素：\n\nx &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\")\nx[c(3, 2, 5)]\n#&gt; [1] \"three\" \"two\"   \"five\"\n\n通过重复某个位置，你实际上可以生成一个比输入更长的输出，这使得“子集选择”这个术语有点名不副实。\n\nx[c(1, 1, 5, 5, 5, 2)]\n#&gt; [1] \"one\"  \"one\"  \"five\" \"five\" \"five\" \"two\"\n\n负整数向量。 负值会删除指定位置的元素：\n\nx[c(-1, -3, -5)]\n#&gt; [1] \"two\"  \"four\"\n\n逻辑向量。使 用逻辑向量进行子集选择会保留所有与TRUE值对应的值。这 通常与比较函数一起使用时非常有用。\n\nx &lt;- c(10, 3, NA, 5, 8, 1, NA)\n\n# All non-missing values of x\nx[!is.na(x)]\n#&gt; [1] 10  3  5  8  1\n\n# All even (or missing!) values of x\nx[x %% 2 == 0]\n#&gt; [1] 10 NA  8 NA\n\n与filter()不同，NA 索引会被包含在输出中，并且以 NAs 的形式出现。\n字符向量。如 果你有一个命名的向量，你可以使用字符向量来对其进行子集选择：\n\nx &lt;- c(abc = 1, def = 2, xyz = 5)\nx[c(\"xyz\", \"def\")]\n#&gt; xyz def \n#&gt;   5   2\n\n与使用正整数进行子集选择一样，你可以使用字符向量来重复单个条目。\n不指定任何内容。最 后一种子集选择方式是什么都不指定，即x[]，这将返回完整的x。这 对于向量的子集选择来说并不实用，但正如我们稍后会看到的，当对像 tibble 这样的二维结构进行子集选择时，它是很有用的。\n\n\n\n27.2.2 数据框子集选择\n你可以使用多种不同的方式1 对数据框使用[，但最重要的方式是使用df[rows, cols]来独立选择行和列。 这里的rows和cols是上面描述的向量。 例如，df[rows, ]和df[, cols]分别只选择行或列，通过保留其他维度的空子集来实现。\n以下是一些示例:\n\ndf &lt;- tibble(\n  x = 1:3, \n  y = c(\"a\", \"e\", \"f\"), \n  z = runif(3)\n)\n\n# Select first row and second column\ndf[1, 2]\n#&gt; # A tibble: 1 × 1\n#&gt;   y    \n#&gt;   &lt;chr&gt;\n#&gt; 1 a\n\n# Select all rows and columns x and y\ndf[, c(\"x\" , \"y\")]\n#&gt; # A tibble: 3 × 2\n#&gt;       x y    \n#&gt;   &lt;int&gt; &lt;chr&gt;\n#&gt; 1     1 a    \n#&gt; 2     2 e    \n#&gt; 3     3 f\n\n# Select rows where `x` is greater than 1 and all columns\ndf[df$x &gt; 1, ]\n#&gt; # A tibble: 2 × 3\n#&gt;       x y         z\n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     2 e     0.834\n#&gt; 2     3 f     0.601\n\n我们稍后会回到$，但你应该能够根据上下文猜出df$x的作用：它从df中提取x变量。我 们在这里需要使用它，因为[不使用整齐评估（tidy evaluation），所以需要明确指定x变量的来源。\n在[的使用上，tibble 和数据框之间存在重要的区别。在 本书中我们主要使用了tibble，它们是数据框，但调整了一些行为以使你的工作更加轻松。在 大多数情况下，你可以互换使用“tibble”和“数据框”，所以当我们要特别关注 R 的内置数据框时，我们会写data.frame。如 果df是一个data.frame，那么df[, cols]会在col选择单个列时返回一个向量，在选择多个列时返回一个数据框。如 果df是一个 tibble，那么[总是会返回一个 tibble。\n\ndf1 &lt;- data.frame(x = 1:3)\ndf1[, \"x\"]\n#&gt; [1] 1 2 3\n\ndf2 &lt;- tibble(x = 1:3)\ndf2[, \"x\"]\n#&gt; # A tibble: 3 × 1\n#&gt;       x\n#&gt;   &lt;int&gt;\n#&gt; 1     1\n#&gt; 2     2\n#&gt; 3     3\n\n避免数据框中这种模糊性的一个方法是明确指定drop = FALSE：\n\ndf1[, \"x\" , drop = FALSE]\n#&gt;   x\n#&gt; 1 1\n#&gt; 2 2\n#&gt; 3 3\n\n\n\n27.2.3 dplyr等效函数\n有几个dplyr的函数是 [ 的特例：\n\nfilter() 相当于使用一个逻辑向量来选择行子集，同时确保排除缺失值：\n\ndf &lt;- tibble(\n  x = c(2, 3, 1, 1, NA), \n  y = letters[1:5], \n  z = runif(5)\n)\ndf |&gt; filter(x &gt; 1)\n\n# same as\ndf[!is.na(df$x) & df$x &gt; 1, ]\n\n在实际应用中另一种常见的技巧是使用which()函数，其有排除缺失值的附带作用：df[which(df$x &gt; 1), ]。\narrange() 相当于使用整数向量来选择子集行，这个整数向量通常是通过order()函数创建的：\n\ndf |&gt; arrange(x, y)\n\n# same as\ndf[order(df$x, df$y), ]\n\n你可以使用order(decreasing = TRUE)来将所有列按降序排序，或者使用-rank(col)来单独按降序排序某一列。\nselect()和relocate()都类似于使用字符向量来选择或重新排列列\n\ndf |&gt; select(x, z)\n\n# same as\ndf[, c(\"x\", \"z\")]\n\n\n基础R还提供了一个函数subset()，该函数结合了filter()和select()2的功能，名为。\n\ndf |&gt; \n  filter(x &gt; 1) |&gt; \n  select(y, z)\n#&gt; # A tibble: 2 × 2\n#&gt;   y           z\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1 a     0.157  \n#&gt; 2 b     0.00740\n\n\n# same as\ndf |&gt; subset(x &gt; 1, c(y, z))\n\n这个函数是dplyr语法中许多部分的灵感来源。\n\n\n27.2.4 练习\n\n创建函数，这些函数以向量为输入，并返回:\n\n偶数位置上的元素；\n除了最后一个值以外的所有元素；\n只有偶数 (且没有缺失值)。\n\n为什么x[-which(x &gt; 0)]不等同于x[x &lt;= 0]？阅 读which()的文档并进行一些实验来找出原因。",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>R基础实用指南</span>"
    ]
  },
  {
    "objectID": "base-R.html#sec-subset-one",
    "href": "base-R.html#sec-subset-one",
    "title": "27  R基础实用指南",
    "section": "27.3 使用$和[[选择元素",
    "text": "27.3 使用$和[[选择元素\n[用于选择多个元素，它与[[和$搭配使用，后两者用于提取单个元素。在 本节中，我们将向您展示如何使用[[和$从数据框中提取列，讨论data.frames和tibble之间的一些其他差异，并强调当与列表一起使用时，[和[[之间的一些重要差异。\n\n27.3.1 数据框\n[[和$可用于从数据框中提取列。[ [可以通过位置或名称进行访问，而$专门用于通过名称进行访问：\n\ntb &lt;- tibble(\n  x = 1:4,\n  y = c(10, 4, 1, 21)\n)\n\n# by position\ntb[[1]]\n#&gt; [1] 1 2 3 4\n\n# by name\ntb[[\"x\"]]\n#&gt; [1] 1 2 3 4\ntb$x\n#&gt; [1] 1 2 3 4\n\n它们还可以用于创建新列，与R 基础包中mutate()函数等价：\n\ntb$z &lt;- tb$x + tb$y\ntb\n#&gt; # A tibble: 4 × 3\n#&gt;       x     y     z\n#&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    10    11\n#&gt; 2     2     4     6\n#&gt; 3     3     1     4\n#&gt; 4     4    21    25\n\n除了transform()、with()和within()，还有其他几种 R 基础包中创建新列的方法。H adley 在https://gist.github.com/hadley/1986a273e384fb2d4d752c18ed71bedf上收集了一些示例。\n当进行快速汇总时，直接使用$符号是很方便的。例 如，如果你只想找到最大钻石的尺寸或者cut的可能值，那么就没有必要使用summarize()函数：\n\nmax(diamonds$carat)\n#&gt; [1] 5.01\n\nlevels(diamonds$cut)\n#&gt; [1] \"Fair\"      \"Good\"      \"Very Good\" \"Premium\"   \"Ideal\"\n\ndplyr也提供了一个与[[或$类似的等效函数pull()，这在@sec-data-transform 没有提到。p ull()接收一个变量名或变量位置，并仅返回该列。这 意味着我们可以使用管道操作符来重写上面的代码。\n\ndiamonds |&gt; pull(carat) |&gt; max()\n#&gt; [1] 5.01\n\ndiamonds |&gt; pull(cut) |&gt; levels()\n#&gt; [1] \"Fair\"      \"Good\"      \"Very Good\" \"Premium\"   \"Ideal\"\n\n\n\n27.3.2 Tibbles\n当涉及到$时，tibble和data.frame之间有几个重要区别。数 据框会匹配任何变量名的前缀（即所谓的部分匹配），并且如果某列不存在也不会报错：\nThere are a couple of important differences between tibbles and base data.frames when it comes to $. Data frames match the prefix of any variable names (so-called partial matching) and don’t complain if a column doesn’t exist:\n\ndf &lt;- data.frame(x1 = 1)\ndf$x\n#&gt; [1] 1\ndf$z\n#&gt; NULL\n\ntibble 更严格：它只精确匹配变量名，如果试图访问的列不存在，它会生成一个警告：\n\ntb &lt;- tibble(x1 = 1)\n\ntb$x\n#&gt; Warning: Unknown or uninitialised column: `x`.\n#&gt; NULL\ntb$z\n#&gt; Warning: Unknown or uninitialised column: `z`.\n#&gt; NULL\n\n出于这个原因，我们有时开玩笑说 tibble 很“懒惰”和“易怒”：它们做的少但抱怨的多。\n\n\n27.3.3 列表\n[[和$对于处理列表也非常重要，了解它们与[的区别很重要。让 我们用一个名为l的列表举例说明这些区别：\n\nl &lt;- list(\n  a = 1:3, \n  b = \"a string\", \n  c = pi, \n  d = list(-1, -5)\n)\n\n\n[用于提取子列表。无 论提取多少个元素，结果始终是一个列表。\n\nstr(l[1:2])\n#&gt; List of 2\n#&gt;  $ a: int [1:3] 1 2 3\n#&gt;  $ b: chr \"a string\"\n\nstr(l[1])\n#&gt; List of 1\n#&gt;  $ a: int [1:3] 1 2 3\n\nstr(l[4])\n#&gt; List of 1\n#&gt;  $ d:List of 2\n#&gt;   ..$ : num -1\n#&gt;   ..$ : num -5\n\n与向量一样，你可以使用逻辑向量、整数向量或字符向量来进行子集选择。\n[[和$用于从列表中提取单个组件。它 们会从列表中移除一层层次结构。\n\nstr(l[[1]])\n#&gt;  int [1:3] 1 2 3\n\nstr(l[[4]])\n#&gt; List of 2\n#&gt;  $ : num -1\n#&gt;  $ : num -5\n\nstr(l$a)\n#&gt;  int [1:3] 1 2 3\n\n\n[和[[之间的区别对于列表来说特别重要，因为[[会深入到列表中提取单个元素，而[则会返回一个新的、更小的列表。为 了帮助你记住这个区别，让我们看一下@fig-pepper 中展示的不寻常的胡椒瓶。如 果这个胡椒瓶代表你的列表胡椒瓶，那么pepper[1]就是一个只包含一包胡椒的胡椒瓶。p epper[2]看起来会一样，但会包含第二包胡椒。p epper[1:2]则是一个包含两包胡椒的胡椒瓶。而 pepper[[1]]则会提取出胡椒包本身。\n\n\n\n\n\n\n\n\n图 27.1: (Left) A pepper shaker that Hadley once found in his hotel room. (Middle) pepper[1]. (Right) pepper[[1]]\n\n\n\n\n\n同样的原则也适用于数据框使用一维运算符[时：df[\"x\"]返回一个单列的数据框，而df[[\"x\"]]返回一个向量。\n\n\n27.3.4 练习\n\n当你使用[[运算符和一个大于向量长度的正整数时，会发生什么？当 你使用不存在的名称进行子集选择时会发生什么？\npepper[[1]][1]会是什么？p epper[[1]][[1]]又是什么？",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>R基础实用指南</span>"
    ]
  },
  {
    "objectID": "base-R.html#apply家族",
    "href": "base-R.html#apply家族",
    "title": "27  R基础实用指南",
    "section": "27.4 apply家族",
    "text": "27.4 apply家族\n在 章节 26, 你学习了如dplyr::across()和映射家族（map family）函数这样的tidyverse迭代技术。在 这一节中，你将学习它们的等效函数，即应用家族（apply family）函数。在 这个前提下，apply和map是同义词，因为“将函数映射到向量的每个元素”的另一种说法就是“将函数应用到向量的每个元素”。在 这里，我们将为你快速概述这个家族，以便你在实际使用中识别它们。\n这个家族中最重要的成员是lapply()，它与purrr::map()3非常相似。 事实上，因为我们没有使用map()的任何高级功能，所以你可以将@sec-iteration 中的每个map()调用替换为lapply()。\n在基础R中没有与across()完全等效的函数，但你可以通过使用lapply()和[来接近这个效果。这 种操作可行是因为在底层，数据框是列的列表，因此对数据框调用lapply()会将函数应用到每一列。\n\ndf &lt;- tibble(a = 1, b = 2, c = \"a\", d = \"b\", e = 4)\n\n# First find numeric columns\nnum_cols &lt;- sapply(df, is.numeric)\nnum_cols\n#&gt;     a     b     c     d     e \n#&gt;  TRUE  TRUE FALSE FALSE  TRUE\n\n# Then transform each column with lapply() then replace the original values\ndf[, num_cols] &lt;- lapply(df[, num_cols, drop = FALSE], \\(x) x * 2)\ndf\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b c     d         e\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     2     4 a     b         8\n\n上面的代码使用了一个新函数sapply()。它 与lapply()类似，但它总是试图简化结果，这就是其名称中s的由来，这里它产生了一个逻辑向量而不是列表。我 们不建议在编程中使用它，因为简化可能会失败并给出意外的类型，但在交互式使用中通常没问题。p urrr包中有一个类似的函数叫做map_vec()，我们在@sec-iteration 中没有提到它。\n基础R提供了一个更严格的sapply()版本，叫做vapply()，即vector apply的缩写。它 接受一个额外的参数来指定预期的类型，确保无论输入如何，简化总是以相同的方式进行。例 如，我们可以将上面的sapply()调用替换为vapply()，其中我们指定我们期望is.numeric()返回一个长度为1的逻辑向量：\n\nvapply(df, is.numeric, logical(1))\n#&gt;     a     b     c     d     e \n#&gt;  TRUE  TRUE FALSE FALSE  TRUE\n\n当sapply()和vapply()在函数内部使用时，它们之间的区别非常重要（因为这对函数对不寻常输入的鲁棒性有很大影响），但在数据分析中通常并不重要。\napply家族中的另一个重要成员是tapply()，它用于计算单个分组汇总：\n\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summarize(price = mean(price))\n#&gt; # A tibble: 5 × 2\n#&gt;   cut       price\n#&gt;   &lt;ord&gt;     &lt;dbl&gt;\n#&gt; 1 Fair      4359.\n#&gt; 2 Good      3929.\n#&gt; 3 Very Good 3982.\n#&gt; 4 Premium   4584.\n#&gt; 5 Ideal     3458.\n\ntapply(diamonds$price, diamonds$cut, mean)\n#&gt;      Fair      Good Very Good   Premium     Ideal \n#&gt;  4358.758  3928.864  3981.760  4584.258  3457.542\n\n不幸的是，tapply()将其结果返回为一个命名向量，如果你想要将多个汇总和分组变量收集到一个数据框中，这需要进行一些处理（当然，不这样做只使用独立的向量进行操作也是可能的，但根据我们的经验，这只会延误工作）。如 果你想知道如何使用tapply()或其他基础技巧来执行其他分组汇总，Hadley 在 in a gist中收集了一些技巧。\n应用家族的最后一个成员是标题中的apply()，它用于矩阵和数组。特 别要注意apply(df, 2, something)，这是使用lapply(df, something)的一种缓慢且可能危险的方式。这 在数据科学中很少出现，因为我们通常使用数据框而不是矩阵。",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>R基础实用指南</span>"
    ]
  },
  {
    "objectID": "base-R.html#for-循环",
    "href": "base-R.html#for-循环",
    "title": "27  R基础实用指南",
    "section": "27.5 for 循环",
    "text": "27.5 for 循环\nfor循环是迭代的基本模块。无 论是apply家族还是map家族，在内部都是基于for循环来实现的。f or循环是强大且通用的工具，对于想要成为更有经验的R程序员来说，学习它们是非常重要的。一 个for循环的基本结构如下所示：\n\nfor (element in vector) {\n  # do something with element\n}\n\nfor循环最直接的用途是实现与walk()相同的效果：对列表中的每个元素调用某个带有副作用的函数。例 如在@sec-save-database 中不使用walk()函数：\n\npaths |&gt; walk(append_file)\n\n我们可以使用 for 循环:\n\nfor (path in paths) {\n  append_file(path)\n}\n\n如果你想保存for循环的输出，事情会变得稍微复杂一些，比如像我们在@sec-iteration 所做的那样，读取一个目录中所有的Excel文件：\n\npaths &lt;- dir(\"data/gapminder\", pattern = \"\\\\.xlsx$\", full.names = TRUE)\nfiles &lt;- map(paths, readxl::read_excel)\n\n你可以使用几种不同的技巧，但我们建议一开始就明确输出将是什么样的。在 这种情况下，我们想要一个与路径列表长度相同的列表，我们可以使用vector()函数来创建它。\n\nfiles &lt;- vector(\"list\", length(paths))\n\n然后，我们将不再直接迭代paths的元素，而是迭代它们的索引，使用seq_along()函数为每个paths的元素生成一个索引：\n\nseq_along(paths)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16\n\n使用索引很重要，因为它允许我们将输入中的每个位置与输出中的相应位置链接起来:\n\nfor (i in seq_along(paths)) {\n  files[[i]] &lt;- readxl::read_excel(paths[[i]])\n}\n\n要将多个tibble列表合并成一个单一的tibble，你可以使用do.call()+rbind()函数：\n\ndo.call(rbind, files)\n#&gt; # A tibble: 2,272 × 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 Albania     Europe       55.2  1282697     1601.\n#&gt; 3 Algeria     Africa       43.1  9279525     2449.\n#&gt; 4 Angola      Africa       30.0  4232095     3521.\n#&gt; 5 Argentina   Americas     62.5 17876956     5911.\n#&gt; 6 Australia   Oceania      69.1  8691212    10040.\n#&gt; # ℹ 2,266 more rows\n\n与其在遍历过程中创建一个列表并保存结果，一个更简单的方法是逐步构建数据框：\n\nout &lt;- NULL\nfor (path in paths) {\n  out &lt;- rbind(out, readxl::read_excel(path))\n}\n\n我们推荐避免这种模式，因为当向量很长时它可能会变得非常慢，这就是for循环很慢这种误解持续存在的来源。实 际上for循环本身并不慢，但迭代地增长向量却很慢。",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>R基础实用指南</span>"
    ]
  },
  {
    "objectID": "base-R.html#绘图",
    "href": "base-R.html#绘图",
    "title": "27  R基础实用指南",
    "section": "27.6 绘图",
    "text": "27.6 绘图\n许多不使用tidyverse的R用户更喜欢使用ggplot2进行绘图，因为它有一些有用的特性，如合理的默认值、自动图例和现代外观。然 而，基础R绘图函数仍然很有用，因为它们非常简洁，只需输入很少的代码就可以进行基本的探索性绘图。\n你在实际使用中会遇到两种主要的基础绘图类型：散点图和直方图，它们分别使用plot()和hist()函数生成。下 面是一个来自diamonds数据集的快速示例：\n# Left\nhist(diamonds$carat)\n\n# Right\nplot(diamonds$carat, diamonds$price)\n\n\n\n\n\n\n\n\n\n\n注意，基本绘图函数与向量一起工作，因此需要使用$或其他技巧将列从数据框架中提取出来。",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>R基础实用指南</span>"
    ]
  },
  {
    "objectID": "base-R.html#小结",
    "href": "base-R.html#小结",
    "title": "27  R基础实用指南",
    "section": "27.7 小结",
    "text": "27.7 小结\n在本章中，我们向你展示了一些用于子集选择和迭代的基础R函数。与 本书中其他地方讨论的方法相比，这些函数往往具有更多的“向量”风味而不是“数据框”风味，因为基础R函数倾向于接受单独的向量，而不是数据框和某些列规范。这 通常使编程变得更容易，因此当你编写更多函数并开始编写自己的包时，它变得更加重要。\n本章标志着本书编程部分的结束。你 在成为不仅是使用R的数据科学家，而且是能够用R编程的数据科学家的道路上迈出了坚实的一步。我 们希望这些章节已经激发了对你编程的兴趣，并期待你在这本书之外学习更多知识。",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>R基础实用指南</span>"
    ]
  },
  {
    "objectID": "base-R.html#footnotes",
    "href": "base-R.html#footnotes",
    "title": "27  R基础实用指南",
    "section": "",
    "text": "阅读https://adv-r.hadley.nz/subsetting.html#subset-multiple来了解如何像对待一维对象那样对数据框进行子集选择，以及如何使用矩阵来对其进行子集选择。↩︎\n但它不会以不同的方式处理分组数据框，并且它不支持如starts_with()这样的选择辅助函数。↩︎\n它只是缺少一些便利的功能，比如进度条，以及在发生错误时报告哪个元素导致了问题。↩︎",
    "crumbs": [
      "编程",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>R基础实用指南</span>"
    ]
  },
  {
    "objectID": "quarto.html",
    "href": "quarto.html",
    "title": "28  Quarto",
    "section": "",
    "text": "28.1 引言\nQuarto 为数据科学提供了一个统一的创作框架，结合了你的代码、结果和文字。Q uarto 文档完全可重现，并支持数十种输出格式，如 PDF、Word 文件和演示文稿等。\nQuarto 文件设计有三种用途：\nQuarto 是一个命令行界面工具，而不是 R 包。这 意味着通常无法通过 ? 来获取帮助。相 反，当你阅读本章内容并在将来使用 Quarto 时，您应该参考Quarto文档。\n如果你是 R Markdown 用户，你可能会觉得Quarto听起来很像 R Markdown。没 错！Q uarto 将 R Markdown 生态系统中许多包（如 rmarkdown、bookdown、distill、xaringan 等）的功能统一到一个一致的系统中，并通过原生支持 Python、Julia 等多种编程语言（包括R）来扩展其功能。在 某种程度上，Quarto 反映了过去十多年来扩展和支持 R Markdown 生态系统的所有经验。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#引言",
    "href": "quarto.html#引言",
    "title": "28  Quarto",
    "section": "",
    "text": "与决策者交流，他们希望关注结论，而不是分析背后的代码；\n与其他数据科学家（包括未来的你！）合作，他们既对你的结论感兴趣，也对你如何得出这些结论（即代码）感兴趣；\n作为开展数据科学的环境，作为现代实验室的笔记本，你不仅可以记录你做了什么，还可以记录你当时的想法。\n\n\n\n\n28.1.1 必要条件\n你需要使用 Quarto 命令行界面（Quarto CLI），但你不需要显式地安装或加载它，因为当需要时RStudio 会自动完成这两项操作。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#quarto-基础",
    "href": "quarto.html#quarto-基础",
    "title": "28  Quarto",
    "section": "28.2 Quarto 基础",
    "text": "28.2 Quarto 基础\n下面是一个Quarto文件，一个扩展名为.qmd的纯文本文件:\n\n---\ntitle: \"Diamond sizes\"\ndate: 2022-09-12\nformat: html\n---\n\n```{r}\n#| label: setup\n#| include: false\n\nlibrary(tidyverse)\n\nsmaller &lt;- diamonds |&gt; \n  filter(carat &lt;= 2.5)\n```\n\nWe have data about `r nrow(diamonds)` diamonds.\nOnly `r nrow(diamonds) - nrow(smaller)` are larger than 2.5 carats.\nThe distribution of the remainder is shown below:\n\n```{r}\n#| label: plot-smaller-diamonds\n#| echo: false\n\nsmaller |&gt; \n  ggplot(aes(x = carat)) + \n  geom_freqpoly(binwidth = 0.01)\n```\n\n它包含三种重要类型的内容:\n\n用---包围的YAML头部信息（可选）；\n用 ```包围的R代码块；\n与简单文本格式（如# heading 和 _italics_）混合的文本。\n\n图 28.1 展示了在 RStudio 笔记本界面中的 .qmd 文档，其中代码和输出交错显示。你 可以通过点击运行图标（它位于代码块顶部的位置，看起来像一个播放按钮）来运行每个代码块，或者通过按下 Cmd/Ctrl + Shift + Enter 来运行。R Studio 执行代码，并将结果显示在代码旁边。\n\n\n\n\n\n\n\n\n图 28.1: A Quarto document in RStudio. Code and output interleaved in the document, with the plot output appearing right underneath the code.\n\n\n\n\n\n如果你不喜欢在文档中看到图表和输出，而是更想使用 RStudio 的“控制台”和“绘图”面板，你可以点击”Render” 旁边的齿轮图标，并切换到”Chunk Output in Console”，如 图 28.2 所示。\n\n\n\n\n\n\n\n\n图 28.2: A Quarto document in RStudio with the plot output in the Plots pane.\n\n\n\n\n\n要生成一个包含所有文本、代码和结果的完整报告，请点击“Render”或按下 Cmd/Ctrl + Shift + K。你 也可以通过编程方式使用quarto::quarto_render(\"diamond-sizes.qmd\")来完成这一操作。这 将在查看器面板中显示报告，如图 图 28.3 所示，并创建一个HTML文件。\n\n\n\n\n\n\n\n\n图 28.3: A Quarto document in RStudio with the rendered document in the Viewer pane.\n\n\n\n\n\n当你渲染（render）文档时，Quarto 将.qmd文件发送给 knitr（https://yihui.org/knitr/），knitr执行所有的代码块并创建一个新的 markdown（.md）文档，这个文档包含了代码及其输出。随 后，由 knitr 生成的 markdown 文件会被 pandoc（https://pandoc.org）处理，pandoc负责创建最终的文件。这 个过程在 图 28.4 中有展示。这 种两步工作流程的优势在于可以创建非常广泛的输出格式，这将在 章节 29 中学习。\n\n\n\n\n\n\n\n\n图 28.4: Diagram of Quarto workflow from qmd, to knitr, to md, to pandoc, to output in PDF, MS Word, or HTML formats.\n\n\n\n\n\n要开始使用你自己的.qmd文件，请在菜单栏中选择File &gt; New File &gt; Quarto Document…。R Studio 将启动一个向导，你可以使用它来预先填充你的文件，其中包含一些有用的内容，以提醒你 Quarto 的关键功能是如何工作的。\n以下部分将更详细地介绍 Quarto 文档的三个组成部分：markdown 文本、代码块和 YAML 头部信息。\n\n28.2.1 练习\n\n使用File &gt; New File &gt; Quarto Document来创建一个新的 Quarto 文档。阅 读说明。练 习单独运行各个代码块。然 后点击适当的按钮或使用相应的键盘快捷键来渲染文档。验 证你是否可以修改代码，重新运行它，并查看修改后的输出；\n为三种内置格式（HTML、PDF 和 Word）中的每一种创建一个新的 Quarto 文档。渲 染这三个文档。输 出的内容有什么不同？输 入的内容有什么不同？（ 如果需要构建 PDF 输出，你可能需要安装 LaTeX — 如果需要，RStudio 会提示你。）",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#可视化编辑器",
    "href": "quarto.html#可视化编辑器",
    "title": "28  Quarto",
    "section": "28.3 可视化编辑器",
    "text": "28.3 可视化编辑器\nRStudio 中的可视化编辑器为 Quarto 文档的编写提供了一个“所见即所得”（WYSIWYM）的界面。实 际上，Quarto 文档（.qmd文件）中的文本部分使用 Markdown 编写，Markdown 是一套轻量级的文本文件格式约定。Q uarto 使用的是 Pandoc markdown（Markdown 的一个稍有扩展的版本，Quarto 能够理解），包括表格、引文、交叉引用、脚注、divs/spans、定义列表、属性、原始 HTML/TeX 等，并支持执行代码单元格和查看它们的内联输出。尽 管 Markdown 的设计初衷是易于读写，如你在@sec-source-editor 中所见，学习新的语法仍然是必要的。因 此，如果你不熟悉像 .qmd 文件这样的计算文档，但有使用 Google Docs 或 MS Word 等工具的经验，那么在 RStudio 中使用 Quarto 的最简单方法就是使用可视化编辑器。\n在可视化编辑器中，你可以使用菜单栏上的按钮来插入图片、表格、交叉引用等，或者使用通用快捷键&lt;kbd&gt;⌘&lt;/kbd&gt;+&lt;kbd&gt;/&lt;/kbd&gt;（Mac）或 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;/&lt;/kbd&gt;（Windows/Linux）来插入几乎任何内容。如 果你在行的开头（如 图 28.5 所示），你也可以只输入&lt;kbd&gt;/&lt;/kbd&gt;来调用这个快捷键。\n\n\n\n\n\n\n\n\n图 28.5: Quarto visual editor.\n\n\n\n\n\n使用可视化编辑器插入图片和自定义图片的显示方式也很方便。你 可以直接从剪贴板中将图片粘贴到可视化编辑器中（RStudio 会在项目目录中放置该图片的一个副本并链接到它），或者你可以使用可视化编辑器的Insert &gt; Figure / Image菜单来浏览你想要插入的图片或粘贴其 URL。此 外，使用相同的菜单，你还可以调整图片的大小、添加标题、替代文本和链接。\n可视化编辑器还有许多其他我们没有在此列举的功能，随着你使用它进行文档编写的经验增加，你可能会发现这些功能很有用。\n最重要的是，虽然可视化编辑器以格式化方式显示你的内容，但实际上，它是以纯 Markdown 格式保存你的内容的，你可以在可视化和源代码编辑器之间来回切换，以使用任一工具查看和编辑你的内容。\n\n28.3.1 练习\n\n使用可视化编辑器重新创建 图 28.5 中的文档。\n使用可视化编辑器，通过Insert菜单然后选择insert anything工具来插入一个代码块。\n使用可视化编辑器，找出如何：\n\n添加脚注。\n添加水平线。\n添加块引用。\n\n在可视化编辑器中，转到Insert &gt; Citation并插入一篇名为“Welcome to the Tidyverse”的论文的引文，使用其 DOI（数字对象标识符），即 10.21105/joss.01686。渲染文档并观察引文在文档中的显示方式。你的文档的 YAML 部分发生了什么变化？",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#sec-source-editor",
    "href": "quarto.html#sec-source-editor",
    "title": "28  Quarto",
    "section": "28.4 源代码编辑器",
    "text": "28.4 源代码编辑器\n你也可以在 RStudio 的源代码编辑器中编辑 Quarto 文档，而无需可视化编辑器的帮助。虽 然可视化编辑器对于习惯使用 Google Docs 等工具编写文档的人来说会感觉很熟悉，但源代码编辑器对于有经验的 R 脚本或 R Markdown 文档编写者来说也会感觉熟悉。源 代码编辑器在调试任何 Quarto 语法错误时也非常有用，因为通常在纯文本中更容易发现这些错误。\n下面的指南展示了如何在源代码编辑器中使用 Pandoc 的 Markdown 来编写 Quarto 文档。\n\n## Text formatting\n\n*italic* **bold** ~~strikeout~~ `code`\n\nsuperscript^2^ subscript~2~\n\n[underline]{.underline} [small caps]{.smallcaps}\n\n## Headings\n\n# 1st Level Header\n\n## 2nd Level Header\n\n### 3rd Level Header\n\n## Lists\n\n-   Bulleted list item 1\n\n-   Item 2\n\n    -   Item 2a\n\n    -   Item 2b\n\n1.  Numbered list item 1\n\n2.  Item 2.\n    The numbers are incremented automatically in the output.\n\n## Links and images\n\n&lt;http://example.com&gt;\n\n[linked phrase](http://example.com)\n\n![optional caption text](quarto.png){fig-alt=\"Quarto logo and the word quarto spelled in small case letters\"}\n\n## Tables\n\n| First Header | Second Header |\n|--------------|---------------|\n| Content Cell | Content Cell  |\n| Content Cell | Content Cell  |\n\n学习这些的最佳方法就是去尝试使用它们。这 可能需要几天的时间，但很快就会变得驾轻就熟，你甚至不需要再去思考它们。如 果你忘记了，可以通过Help &gt; Markdown Quick Reference 来查看方便的参考表。\n\n28.4.1 练习\n\n通过创建一个简短的简历来实践你所学到的内容。简 历的标题应该是你的名字，并且应该包括（至少）教育或工作经历的标题。每 个部分都应该包含一个以项目符号列出的工作或学位列表。用 粗体突出年份。\n使用源编辑器和Markdown快速参考指南，弄清楚如何：\n\n添加脚注。\n添加水平线。\n添加块引用。\n\n将https://github.com/hadley/r4ds/tree/main/quarto中 diamond-sizes.qmd 的内容复制并粘贴到本地的 R Quarto 文档中。检 查是否可以运行它，然后在频率多边形之后添加描述其最显著特征的文本。\n在 Google Docs 或 MS Word 中创建一个文档（或找到你之前创建的文档），其中包含一些内容，如标题、超链接、格式化的文本等。复 制这个文档的内容，并粘贴到 Quarto 文档的可视化编辑器中。然 后，切换到源代码编辑器并检查源代码。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#代码块",
    "href": "quarto.html#代码块",
    "title": "28  Quarto",
    "section": "28.5 代码块",
    "text": "28.5 代码块\n要在Quarto文档中运行代码，需要插入一个块。有 三种方法:\n\n键盘快捷键 Cmd + Option + I / Ctrl + Alt + I。\n编辑器工具栏中的Insert按钮图标。\n通过手动键入代码块分隔符 ```{r} and ```.\n\n我们建议你学习键盘快捷键。从 长远来看，这将节省你很多时间!\n你可以继续使用你已知并喜爱的键盘快捷键来运行代码：Cmd/Ctrl + Enter。然 而，代码块现在有一个新的键盘快捷键：Cmd/Ctrl + Shift + Enter，这个快捷键会运行代码块中的所有代码。你 可以把代码块想象成一个函数。一 个代码块应该是相对独立的，并且专注于一个单一的任务。\n以下部分描述了代码块头部，它由```{r}开始，后面跟着一个可选的代码块标签和各种其他代码块选项，每个选项都在它们自己的行上，并用#|标记。\n\n28.5.1 块标签\n块可以被赋予一个可选的标签，例如:\n\n```{r}\n#| label: simple-addition\n\n1 + 1\n```\n#&gt; [1] 2\n\n这有三个好处：\n\n您可以通过脚本编辑器左下角的下拉代码导航器更轻松地导航到特定的代码块：\n\n\n\n\n\n\n\n\n\n代码块产生的图形将具有有用的名称，使得在其他地方使用它们更加方便。更 多信息请参见 小节 28.6。\n你可以设置缓存代码块的网络，以避免在每次运行时重新执行耗时的计算。更 多信息请参见 小节 28.8。\n\n您的代码块标签应该简短但富有启发性，并且不应该包含空格。我 们建议使用连字符（-）来分隔单词（而不是下划线_），并避免在代码块标签中使用其他特殊字符。\n你通常可以随意标记你的代码块，但有一个代码块名称具有特殊行为：setup。当 你在笔记本模式下时，名为setup的代码块将自动运行一次，并且在运行任何其他代码之前。\n此外，代码块标签不能重复，每个代码块标签都必须是唯一的。\n\n\n28.5.2 块选项\n代码块的输出可以通过提供给代码块头部的字段选项进行自定义。k nitr 提供了近 60 个选项，你可以使用它们来定制你的代码块。这 里我们将介绍经常使用的最重要的代码块选项。你 可以在https://yihui.org/knitr/options查看完整的选项列表。\n最重要的一组选项控制你的代码块是否被执行以及哪些结果被插入到最终的报告中：\neval: false 阻止代码被评估（显然，如果代码没有被运行，就不会生成结果）。这 对于显示示例代码或禁用一大块代码而不必逐行注释很有用。\ninclude: false 会运行代码，但在最终文档中不显示代码或结果。使 用此选项来设置你不想在报告中显示的代码。\necho: false 阻止代码出现在最终文件中，但结果仍然显示。当 编写面向不想看到底层 R 代码的读者的报告时，请使用此选项。\nmessage: false或warning: false 阻止消息或警告出现在最终文件中。\nresults: hide 隐藏打印输出；fig.show: hide 隐藏图形。\nerror: true 即使代码返回错误也继续渲染。这 很少是你希望在报告的最终版本中包括的内容，但如果你需要调试 .qmd 文件内部到底发生了什么，它会非常有用。如 果你正在教授 R 并想故意包含一个错误，它也很有用。默 认情况下，error: false会在文档中出现单个错误时导致渲染失败。\n这些代码块选项中的每一个都添加到代码块的头部，跟在#|后面，例如，在下面的代码块中，由于eval设置为false，结果不会被打印出来。\n\n```{r}\n#| label: simple-multiplication\n#| eval: false\n\n2 * 2\n```\n\n下表总结了每个选项抑制的输出类型:\n\n\n\n\n\n\n\n\n\n\n\n\nOption\nRun code\nShow code\nOutput\nPlots\nMessages\nWarnings\n\n\n\n\neval: false\nX\n\nX\nX\nX\nX\n\n\ninclude: false\n\nX\nX\nX\nX\nX\n\n\necho: false\n\nX\n\n\n\n\n\n\nresults: hide\n\n\nX\n\n\n\n\n\nfig-show: hide\n\n\n\nX\n\n\n\n\nmessage: false\n\n\n\n\nX\n\n\n\nwarning: false\n\n\n\n\n\nX\n\n\n\n\n\n28.5.3 全局选项\n随着你更深入地使用 knitr，你会发现一些默认的代码块选项并不符合你的需求，你想要改变它们。\n你可以通过在文档的 YAML 部分下的execute中添加首选选项来实现这一点。例 如如果你正在为不需要看到你的代码但只需要看到你的结果和叙述的受众准备报告，你可能会在文档级别设置echo: false。这 将默认隐藏代码，因此只显示你故意选择显示的代码块（使用echo: true）。你 可能会考虑设置message: false和warning: false，但这会使得调试问题变得更加困难，因为你在最终文档中看不到任何消息。\ntitle: \"My report\"\nexecute:\n  echo: false\n由于 Quarto 被设计为支持多种语言（适用于 R 、Python以及 Julia 等），因此在文档执行级别并非所有 knitr 选项都可用，因为其中一些选项仅适用于 knitr 而不适用于 Quarto 用于运行其他语言代码的其他引擎（如Jupyter）。然 而你仍然可以在 knitr 字段下的opts_chunk中为你的文档设置这些选项作为全局选项。例 如，在编写书籍和教程时，我们设置：\ntitle: \"Tutorial\"\nknitr:\n  opts_chunk:\n    comment: \"#&gt;\"\n    collapse: true\n这使用了我们首选的注释格式，并确保代码和输出紧密地交织在一起。\n\n\n28.5.4 内联代码\n还有一种将 R 代码嵌入 Quarto 文档的方法：直接在文本中使用`r `。如 果你在文本中提到数据的属性，这会非常有用。例 如，本章开头使用的示例文档中有：\n\n我们有关于`r nrow(diamonds)`颗钻石的数据。只 有`r nrow(diamonds) - nrow(smaller)`颗钻石大于 2.5 克拉。剩 余的分布如下所示：\n\n当报告被渲染时，这些计算的结果会被插入到文本中：\n\n我们有关于 53940 颗钻石的数据。只 有 126 颗钻石大于 2.5 克拉。剩 余的分布如下所示：\n\n在将数字插入文本时，format()是你的好帮手。它 允许你设置数字的位数，以便你不会打印出荒谬的精度，还可以设置千位分隔符（big.mark）以使数字更容易阅读。你 可以将这些功能组合成一个辅助函数：\n\ncomma &lt;- function(x) format(x, digits = 2, big.mark = \",\")\ncomma(3452345)\n#&gt; [1] \"3,452,345\"\ncomma(.12358124331)\n#&gt; [1] \"0.12\"\n\n\n\n28.5.5 练习\n\n添加一节来探讨钻石的尺寸如何随切割、颜色和净度而变化。假 设你正在为不懂R的人编写报告，而不是在每个代码块上设置echo: false，而是设置一个全局选项。\n从 https://github.com/hadley/r4ds/tree/main/quarto下载diamond-sizes.qmd。在 文件中添加一个部分来描述最大的20颗钻石，包括一个显示它们最重要属性的表格。\n修改diamonds-sizes.qmd文件，使用label_comma()函数来生成格式优美的输出。同 时，也要包含大于2.5克拉的钻石的百分比。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#sec-figures",
    "href": "quarto.html#sec-figures",
    "title": "28  Quarto",
    "section": "28.6 图形",
    "text": "28.6 图形\nQuarto 文档中的图形可以嵌入（例如PNG 或 JPEG 文件）或作为代码块的结果生成。\n要从外部文件嵌入图像，你可以在 RStudio 的可视化编辑器中使用Insert 菜单并选择Figure / Image。这 将弹出一个菜单，您可以在其中浏览要插入的图像，并为其添加替代文本或标题，并调整其大小。在 可视化编辑器中，你还可以直接从剪贴板中粘贴图像到文档中，RStudio 将在您的项目文件夹中放置该图像的副本。\n如果你包含一个生成图形的代码块（例如包含 ggplot() 调用），生成的图形将自动包含在您的 Quarto 文档中。\n\n28.6.1 图形大小调整\nQuarto 中制图的最大挑战在于使你的图形具有合适的尺寸和形状。控 制图形大小的选项主要有五个：fig-width、fig-height、fig-asp、out-width 和 out-height。图 像大小调整具有挑战性，因为存在两种尺寸（R 创建的图形大小和它在输出文档中插入的大小），以及多种指定尺寸的方式（即高度、宽度和宽高比：三者选二）。\n我们推荐五个选项中的三个：\n\n如果图形具有一致的宽度，则图形在视觉上会更加赏心悦目。为 此，请在默认设置中设置 fig-width: 6（6 英寸）和 fig-asp: 0.618（黄金比例）。然 后在单独的代码块中仅调整 fig-asp。\n使用 out-width 控制输出大小，并将其设置为输出文档主体宽度的百分比。我 们建议将 out-width 设置为“70%”并将 fig-align 设置为center。\n这样做既给图形提供了足够的空间，又不会占用太多空间。\n要将多个图形放在同一行中，请将 layout-ncol 设置为 2（两个图形）、3（三个图形）等。如 果 layout-ncol 为 2，这将有效地将每个图形的 out-width 设置为“50%”，如果 layout-ncol 为 3，则设置为“33%”，依此类推。根 据你想要说明的内容（例如，显示数据或显示图形变化），可能还需要调整 fig-width，如下所述。\n\n如果您发现需要眯起眼睛才能阅读图形中的文本，则需要调整 fig-width。如 果 fig-width 大于图形在最终文档中呈现的大小，则文本将太小；如果 fig-width 较小，则文本将太大。您 通常需要进行一些尝试，以确定 fig-width 与文档中最终宽度的正确比例。为 了说明这一点，以下三个图形的 fig-width 分别为 4、6 和 8：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n如果你想确保所有图中的字体大小一致，每次设置out-width时，你也需要调整fig-width以保持与默认out-width的相同比例。例 如，如果你的默认fig-width是6，out-width是“70%”，当你将out-width设置为“50%”时，你需要将fig-width 设置为4.3（6 * 0.5 / 0.7）。\n图形大小调整和缩放既是一门艺术也是一门科学，要做到准确无误可能需要反复尝试和修改。你 可以在taking control of plot scaling blog post中了解更多关于图形大小调整的信息。\n\n\n28.6.2 其他重要选项\n在本书中，当将代码和文本混合使用时，你可以设置fig-show: hold以便在代码之后显示图形。这 样做的另一个积极效果是，即迫使你将大块的代码与其注释分开，从而提高代码的可读性。\n要给图表添加标题，请使用fig-cap。在 Quarto 中，这将使图从内联变为“浮动”。\n如果你正在生成 PDF 输出，默认的图形类型是 PDF。这 是一个好的默认设置，因为 PDF 是高质量的矢量图形。但 是，如果你显示数千个点，它们可能会产生非常大且缓慢的图形。在 这种情况下，设置fig-format: \"png\"以强制使用 PNG 格式。虽 然 PNG 的质量稍低，但会更加紧凑。\n给生成图形的代码块命名是个好主意，即使你不经常为其他代码块贴标签。代 码块标签用于在磁盘上生成图形文件的名称，因此命名你的代码块会使在其他情况下选择图形并重复使用变得更加容易（例如，如果你想快速将一个图形放入电子邮件中）。\n\n\n28.6.3 练习\n\n在可视化编辑器中打开 diamond-sizes.qmd 文件，找到一颗钻石的图片，复制并粘贴到文档中。双击图片并添加标题。调整图片大小并渲染你的文档。观察图片是如何保存在你当前的工作目录中的。\n编辑 diamond-sizes.qmd 中生成图形的代码块标签，使其以 fig- 为前缀，并使用 chunk 选项 fig-cap 为图形添加标题。然后，编辑代码块上方的文本，使用Insert &gt; Cross Reference来添加对该图形的交叉引用。\n使用以下 chunk 选项逐一更改图形大小，渲染你的文档并描述图形是如何变化的。\n\nfig-width: 10\nfig-height: 3\nout-width: \"100%\"\nout-width: \"20%\"",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#表",
    "href": "quarto.html#表",
    "title": "28  Quarto",
    "section": "28.7 表",
    "text": "28.7 表\n与图形类似，你可以在 Quarto 文档中包含两种类型的表。它 们可以是你在 Quarto 文档中直接创建的 Markdown 表（使用Insert Table菜单），也可以是代码块执行结果生成的表。在 本节中，我们将重点关注后者，即通过计算生成的表。\n默认情况下，Quarto 会以你在控制台中看到的方式显示数据框和矩阵：\n\nmtcars[1:5, ]\n#&gt;                    mpg cyl disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n\n如果你希望数据以其他的格式显示，你可以使用knitr::kable()函数。下 面的代码生成了 表 28.1。\n\nknitr::kable(mtcars[1:5, ], )\n\n\n\n表 28.1: A knitr kable.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\nMazda RX4\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\nMazda RX4 Wag\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\nDatsun 710\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\nHornet 4 Drive\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\nHornet Sportabout\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\n\n\n\n\n\n\n查阅?knitr::kable的文档以了解你可以自定义表格的其他方式。对 于更深入的自定义，可以考虑使用 gt、huxtable、reactable、kableExtra、xtable、stargazer、pander、tables 和 ascii 这些包。每 个包都提供了一组工具，用于从 R 代码中返回格式化的表格。\n\n28.7.1 练习\n\n在可视化编辑器中打开 diamond-sizes.qmd 文件，插入一个代码块，并使用knitr::kable()添加一个表格，显示 diamonds 数据框的前 5 行。\n使用gt::gt()来显示相同的表格。\n为代码块添加一个以 tbl- 为前缀的标签，并使用 chunk 选项 tbl-cap 为表格添加标题。然后，编辑代码块上方的文本，使用Insert &gt; Cross Reference为表格添加交叉引用。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#sec-caching",
    "href": "quarto.html#sec-caching",
    "title": "28  Quarto",
    "section": "28.8 缓存",
    "text": "28.8 缓存\n通常，每次渲染文档时都会从头开始，完全不依赖之前的任何状态。这 对于可重复性来说很棒，因为它确保你已经将所有重要的计算都记录在代码中。但 是，如果你有一些需要很长时间才能完成的计算，这可能会很令人头疼。解 决方案是设置cache: true。\n你可以使用标准的 YAML 选项在文档级别启用 Knitr 缓存，以缓存文档中所有计算的结果：\n---\ntitle: \"My Document\"\nexecute: \n  cache: true\n---\n你也可以在块级别启用缓存，以便在特定块中缓存计算结果:\n\n```{r}\n#| cache: true\n\n# code for lengthy computation...\n```\n\n设置后，这将把代码块的输出保存到磁盘上一个特别命名的文件中。在 后续的运行中，knitr 会检查代码是否发生了改变，如果没有改变，它将重用缓存的结果。\n使用缓存系统时需要谨慎，因为默认情况下它仅基于代码本身而不是其依赖项。例 如，这里的 processed_data 代码块依赖于 raw-data 代码块：\n ```{r}\n#| label: raw-data\n#| cache: true\n\nrawdata &lt;- readr::read_csv(\"a_very_large_file.csv\")\n```\n```{r}\n#| label: processed_data\n#| cache: true\n\nprocessed_data &lt;- rawdata |&gt; \n  filter(!is.na(import_var)) |&gt; \n  mutate(new_variable = complicated_transformation(x, y, z))\n```\n缓存 processed_data 代码块意味着，如果 dplyr 管道发生了改变，它将会重新运行，但如果 read_csv() 调用发生了改变，它则不会重新运行。你 可以通过 dependson chunk 选项来避免这个问题：\n```{r}\n#| label: processed-data\n#| cache: true\n#| dependson: \"raw-data\"\n\nprocessed_data &lt;- rawdata |&gt; \n  filter(!is.na(import_var)) |&gt; \n  mutate(new_variable = complicated_transformation(x, y, z))\n```\ndependson应该包含一个字符向量，包含缓存代码块所依赖的每个代码块的名称。每 当 knitr 检测到其中一个依赖项发生变化时，它就会更新缓存代码块的结果。\n请注意，如果a_very_large_file.csv文件发生变化，代码块将不会更新，因为 knitr 缓存只跟踪.qmd文件内的变化。如 果你也想跟踪该文件的更改，你可以使用cache.extra选项。这 是一个任意的 R 表达式，当其发生变化时会使缓存失效。一 个很好的函数是file.mtime()：它返回文件最后一次修改的时间。然 后你可以这样写：\n```{r}\n#| label: raw-data\n#| cache: true\n#| cache.extra: !expr file.mtime(\"a_very_large_file.csv\")\n\nrawdata &lt;- readr::read_csv(\"a_very_large_file.csv\")\n```\n我们遵循了 David Robinson 的建议来命名这些代码块：每个代码块都以它所创建的主要对象命名。这 使得理解dependson规范变得更加容易。\n随着你的缓存策略逐渐变得更加复杂，定期使用knitr::clean_cache()清除所有缓存是一个明智的选择。\n\n28.8.1 练习\n\n建立一个代码块的网络，其中 d 依赖于 c 和 b，而 b 和 c 都依赖于 a。让每个代码块都输出lubridate::now()，设置cache: true，然后验证你对缓存的理解。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#故障排除",
    "href": "quarto.html#故障排除",
    "title": "28  Quarto",
    "section": "28.9 故障排除",
    "text": "28.9 故障排除\nQuarto 文档的故障排除可能会很有挑战性，因为你不再处于交互式的 R 环境中，需要学习一些新的技巧。此 外，错误可能是由于 Quarto 文档本身的问题，或者是由于 Quarto 文档中的 R 代码引起的。\n在包含代码块的文档中，一个常见的错误是重复的块标签，这在你的工作流程涉及复制和粘贴代码块时尤其普遍。要 解决这个问题，你只需要更改其中一个重复的标签。\n如果错误是由于文档中的 R 代码引起的，你应该首先尝试在交互式会话中重现问题。重 启 R，然后Run all chunks，可以从Code 菜单下的Run region进行，或者使用快捷键 Ctrl + Alt + R。如 果你幸运的话，这将重现问题，你就可以在交互式环境中弄清楚发生了什么。\n如果这不起作用，你的交互式环境和 Quarto 环境之间一定存在某种差异。你 需要系统地探索这些选项。最 常见的差异是工作目录：Quarto 的工作目录是它所在的目录。通 过在块中包含getwd()来检查工作目录是否符合你的预期。\n接下来，集思广益所有可能导致错误的原因。你 需要系统地检查这些设置在你的 R 会话和 Quarto 会话中是否相同。最 简单的方法是设置出问题的块的error: true，然后使用print()和str()来检查设置是否符合你的预期。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#yaml",
    "href": "quarto.html#yaml",
    "title": "28  Quarto",
    "section": "28.10 YAML",
    "text": "28.10 YAML\n你可以通过调整 YAML 头部的参数来控制许多其他“整个文档”的设置。你 可能会好奇 YAML 代表什么：它是“YAML Ain’t Markup Language”（YAML 不是标记语言）的缩写，旨在以人类易于读写的方式表示层次结构数据。Q uarto 使用 YAML 来控制输出的许多细节。在 这里，我们将讨论其中的三个：自包含文档、文档参数和参考文献。\n\n28.10.1 自包含\nHTML 文档通常有许多外部依赖项（如图像、CSS 样式表和JavaScript 等）。默 认情况下Quarto 会将这些依赖项放置在与你的 .qmd 文件相同目录下的 _files 文件夹中。如 果你在一个托管平台上发布 HTML 文件（例如QuartoPub，https://quartopub.com/），该目录中的依赖项会随你的文档一起发布，因此在发布的报告中是可用的。然 而，如果你想把报告通过电子邮件发送给同事，你可能会更喜欢一个单一的、自包含的HTML 文档，该文档嵌入了其所有依赖项。你 可以通过指定 embed-resources 选项来实现这一点：\nformat:\n  html:\n    embed-resources: true\n生成的文件将是自包含的，因此它不需要任何外部文件，也不需要互联网连接就可以被浏览器正确显示。\n\n\n28.10.2 参数\nQuarto 文档可以包含一个或多个参数，这些参数的值可以在你渲染报告时设置。当 你想要使用不同的关键输入值重新渲染相同的报告时，参数会很有用。例 如，你可能需要为每个分店生成销售报告，按学生生成考试成绩，或按国家生成人口统计汇总。要 声明一个或多个参数，请使用 params 字段。\n这个示例使用了一个名为 my_class 的参数来确定要显示哪种类型的汽车：\n\n---\nformat: html\nparams:\n  my_class: \"suv\"\n---\n\n```{r}\n#| label: setup\n#| include: false\n\nlibrary(tidyverse)\n\nclass &lt;- mpg |&gt; filter(class == params$my_class)\n```\n\n# Fuel economy for `r params$my_class`s\n\n```{r}\n#| message: false\n\nggplot(class, aes(x = displ, y = hwy)) + \n  geom_point() + \n  geom_smooth(se = FALSE)\n```\n\n如你所见，参数在代码块中作为名为params的只读列表可用。\n你可以直接在 YAML 头部写入原子向量。你 也可以通过在参数值前添加!expr来运行任意的 R 表达式。这 是指定日期/时间参数的好方法。\nparams:\n  start: !expr lubridate::ymd(\"2015-01-01\")\n  snapshot: !expr lubridate::ymd_hms(\"2015-01-01 12:30:00\")\n\n\n28.10.3 参考文献和引文\nQuarto 可以自动以多种样式生成引文和参考文献。将 引文和参考文献添加到 Quarto 文档的最直接方法是使用 RStudio 中的可视化编辑器。\n要使用可视化编辑器添加引文，请转到Insert &gt; Citation。引 文可以从多种来源插入：\n\nDOI（文档对象标识符）引用。\nZotero 个人或群组库。\nCrossref, DataCite, 或 PubMed. 的搜索。\n你的文档参考文献（位于文档目录中的 .bib 文件）\n\n在幕后，可视化模式使用 Pandoc 标准的 Markdown 引文表示法（例如，[@citation]）。\n如果你使用前三种方法中的任何一种添加引文，可视化编辑器将自动为你创建一个 bibliography.bib 文件，并将引用添加到其中。它 还会在文档的 YAML 中添加一个 bibliography 字段。随 着你添加更多的引用，这个文件将会填充它们的引文。你 还可以使用许多常见的参考文献格式（包括 BibLaTeX、BibTeX、EndNote、Medline）直接编辑此文件。\n要在源代码编辑器中的 .qmd 文件中创建引文，请使用由 ‘@’ 加上来自参考文献文件的引文标识符组成的键。然 后将引文放在方括号中。以 下是一些示例：\nSeparate multiple citations with a `;`: Blah blah [@smith04; @doe99].\n\nYou can add arbitrary comments inside the square brackets: \nBlah blah [see @doe99, pp. 33-35; also @smith04, ch. 1].\n\nRemove the square brackets to create an in-text citation: @smith04 \nsays blah, or @smith04 [p. 33] says blah.\n\nAdd a `-` before the citation to suppress the author's name: \nSmith says blah [-@smith04].\n当 Quarto 渲染你的文件时，它会在你的文档末尾构建并附加一个参考文献列表。这 个参考文献列表将包含来自你的参考文献文件的每个引用，但它不会包含章节标题。因 此，常见的做法是在文件末尾添加一个参考文献的章节标题，如 # References 或 # Bibliography。\n你可以通过在 csl 字段中引用 CSL（引文样式语言）文件来改变你的引文和参考文献的样式：\nbibliography: rmarkdown.bib\ncsl: apa.csl\n与参考文献字段一样，你的 csl 文件应该包含该文件的路径。在 这里，我们假设 csl 文件与 .qmd 文件位于同一目录下。你 可以在https://github.com/citation-style-language/styles找到常见参考文献样式的 CSL 样式文件。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#工作流程",
    "href": "quarto.html#工作流程",
    "title": "28  Quarto",
    "section": "28.11 工作流程",
    "text": "28.11 工作流程\n之前，我们讨论了在控制台中交互式工作，然后在脚本编辑器中捕获有效代码的基本工作流程。Q uarto 将控制台和脚本编辑器结合在一起，模糊了交互式探索和长期代码捕获之间的界限。你 可以在代码块中快速迭代，使用 Cmd/Ctrl + Shift + Enter 进行编辑和重新执行。当 你满意时，你可以继续并开始一个新的代码块。\nQuarto 也非常重要，因为它将文本和代码紧密地结合在一起。这 使得它成为了一个出色的分析笔记本（analysis notebook），因为它允许你开发代码并记录你的想法。分 析笔记本与物理科学中的经典实验笔记本有许多相同的目标。它 ：\n\n记录了你做了什么以及为什么这么做。无论你的记忆力有多好，如果你不记录你的操作，总有一天你会忘记重要的细节。把它们写下来，这样你就不会忘记了！\n支持严谨的思维。如果你在进行过程中记录你的想法并继续反思它们，你更有可能得出强有力的分析。这也会在你最终撰写分析并与他人分享时节省你的时间。\n帮助他人理解你的工作。很少有人会单独进行数据分析，你通常会作为团队的一部分工作。实验笔记本有助于你与同事或实验室伙伴分享你所做的工作以及为什么这么做。\n\n如何有效使用实验笔记本的大部分好建议也适用于分析笔记本。我 们根据自己的经验和 Colin Purrington 关于实验笔记本的建议（https://colinpurrington.com/tips/lab-notebooks），提出以下建议：\n\n确保每个笔记本都有一个描述性的标题、一个引人注目的文件名以及一个简要描述分析目标的第一段。\n使用 YAML 头部中的日期字段来记录你开始在该笔记本上工作的日期：\ndate: 2016-08-23\n使用 ISO8601 YYYY-MM-DD 格式来确保没有歧义。即 使你通常不这样写日期，也请使用这种格式！\n如果你在一个分析想法上花费了很多时间，但它最终是条死胡同，不要删除它！写 一段简短的说明解释为什么它失败了，并把它留在笔记本里。这 将有助于你在未来再次进行该分析时避免走进相同的死胡同。\n通常，最好在 R 之外进行数据输入。但 如果你确实需要记录一小段数据，请使用tibble::tribble()清晰地布局它。\n如果你发现数据文件中存在错误，永远不要直接修改它，而是编写代码来纠正该值。说 明你为何进行此修复。\n在一天结束前，确保你可以渲染笔记本。如 果你在使用缓存，请确保清除缓存。这 样，当代码仍然在你脑海中时，你就可以修复任何问题。\n如果你想让你的代码在长远来看是可重复的（即你可以在未来几个月或几年内回来运行它），你需要跟踪你的代码所使用的包的版本。一 种严格的方法是使用renv（https://rstudio.github.io/renv/index.html），它将包存储在你的项目目录中。一 个快速而简单的方法是包含一个运行sessionInfo()的代码块——虽然这不会让你轻松地重新创建今天的包，但至少你会知道它们是什么。\n在你的职业生涯中，你将创建很多、很多、很多的分析笔记本。你 将如何组织它们以便将来能够再次找到它们？我 们建议将它们存储在单独的项目中，并想出一个好的命名方案。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#小结",
    "href": "quarto.html#小结",
    "title": "28  Quarto",
    "section": "28.12 小结",
    "text": "28.12 小结\n在这一章中，我们向你介绍了Quarto，用于编写和发布可重复计算的文档，这些文档将你的代码和文本融合在一起。你 学习了如何在RStudio中使用可视化编辑器或源代码编辑器编写Quarto文档，了解了代码块的工作原理以及如何为它们定制选项，如何在Quarto文档中包含图形和表格，以及计算的缓存选项。此 外，你还学习了如何调整YAML头部选项以创建自包含或参数化文档，以及如何包含引文和参考书目。我 们还为您提供了一些故障排除和工作流程提示。\n虽然这个介绍应该足以让您开始使用Quarto，但还有很多需要学习的内容。Q uarto仍然相对年轻，并且仍在快速发展。要 了解最新的创新动态，最好的地方是Quarto的官方网站https://quarto.org 。\n这里有两个我们未涵盖的重要主题：协作以及如何准确地向其他人交流你的想法。协 作是现代数据科学中至关重要的一部分，通过使用像Git和GitHub这样的版本控制工具，您可以使自己的生活更加轻松。我 们推荐《Happy Git with R》，这是一本由R用户Jenny Bryan编写的关于Git和GitHub的友好入门指南。这 本书在线免费提供：https://happygitwithr.com 。\n我们也没有提及为了清晰交流你的分析结果，你应该实际写些什么。为 了改进你的写作，我们强烈推荐您阅读Joseph M. Williams & Joseph Bizup的《Style: Lessons in Clarity and Grace》或George Gopen的《The Sense of Structure: Writing from the Reader’s Perspective》。这 两本书都将帮助你理解句子和段落的结构，并为你提供使你的写作更加清晰的工具。（ 如果购买新书，这些书相当昂贵，但它们被许多英语课程使用，所以有很多便宜的二手书可供选择。）George Gopen还在他的网站https://www.georgegopen.com/litigation-articles.html上发表了一系列关于写作的短文。这 些文章虽然面向律师，但几乎所有内容也适用于数据科学家。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html",
    "href": "quarto-formats.html",
    "title": "29  Quarto 格式",
    "section": "",
    "text": "29.1 引言\n到目前为止，你已经看到Quarto用于生成HTML文档。本 章简要概述了你可以使用Quarto生成其他多种类型的输出。\n设置文档的输出有两种方式：",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto 格式</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#引言",
    "href": "quarto-formats.html#引言",
    "title": "29  Quarto 格式",
    "section": "",
    "text": "永久地，修改YAML头部信息:\ntitle: \"Diamond sizes\"\nformat: html\n暂时地，手动调用 quarto::quarto_render():\n\nquarto::quarto_render(\"diamond-sizes.qmd\", output_format = \"docx\")\n\n如果你希望以编程方式生成多种类型的输出，这是很有用的，因为output_format参数也可以是一个值的列表。\n\nquarto::quarto_render(\"diamond-sizes.qmd\", output_format = c(\"docx\", \"pdf\"))",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto 格式</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#输出选项",
    "href": "quarto-formats.html#输出选项",
    "title": "29  Quarto 格式",
    "section": "29.2 输出选项",
    "text": "29.2 输出选项\nQuarto 提供了广泛的输出格式选择。您 可以在https://quarto.org/docs/output-formats/all-formats.html找到完整的列表。许 多格式共享一些输出选项（例如toc: true 用于包含目录），但其他选项是特定于某种格式的（例如，code-fold: true 将代码块折叠成一个&lt;details&gt;标签用于 HTML 输出，以便用户按需显示，这在 PDF 或 Word 文档中不适用）。\n要覆盖默认选项，你需要使用扩展的format字段。例 如，如果你想呈现一个带有浮动目录的 html，你应该使用：\nformat:\n  html:\n    toc: true\n    toc_float: true\n你甚至可以通过提供一个格式列表来呈现多个输出:\nformat:\n  html:\n    toc: true\n    toc_float: true\n  pdf: default\n  docx: default\n如果不想覆盖任何默认选项，请注意特殊的语法（pdf: default）\n要在一个文档的 YAML 中指定的所有格式上进行渲染，您可以使用output_format = \"all\"。\n\nquarto::quarto_render(\"diamond-sizes.qmd\", output_format = \"all\")",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto 格式</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#文档",
    "href": "quarto-formats.html#文档",
    "title": "29  Quarto 格式",
    "section": "29.3 文档",
    "text": "29.3 文档\n前一章主要介绍了默认的 html 输出。基 于这一主题，有几种基本的变体可以生成不同类型的文档。例 如：\nThe previous chapter focused on the default html output. There are several basic variations on that theme, generating different types of documents. For example:\n\npdf 使用 LaTeX（一个开源的文档排版系统）生成 PDF 文档，你需要先安装它。如果您尚未安装，RStudio 会提示你。\ndocx 用于生成 Microsoft Word (.docx) 文档。\nodt 用于生成 OpenDocument Text (.odt) 文档。\nrtf 用于生成 Rich Text Format (.rtf) 文档。\ngfm 用于生成 GitHub Flavored Markdown (.md) 文档。\nipynb 用于生成 Jupyter Notebooks (.ipynb)。\n\n请记住，当你生成文档以与决策者共享时，您可以通过在文档的 YAML 中设置全局选项来关闭代码的默认显示：\nexecute:\n  echo: false\n对于 html文档，另一个选项是默认隐藏代码块，但可以通过点击来显示它们：\nformat:\n  html:\n    code: true",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto 格式</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#演示文稿",
    "href": "quarto-formats.html#演示文稿",
    "title": "29  Quarto 格式",
    "section": "29.4 演示文稿",
    "text": "29.4 演示文稿\n你还可以使用 Quarto 来制作演示文稿。虽 然与 Keynote 或 PowerPoint 这样的工具相比，你在视觉控制上会受到一些限制，但自动将 R 代码的结果插入到演示文稿中可以节省大量时间。制 作演示文稿的方法是将您的内容划分为幻灯片，每个二级（##）标题都会开始一个新的幻灯片。此 外，一级（#）标题表示带有标题幻灯片的新部分的开始，该标题幻灯片默认居中显示在屏幕中央。\nQuarto支持多种支持多种演示文稿格式，包括:\n\nrevealjs - 使用revealjs的HTML 演示文稿\npptx - PowerPoint演示文稿\nbeamer - 使用 LaTeX Beamer 的 PDF 演示文稿\n\n您可以在https://quarto.org/docs/presentations阅读有关使用Quarto创建演示文稿的更多信息。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto 格式</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#交互性",
    "href": "quarto-formats.html#交互性",
    "title": "29  Quarto 格式",
    "section": "29.5 交互性",
    "text": "29.5 交互性\n与任何 HTML 文档一样，使用 Quarto 创建的 HTML 文档也可以包含交互式组件。在 这里，我们介绍两种在 Quarto 文档中包含交互性的选项：htmlwidgets 和 Shiny。\n\n29.5.1 htmlwidgets\nHTML 是一种交互式格式，你可以利用 htmlwidgets 的交互性，htmlwidgets 是 R 函数，用于生成交互式的 HTML 可视化。例 如，请看下面的 leaflet 地图。如 果在网页上查看此页面，你可以拖动地图、放大缩小等。显 然，你无法在书中这样做，所以 Quarto 会自动为你插入一个静态的屏幕截图。\n\nlibrary(leaflet)\nleaflet() |&gt;\n  setView(174.764, -36.877, zoom = 16) |&gt; \n  addTiles() |&gt;\n  addMarkers(174.764, -36.877, popup = \"Maungawhau\") \n\n\n\n\n\nhtmlwidgets 的好处是，你不需要了解任何关于 HTML 或 JavaScript 的知识就可以使用它们。所 有的细节都被封装在包内部，所以你不需要担心。\n有很多包都提供了htmlwidgets，包括：\n\ndygraphs 用于交互式时间序列可视化。\nDT 用于交互式表格。\nthreejs 用于交互式 3D 绘图。\nthreejs 用于图形（如流程图和简单的节点链接图）。\n\n要了解更多关于 htmlwidgets 的信息，并查看提供它们的包的完整列表，请访问https://www.htmlwidgets.org 。\n\n\n29.5.2 Shiny\nhtmlwidgets 提供客户端交互性，所有的交互都发生在浏览器中，与 R 无关。当 然这很好，因为你可以分发 HTML 文件而无需与 R 建立任何连接。然 而，这从根本上限制了你可以使用 HTML 和 JavaScript 实现的功能。另 一种方法是使用 shiny，这是一个允许你使用 R 代码而不是 JavaScript 创建交互性的包。\ntitle: \"Shiny Web App\"\nformat: html\nserver: shiny\n然后你可以使用”input”函数向文档中添加交互式组件:\n\nlibrary(shiny)\n\ntextInput(\"name\", \"What is your name?\")\nnumericInput(\"age\", \"How old are you?\", NA, min = 0, max = 150)\n\n\n\n\n\n\n\n\n\n\n此外，你还需要一个带有 chunk 选项context: server的代码块，其中包含需要在 Shiny 服务器上运行的代码。\n然后，您可以使用input$name和input$age来引用这些值，并且当这些值发生变化时，使用它们的代码将自动重新运行。\n由于 Shiny 交互是在服务器端发生的，所以我们无法在这里向你展示一个实时的 Shiny 应用。这 意味着你可以在不了解 JavaScript 的情况下编写交互式应用，但是你需要一个服务器来运行它们。这 引入了一个逻辑问题：Shiny 应用需要一个 Shiny 服务器才能在线运行。当 你在自己的计算机上运行 Shiny 应用时，Shiny 会自动为你设置一个 Shiny 服务器，但如果你想在线发布这种交互性，则需要一个面向公众的 Shiny 服务器。这 是 Shiny 的基本权衡：你可以在 Shiny 文档中执行任何可以在 R 中执行的操作，但它需要有人运行 R。\n要深入了解 Shiny，我们建议您阅读 Hadley Wickham 的《精通 Shiny》，网址为：https://mastering-shiny.org。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto 格式</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#网站和书籍",
    "href": "quarto-formats.html#网站和书籍",
    "title": "29  Quarto 格式",
    "section": "29.6 网站和书籍",
    "text": "29.6 网站和书籍\n通过一些额外的基础设施，您可以使用 Quarto 生成完整的网站或书籍：\n\n将您的.qmd文件放在一个单独的目录中。i ndex.qmd将成为主页。\n添加一个名为_quarto.yml的 YAML 文件，该文件为网站提供导航。在 此文件中，将项目类型设置为 book（书籍）或 website（网站），例如：\nproject:\n  type: book\n\n例如，以下_quarto.yml文件从三个源文件创建了一个网站：index.qmd（主页）、viridis-colors.qmd和terrain-colors.qmd。\n\nproject:\n  type: website\n\nwebsite:\n  title: \"A website on color scales\"\n  navbar:\n    left:\n      - href: index.qmd\n        text: Home\n      - href: viridis-colors.qmd\n        text: Viridis colors\n      - href: terrain-colors.qmd\n        text: Terrain colors\n\n对于书籍，您需要的_quarto.yml文件的结构非常相似。以 下示例展示了如何创建一个包含四个章节的书籍，并将其渲染为三种不同的输出格式（html、pdf 和 epub）。同 样地，源文件是.qmd文件。\n\nproject:\n  type: book\n\nbook:\n  title: \"A book on color scales\"\n  author: \"Jane Coloriste\"\n  chapters:\n    - index.qmd\n    - intro.qmd\n    - viridis-colors.qmd\n    - terrain-colors.qmd\n\nformat:\n  html:\n    theme: cosmo\n  pdf: default\n  epub: default\n\n我们建议您为网站和书籍使用 RStudio 项目。基 于_quarto.yml文件，RStudio 将识别您正在处理的项目类型，并在 IDE 中添加一个“Build”选项卡，您可以使用它来渲染和预览您的网站和书籍。同 时，你也可以使用quarto::quarto_render()来渲染网站和书籍。\n有关 Quarto 网站的更多信息，请访问https://quarto.org/docs/websites ；有关书籍的更多信息，请访问 https://quarto.org/docs/books。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto 格式</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#其他格式",
    "href": "quarto-formats.html#其他格式",
    "title": "29  Quarto 格式",
    "section": "29.7 其他格式",
    "text": "29.7 其他格式\nQuarto提供了更多的输出格式:\n\n你可以使用Quarto 期刊模板撰写期刊文章: https://quarto.org/docs/journals/templates.html。\n你可以将 Quarto 文档输出为 Jupyter 笔记本，选项 format: ipynb: https://quarto.org/docs/reference/formats/ipynb.html。\n\n在 https://quarto.org/docs/output-formats/all-formats.html 上你可以查看更多输出格式的列表。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto 格式</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#小结",
    "href": "quarto-formats.html#小结",
    "title": "29  Quarto 格式",
    "section": "29.8 小结",
    "text": "29.8 小结\n在本章中，我们为你展示了如何使用 Quarto 以各种形式展示你的成果，从静态和交互式文档到演示文稿，再到网站和书籍。\n为了更深入地了解如何以这些不同形式有效地交流，我们推荐以下资源：\n\n要提高你的演讲技巧，请尝试阅读《Presentation Patterns》一书，作者是 Neal Ford、Matthew McCollough 和 Nathaniel Schutta。该书提供了一系列有效的模式（低水平和高水平），你可以应用这些模式来改进你的演讲。\n如果您进行学术演讲，您可能会喜欢 Leek group guide to giving talks。\n我们还没有亲自学习过，但我们听说过 Matt McGarrity 的公共演讲在线课程评价很好：https://www.coursera.org/learn/public-speaking。\n如果你正在创建许多仪表板，请务必阅读 Stephen Few 的《Information Dashboard Design: The Effective Visual Communication of Data》一书。它将帮助你创建真正有用的仪表板，而不仅仅是看起来漂亮。\n有效地交流你的想法通常受益于一些图形设计知识。Robin Williams 的《The Non-Designer’s Design Book》是一个很好的起点。",
    "crumbs": [
      "交流",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto 格式</span>"
    ]
  },
  {
    "objectID": "whole-game.html",
    "href": "whole-game.html",
    "title": "全貌概览",
    "section": "",
    "text": "本书这一部分的目的是让你快速浏览数据科学的主要工具：导入、整理、转换和可视化数据，如 图 1 所示。我 们将向你展示数据科学的“全貌”，为你提供各主要部分的足够内容，以便你能够处理真实 (尽管可能简单) 的数据集。本 书后面的部分将深入探讨这些主题，从而增加你解决数据科学挑战的范围。\n\n\n\n\n\n\n\n\n图 1: 在本书的这一节中，你将学习如何导入、整齐、转换和可视化数据；编程贯穿于各个过程。\n\n\n\n\n\n数据科学工具包含四章内容：\n\n可视化是学习R编程非常好的起点，因为它的回报是如此明显：你可以制作优雅且信息丰富的图形，以帮助你理解数据。在 1  数据可视化 中，你将深入了解可视化，学习ggplot2图形的基本结构，以及将数据转换为图形的强大技术。\n仅仅可视化通常是不够的，因此在 3  数据转换 中，你将学习关键函数，这些关键函数允许你选择重要变量、筛选关键观测值、创建新变量和计算汇总统计量。\n在 5  数据整齐 中， 你将学习整理数据，这是一种致的数据存储方式，可以使数据转换、可视化和建模更容易。你 将了解其基本原理，以及如何将数据整理成整齐的形式。\n在转换和可视化数据之前，首先需要将数据导入R。在 7  数据导入 中将学习把.csv 文件导入R的基础知识。\n\n在这些章节中，还有另外四章是关于R工作流程的。 在 2  工作流程：基础，4  工作流程: 代码风格 和 6  工作流程: 脚本和项目 中，你将学习编写和组织R代码的良好工作流程。从 长远来看这会让你更容易取得成功，因为它们将为你提供在处理实际项目时保持条理清晰的工具。最 后，8  工作流程：获取帮助 将教你如何获得帮助并继续学习。",
    "crumbs": [
      "全貌概览"
    ]
  },
  {
    "objectID": "visualize.html",
    "href": "visualize.html",
    "title": "可视化",
    "section": "",
    "text": "在阅读了本书的第一部分之后，你（至少从表面上）理解了做数据科学最重要的工具，现在是时候深入细节了。在 本书这一部分，你将进一步深入学习数据可视化。\n\n\n\n\n\n\n\n\n图 1: Data visualization is often the first step in data exploration.\n\n\n\n\n\n每一章都会介绍创建数据可视化的一个或多个方面。\n\n在 9  图层 部分，学习图形的分层语法；\n在 10  探索性数据分析 部分，把可视化与你的好奇心和怀疑精神结合起来，针对数据提出并回答有趣的问题；\n最后, 在 11  交流 部分，学习如何将探索性图形提升为解释性图形，这些图形有助于新手尽快理解你的分析结果。\n\n这三章带你进入可视化的世界，但还有更多要学习的内容。学 习更多知识的绝佳选择是ggplot2：ggplot2: Elegant graphics for data analysis.。这 本书深入探讨了底层理论，并提供了许多如何将各个部分组合起来解决实际问题的示例。另 一个很好的资源是ggplot2扩展库https://exts.ggplot2.tidyverse.org/gallery/。这 个网站列出了许多用新的geoms和scales扩展ggplot2的包。如 果你试图用ggplot2做一些看似困难的事情，这是一个很好的出发点。",
    "crumbs": [
      "可视化"
    ]
  },
  {
    "objectID": "transform.html",
    "href": "transform.html",
    "title": "转换",
    "section": "",
    "text": "本书的第二部分深入探讨了数据可视化。在 这一部分，你将学习在数据框中最常遇到的变量类型，并学习可用于处理这些变量的工具。\n\n\n\n\n\n\n\n\n图 1: The options for data transformation depends heavily on the type of data involved, the subject of this part of the book.\n\n\n\n\n\n你可以根据需要阅读这些章节。它 们的设计在很大程度上是独立的，因此可以按顺序阅读，也可以不按顺序阅读。\n\n12  逻辑向量 将向你介绍逻辑向量。逻辑向量是最简单的向量类型，但功能非常强大。你将学习如何通过数值比较创建它们，如何使用布尔代数将它们组合在一起，如何在汇总中使用它们，以及如何使用它们进行条件转换；\n13  数值 将深入探讨数字向量的工具，这是数据科学的动力源泉。你将更深入地了解计数和一系列重要的转换和汇总函数；\n14  字符串 将为你提供处理字符串的工具。你可以切割它们，将它们分割成小块，然后再将它们重新组合在一起。这一章主要关注stringr包，但你也将学习一些更多用于从字符串中提取数据的tidyr函数；\n15  正则表达式 将向你介绍正则表达式，这是一种强大的字符串操作工具。本章将带你从想象一只猫走过你的键盘，到阅读和编写复杂的字符串模式；\n16  因子 将介绍因子，一种R用于存储分类数据的数据类型。当变量具有一组固定的可能值时，或者当你想要使用非字母顺序的字符串排序时，你可以使用因子；\n17  日期和时间 将为你提供处理日期和日期时间的关键工具。不幸的是，你越了解日期时间，它们似乎就变得越复杂，但在lubridate包的帮助下，你将学习如何克服最常见的挑战；\n18  缺失值 将深入探讨缺失值。我们之前已经单独讨论过它们几次了，但现在是时候全面讨论它们了，帮助你理解隐式和显式缺失值之间的区别，以及如何和为什么可在它们之间进行转换；\n19  连接 通过为你提供将两个（或多个）数据框合并在一起的工具来结束本书的这一部分。学习合并（join）将迫使你了解键（keys）的概念，并思考如何标识数据集的每一行。",
    "crumbs": [
      "转换"
    ]
  },
  {
    "objectID": "import.html",
    "href": "import.html",
    "title": "导入",
    "section": "",
    "text": "在本书的这一部分，你将学习如何将更广泛的数据导入R，以及如何将其转换为对分析有用的形式。有 时，这只需要调用适当的数据导入包中的函数即可。但 在更复杂的情况下，可能需要同时进行数据整理和转换，以得到你更喜欢使用的整齐矩形数据。\n\n\n\n\n\n\n\n\n图 1: Data import is the beginning of the data science process; without data you can’t do data science!\n\n\n\n\n\n在本书的这一部分，你将学习如何访问以以下方式存储的数据:\n\n在 20  电子表格 学习如何从Excel电子表格和Google表格导入数据。\n在 21  数据库 学习如何从数据库中获取数据并将其导入R（同时将学习一点如何将数据从R导出到数据库）。\n在 22  Arrow 学习Arrow，这是一个用于处理内存外数据的强大工具，特别是当数据以Parquet格式存储时。\n在 23  层次数据 学习如何处理层次化数据，包括由JSON格式存储的数据产生的深度嵌套列表。\n在 24  网页抓取 学习网页“抓取”，即从网页中提取数据的艺术和科学。\n\n这里有两个重要的tidyverse包我们没有讨论：haven和xml2。如 果你正在处理SPSS、Stata和SAS文件中的数据，请查看haven包 (https://haven.tidyverse.org)。如 果你正在处理XML数据，请查看xml2包 (https://haven.tidyverse.org)。不 然，你可能需要进行一些研究来确定需要使用哪个包；此时，谷歌会是你的得力助手😃。",
    "crumbs": [
      "导入"
    ]
  },
  {
    "objectID": "program.html",
    "href": "program.html",
    "title": "编程",
    "section": "",
    "text": "在这本书的这一部分，你将提高你的编程技能。编 程是一项跨领域技能，对于所有数据科学工作都是必需的：你必须使用计算机来进行数据科学工作；你不能仅凭大脑、铅笔和纸来完成它。\n\n\n\n\n\n\n\n\n图 1: Programming is the water in which all the other components swim.\n\n\n\n\n\n编程产生代码，而代码是一种沟通工具。显 然，代码告诉计算机你想要它做什么。但 它也向其他人类传达了意义。将 代码视为沟通的工具很重要，因为你所做的每一个项目本质上都是协作的。即 使你没有和其他人一起工作，你也一定会和未来的自己一起工作！编 写清晰的代码很重要，这样其他人（比如未来的你）就能理解你为什么以这种方式进行分析。这 意味着提高编程技能也涉及到提高沟通技巧。随 着时间的推移，你希望你的代码不仅更容易编写，而且更容易让他人阅读。\n在接下来的三章中，你将学习提高编程技能的方法：\n\n复制粘贴是一个强大的工具，但你应该避免使用超过两次。在 代码中重复自己是很危险的，因为它很容易导致错误和不一致。相 反，在 25  函数 中你将学习如何编写函数，这些函数可以让你提取出重复的tidyverse代码，以便轻松地重复使用。\n函数可以提取出重复的代码，但你经常需要对不同的输入重复相同的操作。你 需要迭代工具来让你一次又一次地做类似的事情。这 些工具包括for循环和函数式编程，你将在@sec-iteration 学习它们。\n当你阅读更多由他人编写的代码时，你会看到更多不使用tidyverse的代码。在 27  R基础实用指南 中你将学习一些在实际情况中你会看到的最重要的基础R函数。\n\n这些章节的目的是教你数据科学所需的最基本的编程知识。一 旦你掌握了这里的内容，我们强烈建议你继续投资于你的编程技能。我 们写了两本书，你可能会觉得很有帮助。G arrett Grolemund的《Hands on Programming with R》是一本介绍R作为编程语言的入门书籍，如果你是第一次学习编程语言，这是一个很好的起点。H adley Wickham的《Advanced R》深入探讨了R编程语言的细节；如果你已经有编程经验，并且已经掌握了这些章节中的思想，那么它是一个很好的起点和进一步提升编程能力的绝佳选择。",
    "crumbs": [
      "编程"
    ]
  },
  {
    "objectID": "communicate.html",
    "href": "communicate.html",
    "title": "交流",
    "section": "",
    "text": "到目前为止你已经学习了将数据导入R的工具，将数据整理成便于分析的形式，然后通过转换和可视化来理解数据。但 是，除非你能够向其他人解释你的分析，否则无论你的分析多么出色都没有意义：你需要交流你的结果。\n\n\n\n\n\n\n\n\n图 1: Communication is the final part of the data science process; if you can’t communicate your results to other humans, it doesn’t matter how great your analysis is.\n\n\n\n\n\n接下来的两章主题是交流：\n\n在@sec-quarto 中，你将了解Quarto，这是一个用于整合文字、代码和结果的工具。你 可以使用Quarto进行分析师之间的交流，以及分析师与决策者之间的交流。得 益于Quarto格式的强大功能，你甚至可以使用同一份文档来完成这两个目的。\n在 29  Quarto 格式 中, 你将了解使用Quarto可以生成的其他许多不同种类的输出，包括仪表板、网站和书籍。\n\n这些章节主要关注交流的技术机制，而不是将你的想法传达给其他人的真正难题。然 而，关于交流的其他很多好书，我们将在每章结尾处向你推荐。",
    "crumbs": [
      "交流"
    ]
  }
]