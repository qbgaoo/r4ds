{
  "hash": "cceae8222ba755344f8ddaae122a868c",
  "result": {
    "engine": "knitr",
    "markdown": "# 字符串 {#sec-strings}\n\n\n::: {.cell}\n\n:::\n\n\n## 引言\n\n到目前为止，你已经使用了一堆字符串，但对它们的细节了解并不多，现在是时候深入了解它们了。学\n习字符串的工作原理，并掌握一些可以使用的字符串操作工具。\n\n我们将从创建字符串和字符向量的细节开始。然\n后，你将深入了解如何从数据中创建字符串，然后是从数据中提取字符串。接\n着，我们将讨论处理单个字母的工具。本\n章最后介绍了一些处理单个字母的函数，并简要讨论了在使用其他语言时，你对英语的预期可能会引导你误入歧途的情况。\n\n在下一章中，我们将继续使用字符串，届时你将深入了解正则表达式的强大功能。\n\n### 必要条件\n\n在本章中，我们将使用`stringr`包中的函数，`stringr`是tidyverse的一部分。我\n们还将使用`babynames`数据，因为它提供了一些有趣的字符串供操作。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(babynames)\n```\n:::\n\n\n当你使用 stringr 函数时，你可以很容易地识别出来，因为所有的 stringr 函数都以`str_`开头。如\n果你使用 RStudio，这尤其有用，因为输入`str_`会触发自动补全功能，帮助你回忆起可用的函数。\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](screenshots/stringr-autocomplete.png){fig-alt='str_c typed into the RStudio console with the autocomplete tooltip shown\non top, which lists functions beginning with str_c. The funtion signature\nand beginning of the man page for the highlighted function from the\nautocomplete list are shown in a panel to its right.' width=678}\n:::\n:::\n\n\n## 生成一个字符串\n\n在本书的前面部分，我们曾经创建过字符串，但没有讨论细节。首\n先，你可以使用单引号（`'`）或双引号（`\"`）来创建字符串。两\n者在行为上没有区别，因此，为了保持一致性，[tidyverse 风格指南](https://style.tidyverse.org/syntax.html#character-vectors) 建议使用双引号（`\"`），除非字符串中包含多个`\"`。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring1 <- \"This is a string\"\nstring2 <- 'If I want to include a \"quote\" inside a string, I use single quotes'\n```\n:::\n\n\n如果你漏写了结束引号，你会看到`+`，这是继续提示符：\n\n```         \n> \"This is a string without a closing quote\n+ \n+ \n+ HELP I'M STUCK IN A STRING\n```\n\n如果碰到了这种情况，而你又不知道漏写了哪个引号，可以按 Esc 键取消并重新尝试。\n\n### 转义符（Escapes）\n\n要在字符串中包含单引号或双引号，您可以使用`\\` 来“转义”它：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble_quote <- \"\\\"\" # or '\"'\nsingle_quote <- '\\'' # or \"'\"\n```\n:::\n\n\n所以如果你想在字符串中包含一个反斜杠，你需要转义它:`\"\\\\\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbackslash <- \"\\\\\"\n```\n:::\n\n\n请注意，字符串的输出形式与字符串本身并不相同，因为输出形式会显示转义符（换句话说，当你输出一个字符串时，你可以复制并粘贴输出来重新创建该字符串）。要\n查看字符串的原始内容，请使用`str_view()`[^strings-1]：\n\n[^strings-1]: 或使用基础R函数 `writeLines()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(single_quote, double_quote, backslash)\nx\n#> [1] \"'\"  \"\\\"\" \"\\\\\"\n\nstr_view(x)\n#> [1] │ '\n#> [2] │ \"\n#> [3] │ \\\n```\n:::\n\n\n### 原始字符串 {#sec-raw-strings}\n\n使用多个引号或反斜杠创建字符串很快就会让人困惑。为\n了说明这个问题，我们创建一个字符串，其中包含定义`double_quote`和`single_quote`变量的代码块的内容：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntricky <- \"double_quote <- \\\"\\\\\\\"\\\" # or '\\\"'\nsingle_quote <- '\\\\'' # or \\\"'\\\"\"\nstr_view(tricky)\n#> [1] │ double_quote <- \"\\\"\" # or '\"'\n#>     │ single_quote <- '\\'' # or \"'\"\n```\n:::\n\n\n这么多反斜杠!(\n这有时被称为[斜杠综合症](https://en.wikipedia.org/wiki/Leaning_toothpick_syndrome))为了消除转义，你可以使用原始字符串[^strings-2]:\n\n[^strings-2]: 在R 4.0.0及更高版本中可用。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntricky <- r\"(double_quote <- \"\\\"\" # or '\"'\nsingle_quote <- '\\'' # or \"'\")\"\nstr_view(tricky)\n#> [1] │ double_quote <- \"\\\"\" # or '\"'\n#>     │ single_quote <- '\\'' # or \"'\"\n```\n:::\n\n\n原始字符串通常以`r\"(`开头并以`)\"`结尾。但\n是，如果你的字符串包含`)\"`，你可以改用`r\"[]\"`或`r\"{}\"`，如果这还不够，你可以插入任意数量的短横线来使开闭对变得唯一，例如`r\"--()--\"`、`r\"---()---\"`等。原始字符串足够灵活，可以处理任何文本。\n\n### 其他特殊字符\n\n除了`\\\"`、`\\'`和`\\\\`之外，还有其他一些可能有用的特殊字符。最常见的是`\\n`（换行）和`\\t`（制表符）。有时你还会看到包含以`\\u`或`\\U` 开头的 Unicode 转义序列的字符串。这是一种在所有系统上都能工作的非英文字符的写法。你可以在`?Quotes`中查看其他特殊字符的完整列表。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"one\\ntwo\", \"one\\ttwo\", \"\\u00b5\", \"\\U0001f604\")\nx\n#> [1] \"one\\ntwo\" \"one\\ttwo\" \"µ\"        \"😄\"\nstr_view(x)\n#> [1] │ one\n#>     │ two\n#> [2] │ one{\\t}two\n#> [3] │ µ\n#> [4] │ 😄\n```\n:::\n\n\n请注意，`str_view()`使用花括号来表示制表符，以便更容易地发现它们[^strings-3]。\n处理文本时的一个挑战是文本中可能存在多种不同形式的空白字符，因此了解这种背景知识有助于你识别是否发生了异常情况。\n\n[^strings-3]: `str_view()` 也使用颜色来引起你对制表符、空格、匹配等的注意。这\n    些颜色目前不会在书中显示，但在交互式运行代码时你会注意到它们。\n\n### 练习\n\n1.  创建包含以下值的字符串:\n\n    1.  `He said \"That's amazing!\"`\n\n    2.  `\\a\\b\\c\\d`\n\n    3.  `\\\\\\\\\\\\`\n\n2.  在R会话中创建字符串并输出它。特\n    殊字符“\\\\u00a0”发生了什么？`s`\n    `tr_view()`是如何显示它的？你\n    能在谷歌上查一下这个特殊字符是什么吗？\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- \"This\\u00a0is\\u00a0tricky\"\n    ```\n    :::\n\n\n## 从数据中创建许多字符串\n\n既然你已经学会了“手动”创建一两个字符串的基础知识，接下来我们将详细讨论如何从其他字符串中创建字符串。这\n将帮助你解决一个常见问题，即当你有一些自己写的文本并希望将其与数据框中的字符串结合时。例\n如，你可能想要将“Hello”与一个名字变量结合起来创建一个问候语。我\n们将向你展示如何使用`str_c()`和`str_glue()`函数来完成这个任务，以及如何在`mutate()`函数中使用它们。这\n自然会引出一个问题，即你可能在`summarize()`函数中使用哪些`stringr`函数，因此我们将以讨论`str_flatten()`函数来结束这一节，它是一个用于字符串的汇总函数。\n\n### `str_c()`\n\n`str_c()` 可以接受任意数量的向量作为参数并返回一个字符向量:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_c(\"x\", \"y\")\n#> [1] \"xy\"\nstr_c(\"x\", \"y\", \"z\")\n#> [1] \"xyz\"\nstr_c(\"Hello \", c(\"John\", \"Susan\"))\n#> [1] \"Hello John\"  \"Hello Susan\"\n```\n:::\n\n\n`str_c()`的功能类似于基础R的`paste0()`，但它是为了与`mutate()`一起使用而设计的，它遵守 tidyverse 中关于循环（recycling）和缺失值传播（propagating missing values）的惯常规则。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(name = c(\"Flora\", \"David\", \"Terra\", NA))\ndf |> mutate(greeting = str_c(\"Hi \", name, \"!\"))\n#> # A tibble: 4 × 2\n#>   name  greeting \n#>   <chr> <chr>    \n#> 1 Flora Hi Flora!\n#> 2 David Hi David!\n#> 3 Terra Hi Terra!\n#> 4 <NA>  <NA>\n```\n:::\n\n\n如果你想以另一种方式显示缺失值，可以使用`coalesce()`函数来替换它们。根\n据你的需求，可以在`str_c()`函数内部或外部使用`coalesce()`。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  mutate(\n    greeting1 = str_c(\"Hi \", coalesce(name, \"you\"), \"!\"),\n    greeting2 = coalesce(str_c(\"Hi \", name, \"!\"), \"Hi!\")\n  )\n#> # A tibble: 4 × 3\n#>   name  greeting1 greeting2\n#>   <chr> <chr>     <chr>    \n#> 1 Flora Hi Flora! Hi Flora!\n#> 2 David Hi David! Hi David!\n#> 3 Terra Hi Terra! Hi Terra!\n#> 4 <NA>  Hi you!   Hi!\n```\n:::\n\n\n### `str_glue()` {#sec-glue}\n\n如果在使用`str_c()`时混合了很多固定的和可变的字符串，你会发现需要输入很多`\"`s，这使得很难看清代码的总体目标。为此，[glue](https://glue.tidyverse.org)包提供了一个替代方法，即`str_glue()`[^strings-4]函数。你只需给它一个具有特殊功能的单一字符串：`{}`内的任何内容都会像在引号外部一样被评估。\n\n[^strings-4]: 如果不使用stringr，你也可以用`glue::glue()`直接访问它。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> mutate(greeting = str_glue(\"Hi {name}!\"))\n#> # A tibble: 4 × 2\n#>   name  greeting \n#>   <chr> <glue>   \n#> 1 Flora Hi Flora!\n#> 2 David Hi David!\n#> 3 Terra Hi Terra!\n#> 4 <NA>  Hi NA!\n```\n:::\n\n\n正如你所看到的，`str_glue()`目前将缺失值转换为字符串 \"`NA`\"，不幸的是这与`str_c()`的处理方式不一致。\n\n你也可能会想，如果需要在字符串中包含常规的`{`或`}`符号时应该怎么办。如\n果你猜测需要以某种方式转义它，那么你的思路是正确的。窍\n门在于`glue`使用了一种略有不同的转义技术：不是使用像`\\`这样的特殊字符作为前缀，而是将特殊字符重复两次：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> mutate(greeting = str_glue(\"{{Hi {name}!}}\"))\n#> # A tibble: 4 × 2\n#>   name  greeting   \n#>   <chr> <glue>     \n#> 1 Flora {Hi Flora!}\n#> 2 David {Hi David!}\n#> 3 Terra {Hi Terra!}\n#> 4 <NA>  {Hi NA!}\n```\n:::\n\n\n### `str_flatten()`\n\n`str_c()`和`str_glue()`在与`mutate()`一起使用时效果很好，因为它们的输出与输入具有相同的长度。但\n是，如果你想要一个与`summarize()`配合良好的函数，即一个总是返回一个单独字符串的函数，那么`str_flatten()`[^strings-5]就是为此而设计的：它接受一个字符向量，并将向量的每个元素组合成一个单独的字符串。\n\n[^strings-5]: The base R equivalent is `paste()` used with the `collapse` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_flatten(c(\"x\", \"y\", \"z\"))\n#> [1] \"xyz\"\nstr_flatten(c(\"x\", \"y\", \"z\"), \", \")\n#> [1] \"x, y, z\"\nstr_flatten(c(\"x\", \"y\", \"z\"), \", \", last = \", and \")\n#> [1] \"x, y, and z\"\n```\n:::\n\n\n这使得它可以很好地与 `summarize()` 一起工作：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tribble(\n  ~ name, ~ fruit,\n  \"Carmen\", \"banana\",\n  \"Carmen\", \"apple\",\n  \"Marvin\", \"nectarine\",\n  \"Terence\", \"cantaloupe\",\n  \"Terence\", \"papaya\",\n  \"Terence\", \"mandarin\"\n)\ndf |>\n  group_by(name) |> \n  summarize(fruits = str_flatten(fruit, \", \"))\n#> # A tibble: 3 × 2\n#>   name    fruits                      \n#>   <chr>   <chr>                       \n#> 1 Carmen  banana, apple               \n#> 2 Marvin  nectarine                   \n#> 3 Terence cantaloupe, papaya, mandarin\n```\n:::\n\n\n### 练习\n\n1.  比较和对比`paste0()`和`str_c()`对于以下输入的结果:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    str_c(\"hi \", NA)\n    str_c(letters[1:2], letters[1:3])\n    ```\n    :::\n\n\n2.  `paste()`和`paste0()`有什么区别？如\n    何用`str_c()`重建与`paste()`等效的功能？\n\n3.  将以下表达式从`str_c()`转换为`str_glue()`，反之亦然:\n\n    a.  `str_c(\"The price of \", food, \" is \", price)`\n    b.  `str_glue(\"I'm {age} years old and live in {country}\")`\n    c.  `str_c(\"\\\\section{\", title, \"}\")`\n\n## 从字符串提取数据\n\n将多个变量压缩到单个字符串中是很常见的。在\n本节中，你将学习如何使用四个`tidyr`函数来提取它们：\n\n-   `df |> separate_longer_delim(col, delim)`\n-   `df |> separate_longer_position(col, width)`\n-   `df |> separate_wider_delim(col, delim, names)`\n-   `df |> separate_wider_position(col, widths)`\n\n如果仔细观察，就会发现这里有一个共同的模式：首先`separate_`，然后`longer` 或 `wider`，接着`_`，最后通过分隔符或位置来进一步处理。这\n是因为这四个函数是由两个更简单的原语组成的：\n\n-   正如`pivot_longer()`和`pivot_wider()`一样，以`_longer`结尾的函数通过创建新的行来使输入的数据框变长，而以`_wider`结尾的函数则通过生成新的列来使输入的数据框变宽。\n-   `delim`使用像`\", \"`”或 `\" \"`这样的分隔符来拆分字符串；而`position`则按照指定的宽度进行拆分，如`c(3, 5, 2)`。\n\n我们将在\\@sec-regular-expressions 中再次回到这个家族中的最后一个成员`separate_wider_regex()`。它\n是这些`wider`函数中最灵活的，但你需要对正则表达式有所了解才能使用它。\n\n接下来的两个部分将向你介绍这些拆分函数背后的基本思想，首先是按行拆分（这稍微简单一些），然后是按列拆分。最\n后，将讨论`wider`函数提供的用于诊断问题的工具。\n\n### 拆分成行\n\n当字符串中组件的数量在每行之间变化时，将字符串拆分成行往往是最有用的。最\n常见的情况是，需要`separate_longer_delim()`基于分隔符进行拆分：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- tibble(x = c(\"a,b,c\", \"d,e\", \"f\"))\ndf1 |> \n  separate_longer_delim(x, delim = \",\")\n#> # A tibble: 6 × 1\n#>   x    \n#>   <chr>\n#> 1 a    \n#> 2 b    \n#> 3 c    \n#> 4 d    \n#> 5 e    \n#> 6 f\n```\n:::\n\n\n在实际情况中，`separate_longer_position()`的使用较少见，但一些较旧的数据集确实使用了非常紧凑的格式，其中每个字符都用于记录一个值：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2 <- tibble(x = c(\"1211\", \"131\", \"21\"))\ndf2 |> \n  separate_longer_position(x, width = 1)\n#> # A tibble: 9 × 1\n#>   x    \n#>   <chr>\n#> 1 1    \n#> 2 2    \n#> 3 1    \n#> 4 1    \n#> 5 1    \n#> 6 3    \n#> # ℹ 3 more rows\n```\n:::\n\n\n### 拆分成列 {#sec-string-columns}\n\n当每个字符串中组件数量固定，并且希望将它们分散到列中时，将字符串拆分成列往往是最有用的。它\n们比其`longer`对等项稍微复杂一些，因为你需要为列命名。例\n如，在以下数据集中，`x`由代码、版号和年份组成，它们之间由`\".\"`分隔。要\n使用`separate_wider_delim()`，我们需要在两个参数中提供分隔符和列名：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3 <- tibble(x = c(\"a10.1.2022\", \"b10.2.2011\", \"e15.1.2015\"))\ndf3 |> \n  separate_wider_delim(\n    x,\n    delim = \".\",\n    names = c(\"code\", \"edition\", \"year\")\n  )\n#> # A tibble: 3 × 3\n#>   code  edition year \n#>   <chr> <chr>   <chr>\n#> 1 a10   1       2022 \n#> 2 b10   2       2011 \n#> 3 e15   1       2015\n```\n:::\n\n\n如果某个特定部分没有用，你可以使用`NA`作为列名来在结果中省略它：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3 |> \n  separate_wider_delim(\n    x,\n    delim = \".\",\n    names = c(\"code\", NA, \"year\")\n  )\n#> # A tibble: 3 × 2\n#>   code  year \n#>   <chr> <chr>\n#> 1 a10   2022 \n#> 2 b10   2011 \n#> 3 e15   2015\n```\n:::\n\n\n`separate_wider_position()`的工作方式略有不同，因为你通常需要指定每个列的宽度。因\n此，你给它一个命名的整数向量，其中名称给出新列的名称，而值是它所占据的字符数。你\n可以通过不命名某些值来从输出中省略它们：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf4 <- tibble(x = c(\"202215TX\", \"202122LA\", \"202325CA\")) \ndf4 |> \n  separate_wider_position(\n    x,\n    widths = c(year = 4, age = 2, state = 2)\n  )\n#> # A tibble: 3 × 3\n#>   year  age   state\n#>   <chr> <chr> <chr>\n#> 1 2022  15    TX   \n#> 2 2021  22    LA   \n#> 3 2023  25    CA\n```\n:::\n\n\n### 诊断扩展问题\n\n`separate_wider_delim()`[^strings-6] 需要一个固定且已知数量的列。\n如果某些行没有预期数量的组件怎么办？\n可能存在两种问题，即组件太少或太多，因此`separate_wider_delim()`提供了`too_few`和`too_many`两个参数来帮助处理这些问题。\n首先，让我们使用以下示例数据集来查看`too_few`的情况：\n\n[^strings-6]: 同样的原则也适用于 `separate_wider_position()` 和 `separate_wider_regex()`。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3\", \"1-3-2\", \"1\"))\n\ndf |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\")\n  )\n#> Error in `separate_wider_delim()`:\n#> ! Expected 3 pieces in each element of `x`.\n#> ! 2 values were too short.\n#> ℹ Use `too_few = \"debug\"` to diagnose the problem.\n#> ℹ Use `too_few = \"align_start\"/\"align_end\"` to silence this message.\n```\n:::\n\n\n你会得到一个错误提示，但错误消息给出了一些关于如何继续进行的建议。让\n我们开始调试这个问题：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndebug <- df |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_few = \"debug\"\n  )\n#> Warning: Debug mode activated: adding variables `x_ok`, `x_pieces`, and\n#> `x_remainder`.\ndebug\n#> # A tibble: 5 × 6\n#>   x     y     z     x_ok  x_pieces x_remainder\n#>   <chr> <chr> <chr> <lgl>    <int> <chr>      \n#> 1 1-1-1 1     1     TRUE         3 \"\"         \n#> 2 1-1-2 1     2     TRUE         3 \"\"         \n#> 3 1-3   3     <NA>  FALSE        2 \"\"         \n#> 4 1-3-2 3     2     TRUE         3 \"\"         \n#> 5 1     <NA>  <NA>  FALSE        1 \"\"\n```\n:::\n\n\n当使用调试模式时，你会在输出中看到添加了三个额外的列：`x_ok`、`x_pieces`和`x_remainder`（如果你使用不同名称的变量进行拆分，你会得到一个不同的前缀）。在\n这里，`x_ok`允许你快速找到那些失败的输入：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndebug |> filter(!x_ok)\n#> # A tibble: 2 × 6\n#>   x     y     z     x_ok  x_pieces x_remainder\n#>   <chr> <chr> <chr> <lgl>    <int> <chr>      \n#> 1 1-3   3     <NA>  FALSE        2 \"\"         \n#> 2 1     <NA>  <NA>  FALSE        1 \"\"\n```\n:::\n\n\n`x_pieces`告诉我们找到了多少组件。与\n预期的 3 个（`names`的长度）相比，当得到的组件数量少于预期时，`x_remainder`并不太有用，但稍后我们会再次看到它。\n\n有时查看这些调试信息会发现你的分隔符策略有问题，或者建议你在拆分之前需要进行更多的预处理。在\n这种情况下，解决上游问题并确保移除`too_few = \"debug\"`以确保新问题变成错误。\n\n在其他情况下，你可能想用 `NA`s填充缺失的组件并继续。这\n就是`too_few = \"align_start\"`和`too_few = \"align_end\"`的作用，它们允许你控制 `NA`s应该放在哪里：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_few = \"align_start\"\n  )\n#> # A tibble: 5 × 3\n#>   x     y     z    \n#>   <chr> <chr> <chr>\n#> 1 1     1     1    \n#> 2 1     1     2    \n#> 3 1     3     <NA> \n#> 4 1     3     2    \n#> 5 1     <NA>  <NA>\n```\n:::\n\n\n如果你有太多的组件，同样的原则也适用:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3-5-6\", \"1-3-2\", \"1-3-5-7-9\"))\n\ndf |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\")\n  )\n#> Error in `separate_wider_delim()`:\n#> ! Expected 3 pieces in each element of `x`.\n#> ! 2 values were too long.\n#> ℹ Use `too_many = \"debug\"` to diagnose the problem.\n#> ℹ Use `too_many = \"drop\"/\"merge\"` to silence this message.\n```\n:::\n\n\n但是现在，当我们调试结果时，你可以看到 `x_remainder` 的目的：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndebug <- df |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"debug\"\n  )\n#> Warning: Debug mode activated: adding variables `x_ok`, `x_pieces`, and\n#> `x_remainder`.\ndebug |> filter(!x_ok)\n#> # A tibble: 2 × 6\n#>   x         y     z     x_ok  x_pieces x_remainder\n#>   <chr>     <chr> <chr> <lgl>    <int> <chr>      \n#> 1 1-3-5-6   3     5     FALSE        4 -6         \n#> 2 1-3-5-7-9 3     5     FALSE        5 -7-9\n```\n:::\n\n\n处理过多组件时，会有一些稍微不同的选项：你可以选择静默地“删除”任何额外的组件，或者将它们全部“合并”到最后一列：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"drop\"\n  )\n#> # A tibble: 5 × 3\n#>   x     y     z    \n#>   <chr> <chr> <chr>\n#> 1 1     1     1    \n#> 2 1     1     2    \n#> 3 1     3     5    \n#> 4 1     3     2    \n#> 5 1     3     5\n\n\ndf |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"merge\"\n  )\n#> # A tibble: 5 × 3\n#>   x     y     z    \n#>   <chr> <chr> <chr>\n#> 1 1     1     1    \n#> 2 1     1     2    \n#> 3 1     3     5-6  \n#> 4 1     3     2    \n#> 5 1     3     5-7-9\n```\n:::\n\n\n## 字母\n\n在本节中，我们将介绍一些函数，这些函数允许你处理字符串中的单个字母。你\n将学习如何查找字符串的长度、提取子字符串以及在图和表中处理长字符串。\n\n### 长度\n\n`str_length()`告诉你字符串中字母的数量:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_length(c(\"a\", \"R for data science\", NA))\n#> [1]  1 18 NA\n```\n:::\n\n\n你可以使用`count()`来查找美国婴儿名字长度的分布情况，然后使用`filter()`来查看最长的名字，这些名字恰好有 15 个字母[^strings-7]。\n\n[^strings-7]: 看看这些条目，我们猜测`babynames`数据会省略空格或连字符，并在15个字母之后截断。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbabynames |>\n  count(length = str_length(name), wt = n)\n#> # A tibble: 14 × 2\n#>   length        n\n#>    <int>    <int>\n#> 1      2   338150\n#> 2      3  8589596\n#> 3      4 48506739\n#> 4      5 87011607\n#> 5      6 90749404\n#> 6      7 72120767\n#> # ℹ 8 more rows\n\nbabynames |> \n  filter(str_length(name) == 15) |> \n  count(name, wt = n, sort = TRUE)\n#> # A tibble: 34 × 2\n#>   name                n\n#>   <chr>           <int>\n#> 1 Franciscojavier   123\n#> 2 Christopherjohn   118\n#> 3 Johnchristopher   118\n#> 4 Christopherjame   108\n#> 5 Christophermich    52\n#> 6 Ryanchristopher    45\n#> # ℹ 28 more rows\n```\n:::\n\n\n### 提取子集\n\n你可以使用`str_sub(string, start, end)`来提取字符串的一部分，其中`start`和`end`是子字符串开始和结束的位置。`s`\n`tart`和`end`参数是包含性的，因此返回的字符串的长度将是`end - start + 1`。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"Apple\", \"Banana\", \"Pear\")\nstr_sub(x, 1, 3)\n#> [1] \"App\" \"Ban\" \"Pea\"\n```\n:::\n\n\n你也可以使用负值来从字符串的末尾开始计数：-1 是最后一个字符，-2 是倒数第二个字符，依此类推。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_sub(x, -3, -1)\n#> [1] \"ple\" \"ana\" \"ear\"\n```\n:::\n\n\n请注意，如果字符串太短，`str_sub()`不会失败，它将返回尽可能多的字符：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_sub(\"a\", 1, 5)\n#> [1] \"a\"\n```\n:::\n\n\n我们可以使用`str_sub()`与`mutate()`来找到每个名字的首字母和末字母：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbabynames |> \n  mutate(\n    first = str_sub(name, 1, 1),\n    last = str_sub(name, -1, -1)\n  )\n#> # A tibble: 1,924,665 × 7\n#>    year sex   name          n   prop first last \n#>   <dbl> <chr> <chr>     <int>  <dbl> <chr> <chr>\n#> 1  1880 F     Mary       7065 0.0724 M     y    \n#> 2  1880 F     Anna       2604 0.0267 A     a    \n#> 3  1880 F     Emma       2003 0.0205 E     a    \n#> 4  1880 F     Elizabeth  1939 0.0199 E     h    \n#> 5  1880 F     Minnie     1746 0.0179 M     e    \n#> 6  1880 F     Margaret   1578 0.0162 M     t    \n#> # ℹ 1,924,659 more rows\n```\n:::\n\n\n### 练习\n\n1.  在计算婴儿名字长度的分布时，为什么我们使用 `wt = n`？\n2.  使用`str_length()`和`str_sub()`从每个婴儿的名字中提取中间的字母。如果字符串有偶数个字符，你会怎么做？\n3.  随着时间的推移，`babynames`的长度有什么主要趋势吗？首字母和尾字母的流行程度如何？\n\n## 非英语文本 {#sec-other-languages}\n\n到目前为止，我们主要关注英文文本，这是因为两个原因使其特别易于处理。首\n先，英文字母表相对简单：只有26个字母。其\n次（也许是更重要的），我们今天使用的计算基础设施主要是由英语使用者设计的。不\n幸的是，我们没有篇幅全面介绍非英语语言。不\n过，我们还是想提醒你们注意可能会遇到的一些最大挑战：编码、字母变化和依赖于地区的函数。\n\n### 编码\n\n在处理非英文文本时，第一个挑战通常是编码。为\n了了解正在发生的事情，我们需要深入了解计算机如何表示字符串。在\nR中，我们可以使用`charToRaw()`来获取字符串的底层表示：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncharToRaw(\"Hadley\")\n#> [1] 48 61 64 6c 65 79\n```\n:::\n\n\n这六个十六进制数字中的每一个都代表一个字母：`48` 是 H，`61` 是 a，以此类推。从\n十六进制数字到字符的映射称为编码，在这种情况下，这种编码称为 ASCII。A\nSCII 在表示英文字符方面做得很好，因为它是美国信息交换标准代码（American Standard Code for Information Interchange）。\n\n对于非英文语言来说，事情就没那么简单了。在\n计算机发展的早期，有许多相互竞争的标准用于编码非英文字符。例\n如，欧洲有两种不同的编码：Latin1（也称为 ISO-8859-1）用于西欧语言，而 Latin2（也称为 ISO-8859-2）用于中欧语言。在\nLatin1 中，字节 b1 是“±”，但在 Latin2 中，它是“ą”！幸\n运的是，今天几乎在所有地方都支持一个标准：UTF-8。U\nTF-8 可以编码今天人类使用的几乎所有字符，以及许多额外的符号，如表情符号。\n\n`readr`在所有地方都使用 UTF-8。这\n是一个很好的默认设置，但对于不使用 UTF-8 的旧系统生成的数据将会失败。如\n果发生这种情况，当你输出字符串时，它们看起来会很奇怪。有\n时只是一个或两个字符可能会出错；在其他时候，你会得到完全乱码。例\n如，以下是两个具有异常编码的内联 CSV[^strings-8]：\n\n[^strings-8]: 这里我使用特殊的`\\x`将二进制数据直接编码为字符串。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- \"text\\nEl Ni\\xf1o was particularly bad this year\"\nread_csv(x1)$text\n#> [1] \"El Ni\\xf1o was particularly bad this year\"\n\nx2 <- \"text\\n\\x82\\xb1\\x82\\xf1\\x82\\xc9\\x82\\xbf\\x82\\xcd\"\nread_csv(x2)$text\n#> [1] \"\\x82\\xb1\\x82\\xf1\\x82ɂ\\xbf\\x82\\xcd\"\n```\n:::\n\n\n要正确读取这些，您可以通过`locale` 参数指定编码:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_csv(x1, locale = locale(encoding = \"Latin1\"))$text\n#> [1] \"El Niño was particularly bad this year\"\n\nread_csv(x2, locale = locale(encoding = \"Shift-JIS\"))$text\n#> [1] \"こんにちは\"\n```\n:::\n\n\n如何找到正确的编码？如\n果你很幸运，它可能会在数据文档中的某个地方被提及。不\n幸的是，这种情况很少见，所以`readr`提供了`guess_encoding()`来帮助你找出它。这\n并不是万无一失的，并且在有大量文本时（与这里不同）效果会更好，但这是一个合理的起点。预\n计在你找到正确的编码之前，需要尝试几种不同的编码。\n\n编码是一个丰富且复杂的话题；我们在这里只是触及了皮毛。如\n果你想了解更多，我们推荐阅读 <http://kunststube.net/encoding/>上的详细解释。\n\n### **字母变体**\n\n在使用带有重音的语言时，确定字母的位置（例如使用`str_length()`和`str_sub()`）会面临重大挑战，因为重音字母可能会被编码为一个单独的字符（例如，ü）或者通过将不带重音的字母（例如，u）与变音符号（例如，¨）组合成两个字符来表示。例\n如，以下代码展示了两种看起来相同的表示 ü 的方式：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu <- c(\"\\u00fc\", \"u\\u0308\")\nstr_view(u)\n#> [1] │ ü\n#> [2] │ ü\n```\n:::\n\n\n但是两个字符串的长度不同，它们的第一个字符也不同:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_length(u)\n#> [1] 1 2\nstr_sub(u, 1, 1)\n#> [1] \"ü\" \"u\"\n```\n:::\n\n\n最后，请注意，使用`==`来比较这些字符串时，它们会被解释为不同的字符串，而`stringr`包中的`str_equal()`函数则会识别出两者具有相同的外观。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu[[1]] == u[[2]]\n#> [1] FALSE\n\nstr_equal(u[[1]], u[[2]])\n#> [1] TRUE\n```\n:::\n\n\n### 区域依赖函数\n\n最后，有一些`stringr`函数的行为取决于你的区域（locale）。区\n域类似于一种语言，但包括一个可选的区域标识符来处理语言内的地区差异。区\n域由小写语言缩写指定，后面可以选择性地跟上一个下划线和一个大写区域标识符。例\n如，“en”代表英语，“en_GB”代表英国英语，而“en_US”代表美国英语。如\n果你还不知道你的语言的代码，[维基百科](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes)有一个很好的列表，你可以通过查看`stringi::stri_locale_list()`来查看`stringr`支持哪些区域。\n\n基础R的字符串函数会自动使用你的操作系统设置的区域。这\n意味着基础R的字符串函数会按照你期望的方式处理你的语言，但如果你与来自不同国家的人分享你的代码，代码的行为可能会有所不同。为\n了避免这个问题，stringr默认使用“en”区域（即英语规则），并要求你指定`locale` 参数来覆盖它。幸\n运的是，只有两组函数在处理时需要考虑区域：改变大小写和排序。\n\n改变大小写的规则在不同语言之间有所不同。例\n如，土耳其语有两种i：带点和不带点。由\n于它们是两个不同的字母，所以它们的大写形式也不同：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_to_upper(c(\"i\", \"ı\"))\n#> [1] \"I\" \"I\"\nstr_to_upper(c(\"i\", \"ı\"), locale = \"tr\")\n#> [1] \"İ\" \"I\"\n```\n:::\n\n\n字符串排序依赖于字母表的顺序，而字母表的顺序并不是每种语言都相同的[^strings-9]！\n举个例子：在捷克语中，“ch”是一个复合字母，它在字母表中出现在字母`h`之后。\n\n[^strings-9]: 在没有字母表的语言中排序，比如中文，就更加复杂了。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_sort(c(\"a\", \"c\", \"ch\", \"h\", \"z\"))\n#> [1] \"a\"  \"c\"  \"ch\" \"h\"  \"z\"\nstr_sort(c(\"a\", \"c\", \"ch\", \"h\", \"z\"), locale = \"cs\")\n#> [1] \"a\"  \"c\"  \"h\"  \"ch\" \"z\"\n```\n:::\n\n\nThis also comes up when sorting strings with `dplyr::arrange()`, which is why it also has a `locale` argument.\n\n## 小结\n\n在本章中，你已经了解了`stringr`包的一些强大功能：如何创建、组合和提取字符串，以及在使用非英文字符串时可能遇到的一些挑战。现\n在是时候学习处理字符串的最重要和强大的工具之一：正则表达式了。正\n则表达式是一种非常简洁但非常富有表现力的语言，用于描述字符串中的模式，其是下一章讨论的主题。\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}