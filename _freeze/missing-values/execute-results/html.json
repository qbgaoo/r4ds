{
  "hash": "bdae9929b33833025dc486db0bd92c3f",
  "result": {
    "engine": "knitr",
    "markdown": "# 缺失值 {#sec-missing-values}\n\n\n::: {.cell}\n\n:::\n\n\n## 引言\n\n在本书的早期部分，你已经学习了缺失值的基础知识。你\n首先在 @sec-data-visualization 遇到了它们，这些缺失值在作图时会导致警告，也在 @sec-summarize 干扰了计算汇总统计量。在\n@sec-na-comparison ，你了解了它们的“传染性”以及如何检查它们的存在。现\n在我们将更深入地讨论它们，以便你可以了解更多细节。\n\n首先，我们将讨论一些用于处理记录为`NA`s的缺失值的通用工具。然\n后，探讨隐式缺失值的概念，即那些在数据中完全缺失的值，并展示一些可以用来使它们变成显式的工具。最\n后，讨论由不在数据中出现的因子水平引起的空组的相关问题。\n\n### 必要条件\n\n处理缺失数据的函数主要来自 `dplyr` 和 `tidyr`，这两个库是 `tidyverse` 的核心成员。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## 显式缺失值\n\n首先，让我们来探索一些用于创建或消除显式缺失值（即你看到 `NA` 的单元格）的实用工具。\n\n### 末次观测值结转（LOCF）\n\n缺失值的一个常见用途是作为一种数据输入的便利方式。当\n数据是手动输入时，缺失值有时表示前一行的值被重复（或结转）：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreatment <- tribble(\n  ~person,           ~treatment, ~response,\n  \"Derrick Whitmore\", 1,         7,\n  NA,                 2,         10,\n  NA,                 3,         NA,\n  \"Katherine Burke\",  1,         4\n)\n```\n:::\n\n\n你可以使用`tidyr::fill()`来填充这些缺失值。它\n的工作方式与`select()`类似，接受一组列作为参数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreatment |>\n  fill(everything())\n#> # A tibble: 4 × 3\n#>   person           treatment response\n#>   <chr>                <dbl>    <dbl>\n#> 1 Derrick Whitmore         1        7\n#> 2 Derrick Whitmore         2       10\n#> 3 Derrick Whitmore         3       10\n#> 4 Katherine Burke          1        4\n```\n:::\n\n\n这种处理方法有时被称为“末次观测值结转 (last observation carried forward) ”，简称 locf。你\n可以使用 `.direction` 参数来填充以更特殊方式生成的缺失值。\n\n### 固定值\n\n有时，缺失值代表某个固定且已知的值，最常见的是0。你\n可以使用`dplyr::coalesce()`函数来替换它们：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 4, 5, 7, NA)\ncoalesce(x, 0)\n#> [1] 1 4 5 7 0\n```\n:::\n\n\n有时你会遇到相反的问题，即某个具体的值实际上代表了一个缺失值。这\n通常出现在由较旧软件生成的数据中，这些软件没有正确表示缺失值的方式，因此它们必须使用一些特殊的值，如99或-999来代替。\n\n如果可能的话，在读取数据时处理这种情况，例如，使用`readr::read_csv()`函数的`na`参数，例如`read_csv(path, na = \"99\")`。如\n果你稍后才发现这个问题，或者你的数据源在读取时没有提供处理它的方式，你可以使用`dplyr::na_if()`函数来处理。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 4, 5, 7, -99)\nna_if(x, -99)\n#> [1]  1  4  5  7 NA\n```\n:::\n\n\n### NaN\n\n在我们继续之前，有一种特殊的缺失值类型是你会不时遇到的：`NaN` (读作“nan”，表示“**n**ot **a** **n**umber”) 。了\n解它并不那么重要，因为它通常的行为与`NA`相同：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(NA, NaN)\nx * 10\n#> [1]  NA NaN\nx == 1\n#> [1] NA NA\nis.na(x)\n#> [1] TRUE TRUE\n```\n:::\n\n\n在极少数情况下，如果你需要区分`NA`和`NaN`，你可以使用`is.nan(x)`函数。\n\n当你执行具有不确定结果的数学运算时，通常会遇到`NaN`：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0 / 0 \n#> [1] NaN\n0 * Inf\n#> [1] NaN\nInf - Inf\n#> [1] NaN\nsqrt(-1)\n#> Warning in sqrt(-1): NaNs produced\n#> [1] NaN\n```\n:::\n\n\n## 隐式缺失值 {#sec-missing-implicit}\n\n到目前为止，我们谈论的缺失值都是显式缺失的，即你可以在数据中看到`NA`。但\n是，如果整行数据完全缺失，那么缺失值也可以是隐式的。让\n我们用一个简单的数据集来说明这种区别，该数据集记录了某些股票每个季度的价格：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstocks <- tibble(\n  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),\n  qtr   = c(   1,    2,    3,    4,    2,    3,    4),\n  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)\n)\n```\n:::\n\n\n这个数据集有两个缺失的观测值：\n\n-   2020年第四季度的`price`是显式缺失的，因为它的值是`NA`；\n\n-   2021年第一季度的`price`是隐式缺失的，因为它在数据集中根本没有出现。\n\n理解这种区别的一种方式是借助这个类似禅宗的公案：\n\n> 显式的缺失值是缺失的存在。\n>\n> 隐式的缺失值是存在的缺失。\n\n有时你想将隐式缺失变为显式缺失，以便有具体的东西可以处理。在\n其他情况下，由于数据的结构，显式缺失是强加于你的，你希望消除它们。以\n下部分将讨论一些在隐式和显式缺失之间转换的工具。\n\n### 重塑 (Pivoting)\n\n你已经见过一个工具可以将隐式缺失变为显式缺失，反之亦然：即重塑。将\n数据变宽可以使隐式缺失值变为显式缺失值，因为行和新列的每个组合都必须具有某个值。例\n如，如果我们透视`stocks`数据，将`quarter`放入列中，那么两个缺失值都会变为显式缺失值：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstocks |>\n  pivot_wider(\n    names_from = qtr, \n    values_from = price\n  )\n#> # A tibble: 2 × 5\n#>    year   `1`   `2`   `3`   `4`\n#>   <dbl> <dbl> <dbl> <dbl> <dbl>\n#> 1  2020  1.88  0.59  0.35 NA   \n#> 2  2021 NA     0.92  0.17  2.66\n```\n:::\n\n\n默认情况下，将数据变长会保留显式缺失值，但是如果它们是由于数据不整齐而存在的结构性缺失值，你可以通过设置`values_drop_na = TRUE`来删除它们（使它们变为隐式）。更\n多细节请参见 @sec-tidy-data 中的示例。\n\n### 完整(Complete)\n\n`tidyr::complete()`允许你通过提供一组变量来生成显式缺失值，这些变量定义了应该存在的行的组合。例\n如，我们知道在`stocks`数据中应该存在`year`和`qtr`的所有组合：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstocks |>\n  complete(year, qtr)\n#> # A tibble: 8 × 3\n#>    year   qtr price\n#>   <dbl> <dbl> <dbl>\n#> 1  2020     1  1.88\n#> 2  2020     2  0.59\n#> 3  2020     3  0.35\n#> 4  2020     4 NA   \n#> 5  2021     1 NA   \n#> 6  2021     2  0.92\n#> # ℹ 2 more rows\n```\n:::\n\n\n通常，你会使用现有变量的名称来调用`complete()`函数，以填充缺失的组合。然\n而，有时单个变量本身也是不完整的，因此你可以提供自己的数据。例\n如，你可能知道`stocks` 数据集应该从2019年到2021年，所以你可以为`year`明确提供这些值：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstocks |>\n  complete(year = 2019:2021, qtr)\n#> # A tibble: 12 × 3\n#>    year   qtr price\n#>   <dbl> <dbl> <dbl>\n#> 1  2019     1 NA   \n#> 2  2019     2 NA   \n#> 3  2019     3 NA   \n#> 4  2019     4 NA   \n#> 5  2020     1  1.88\n#> 6  2020     2  0.59\n#> # ℹ 6 more rows\n```\n:::\n\n\n如果变量的范围是正确的，但不是所有值都存在，你可以使用`full_seq(x, 1)`来生成从`min(x)`到`max(x)`之间间隔为1的所有值。\n\n在某些情况下，完整的观测集不能仅通过变量的简单组合来生成。在\n这种情况下，你可以手动执行`complete()`为你所做的操作：创建一个包含所有应该存在的行的数据框（使用你需要的任何方法组合），然后使用`dplyr::full_join()`将其与你的原始数据集结合起来。\n\n### 连接 (Joins)\n\n这让我们引出了另一种揭示隐式缺失观测值的重要方法：连接。你\n将在 @sec-joins 学习更多关于连接的内容，但我们想在这里快速向你提及它们，因为通常只有当你将一个数据集与另一个数据集进行比较时，你才能知道某个数据集中缺失了哪些值。\n\n`dplyr::anti_join(x, y)`在这里是一个特别有用的工具，因为它只选择那些在`x`中但在`y`中没有匹配的行。例\n如，我们可以使用两次`anti_join()`来揭示`flights`中提到的四个机场和722架飞机的信息缺失了：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nycflights13)\n\nflights |> \n  distinct(faa = dest) |> \n  anti_join(airports)\n#> Joining with `by = join_by(faa)`\n#> # A tibble: 4 × 1\n#>   faa  \n#>   <chr>\n#> 1 BQN  \n#> 2 SJU  \n#> 3 STT  \n#> 4 PSE\n\nflights |> \n  distinct(tailnum) |> \n  anti_join(planes)\n#> Joining with `by = join_by(tailnum)`\n#> # A tibble: 722 × 1\n#>   tailnum\n#>   <chr>  \n#> 1 N3ALAA \n#> 2 N3DUAA \n#> 3 N542MQ \n#> 4 N730MQ \n#> 5 N9EAMQ \n#> 6 N532UA \n#> # ℹ 716 more rows\n```\n:::\n\n\n### 练习\n\n1.  你能找到承运人和`planes`上缺失的行之间的关系吗？\n\n## 因子和空组\n\n缺失数据的最后一种类型是空组 (empty group)，即不包含任何观测值的组，这在处理因子时可能会出现。例\n如，假设我们有一个数据集，其中包含了一些关于人的健康信息：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhealth <- tibble(\n  name   = c(\"Ikaia\", \"Oletta\", \"Leriah\", \"Dashay\", \"Tresaun\"),\n  smoker = factor(c(\"no\", \"no\", \"no\", \"no\", \"no\"), levels = c(\"yes\", \"no\")),\n  age    = c(34, 88, 75, 47, 56),\n)\n```\n:::\n\n\n我们想使用`dplyr::count()`来计算吸烟者的数量：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhealth |> count(smoker)\n#> # A tibble: 1 × 2\n#>   smoker     n\n#>   <fct>  <int>\n#> 1 no         5\n```\n:::\n\n\n这个数据集只包含了非吸烟者，但我们知道吸烟者是存在的，吸烟者这一组是空的。我\n们可以通过设置`.drop = FALSE`来请求`count()`保留所有组，即使这些组在数据中不存在：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhealth |> count(smoker, .drop = FALSE)\n#> # A tibble: 2 × 2\n#>   smoker     n\n#>   <fct>  <int>\n#> 1 yes        0\n#> 2 no         5\n```\n:::\n\n\n同样的原理也适用于`ggplot2`的离散轴，它们也会丢弃没有任何值的水平。你\n可以通过将`drop = FALSE`参数传递给适当的离散轴来强制它们显示：\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nggplot(health, aes(x = smoker)) +\n  geom_bar() +\n  scale_x_discrete()\n\nggplot(health, aes(x = smoker)) +\n  geom_bar() +\n  scale_x_discrete(drop = FALSE)\n```\n\n::: {.cell-output-display}\n![](missing-values_files/figure-html/unnamed-chunk-17-1.png){fig-alt='A bar chart with a single value on the x-axis, \"no\".' width=288}\n:::\n\n::: {.cell-output-display}\n![](missing-values_files/figure-html/unnamed-chunk-17-2.png){fig-alt='The same bar chart as the last plot, but now with two values on the x-axis, \"yes\" and \"no\". There is no bar for the \"yes\" category.' width=288}\n:::\n:::\n\n\n同样的问题也会在使用`dplyr::group_by()`时经常出现。同\n样地，你可以使用`.drop = FALSE`来保留所有的因子水平：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhealth |> \n  group_by(smoker, .drop = FALSE) |> \n  summarize(\n    n = n(),\n    mean_age = mean(age),\n    min_age = min(age),\n    max_age = max(age),\n    sd_age = sd(age)\n  )\n#> # A tibble: 2 × 6\n#>   smoker     n mean_age min_age max_age sd_age\n#>   <fct>  <int>    <dbl>   <dbl>   <dbl>  <dbl>\n#> 1 yes        0      NaN     Inf    -Inf   NA  \n#> 2 no         5       60      34      88   21.6\n```\n:::\n\n\n我们在这里得到了一些有趣的结果，因为当对空组进行汇总时，汇总函数会应用于长度为0的向量。这\n里有一个重要的区别，即长度为0的空向量和每个长度为1的缺失值。\n\nWe get some interesting results here because when summarizing an empty group, the summary functions are applied to zero-length vectors.\nThere's an important distinction between empty vectors, which have length 0, and missing values, each of which has length 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A vector containing two missing values\nx1 <- c(NA, NA)\nlength(x1)\n#> [1] 2\n\n# A vector containing nothing\nx2 <- numeric()\nlength(x2)\n#> [1] 0\n```\n:::\n\n\n所有的汇总函数都可以处理长度为0的向量，但它们可能会返回一些乍看之下令人惊讶的结果。在\n这里，我们看到`mean(age)`返回了`NaN`，因为`mean(age) = sum(age)/length(age)`，在这里就变成了`0/0`。`m`\n`ax()`和`min()`对于空向量返回-Inf和Inf，所以如果你将这些结果与非空的新数据向量结合并重新计算，你会得到新数据的最小值或最大值。\n\n有时，一个更简单的方法是先进行汇总，然后使用`complete()`将隐式缺失显式化。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhealth |> \n  group_by(smoker) |> \n  summarize(\n    n = n(),\n    mean_age = mean(age),\n    min_age = min(age),\n    max_age = max(age),\n    sd_age = sd(age)\n  ) |> \n  complete(smoker)\n#> # A tibble: 2 × 6\n#>   smoker     n mean_age min_age max_age sd_age\n#>   <fct>  <int>    <dbl>   <dbl>   <dbl>  <dbl>\n#> 1 yes       NA       NA      NA      NA   NA  \n#> 2 no         5       60      34      88   21.6\n```\n:::\n\n\n这种方法的主要缺点是，即使你知道计数应该是零，你也会得到一个`NA`作为计数结果。\n\n## 小结\n\n缺失值很奇怪！有\n时它们被记录为明确的`NA`，但其他时候你只能通过它们的缺失来注意到它们。本\n章为你提供了一些处理显式缺失值的工具，以及发现隐式缺失值的工具，并讨论了隐式缺失值如何变为显式缺失值的一些方法，反之亦然。\n\n在下一章中，我们将处理本书这部分的最后一章：连接。这\n与之前的章节有所不同，因为我们将讨论一些对整个数据框进行操作的工具，而不是数据框内部的内容。\n",
    "supporting": [
      "missing-values_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}