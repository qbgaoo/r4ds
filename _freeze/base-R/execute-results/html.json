{
  "hash": "8792b34feef5674890c09fe8fccded12",
  "result": {
    "engine": "knitr",
    "markdown": "# R基础实用指南 {#sec-base-r}\n\n\n::: {.cell}\n\n:::\n\n\n## 引言\n\n在编程部分的结尾，我们将快速介绍一些最重要的基础R函数，这些函数在本书中并没有讨论。这\n些工具在你进行更多编程时会特别有用，并且会帮助你阅读在实际项目中遇到的代码。\n\n这是一个很好的时机来提醒你，tidyverse并不是解决数据科学问题的唯一方法。我\n们在本书中教授tidyverse是因为tidyverse包共享一种共同的设计理念，增加了函数之间的一致性，并使每个新函数或包更容易学习和使用。不\n使用基础R就无法使用tidyverse，因此实际上我们已经向你介绍了许多基础R函数：从`library()`来加载包，到`sum()`和`mean()`用于数值汇总，到factor、date和POSIXct数据类型，当然还有所有基本运算符如`+`、`-`、`/`、`*`、`|`、`&`和`！`。到\n目前为止，我们还没有重点关注基础R工作流程，因此本章我们将重点介绍其中的一些。\n\n读完这本书后，你将学习使用基础R、data.table和其他包来解决相同问题的其他方法。当\n你开始阅读其他人编写的R代码时，特别是如果你在使用StackOverflow时，你无疑会遇到这些其他方法。编\n写使用多种方法的代码是完全可以的，不要让任何人告诉你不是这样！\n\n在本章中，我们将重点关注四个大主题：使用`[`进行子集选择，使用`[[`和`$`进行子集选择，apply函数族和`for`循环。最\n后，我们将简要讨论两个基本的绘图函数。\n\n### 必要条件\n\n这个包专注于R的基础功能，因此没有真正的必要条件，但为了解释一些差异，我们将加载tidyverse包。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## 利用 `[` 选择多个元素 {#sec-subset-many}\n\n`[`用于从向量和数据框中提取子组件，其调用方式如`x[i]`或`x[i, j]`。在\n本节中，我们将向您介绍`[`的强大功能，首先展示如何在向量中使用它，然后展示相同的原理如何直接扩展到二维（2d）结构，如数据框。之\n后，我们将通过展示`dplyr`中的各种函数是如何作为`[`的特殊情况的例子来帮助你巩固这些知识。\n\n### 向量子集选择\n\n有五种主要的方式可以用来对向量进行子集选择，即可以利用作为`x[i]`中的`i`：\n\n1.  **正整数向量**。使\n    用正整数进行子集选择会保留这些位置上的元素：\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(\"one\", \"two\", \"three\", \"four\", \"five\")\n    x[c(3, 2, 5)]\n    #> [1] \"three\" \"two\"   \"five\"\n    ```\n    :::\n\n\n    通过重复某个位置，你实际上可以生成一个比输入更长的输出，这使得“子集选择”这个术语有点名不副实。\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x[c(1, 1, 5, 5, 5, 2)]\n    #> [1] \"one\"  \"one\"  \"five\" \"five\" \"five\" \"two\"\n    ```\n    :::\n\n\n2.  **负整数向量**。\n    负值会删除指定位置的元素：\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x[c(-1, -3, -5)]\n    #> [1] \"two\"  \"four\"\n    ```\n    :::\n\n\n3.  **逻辑向量**。使\n    用逻辑向量进行子集选择会保留所有与`TRUE`值对应的值。这\n    通常与比较函数一起使用时非常有用。\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(10, 3, NA, 5, 8, 1, NA)\n    \n    # All non-missing values of x\n    x[!is.na(x)]\n    #> [1] 10  3  5  8  1\n    \n    # All even (or missing!) values of x\n    x[x %% 2 == 0]\n    #> [1] 10 NA  8 NA\n    ```\n    :::\n\n\n    与`filter()`不同，`NA` 索引会被包含在输出中，并且以 `NAs` 的形式出现。\n\n4.  **字符向量**。如\n    果你有一个命名的向量，你可以使用字符向量来对其进行子集选择：\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(abc = 1, def = 2, xyz = 5)\n    x[c(\"xyz\", \"def\")]\n    #> xyz def \n    #>   5   2\n    ```\n    :::\n\n\n    与使用正整数进行子集选择一样，你可以使用字符向量来重复单个条目。\n\n5.  **不指定任何内容**。最\n    后一种子集选择方式是什么都不指定，即`x[]`，这将返回完整的`x`。这\n    对于向量的子集选择来说并不实用，但正如我们稍后会看到的，当对像 tibble 这样的二维结构进行子集选择时，它是很有用的。\n\n### 数据框子集选择\n\n你可以使用多种不同的方式[^base-r-1] 对数据框使用`[`，但最重要的方式是使用`df[rows, cols]`来独立选择行和列。\n这里的`rows`和`cols`是上面描述的向量。\n例如，`df[rows, ]`和`df[, cols]`分别只选择行或列，通过保留其他维度的空子集来实现。\n\n[^base-r-1]: 阅读<https://adv-r.hadley.nz/subsetting.html#subset-multiple>来了解如何像对待一维对象那样对数据框进行子集选择，以及如何使用矩阵来对其进行子集选择。\n\n以下是一些示例:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  x = 1:3, \n  y = c(\"a\", \"e\", \"f\"), \n  z = runif(3)\n)\n\n# Select first row and second column\ndf[1, 2]\n#> # A tibble: 1 × 1\n#>   y    \n#>   <chr>\n#> 1 a\n\n# Select all rows and columns x and y\ndf[, c(\"x\" , \"y\")]\n#> # A tibble: 3 × 2\n#>       x y    \n#>   <int> <chr>\n#> 1     1 a    \n#> 2     2 e    \n#> 3     3 f\n\n# Select rows where `x` is greater than 1 and all columns\ndf[df$x > 1, ]\n#> # A tibble: 2 × 3\n#>       x y         z\n#>   <int> <chr> <dbl>\n#> 1     2 e     0.834\n#> 2     3 f     0.601\n```\n:::\n\n\n我们稍后会回到`$`，但你应该能够根据上下文猜出`df$x`的作用：它从`df`中提取`x`变量。我\n们在这里需要使用它，因为`[`不使用整齐评估（tidy evaluation），所以需要明确指定`x`变量的来源。\n\n在`[`的使用上，tibble 和数据框之间存在重要的区别。在\n本书中我们主要使用了tibble，它们是数据框，但调整了一些行为以使你的工作更加轻松。在\n大多数情况下，你可以互换使用“tibble”和“数据框”，所以当我们要特别关注 R 的内置数据框时，我们会写`data.frame`。如\n果`df`是一个`data.frame`，那么`df[, cols]`会在`col`选择单个列时返回一个向量，在选择多个列时返回一个数据框。如\n果`df`是一个 tibble，那么`[`总是会返回一个 tibble。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- data.frame(x = 1:3)\ndf1[, \"x\"]\n#> [1] 1 2 3\n\ndf2 <- tibble(x = 1:3)\ndf2[, \"x\"]\n#> # A tibble: 3 × 1\n#>       x\n#>   <int>\n#> 1     1\n#> 2     2\n#> 3     3\n```\n:::\n\n\n避免数据框中这种模糊性的一个方法是明确指定`drop = FALSE`：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1[, \"x\" , drop = FALSE]\n#>   x\n#> 1 1\n#> 2 2\n#> 3 3\n```\n:::\n\n\n### dplyr等效函数\n\n有几个dplyr的函数是 `[` 的特例：\n\n-   `filter()` 相当于使用一个逻辑向量来选择行子集，同时确保排除缺失值：\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df <- tibble(\n      x = c(2, 3, 1, 1, NA), \n      y = letters[1:5], \n      z = runif(5)\n    )\n    df |> filter(x > 1)\n    \n    # same as\n    df[!is.na(df$x) & df$x > 1, ]\n    ```\n    :::\n\n\n    在实际应用中另一种常见的技巧是使用`which()`函数，其有排除缺失值的附带作用：`df[which(df$x > 1), ]`。\n\n-   `arrange()` 相当于使用整数向量来选择子集行，这个整数向量通常是通过`order()`函数创建的：\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df |> arrange(x, y)\n    \n    # same as\n    df[order(df$x, df$y), ]\n    ```\n    :::\n\n\n    你可以使用`order(decreasing = TRUE)`来将所有列按降序排序，或者使用`-rank(col)`来单独按降序排序某一列。\n\n-   `select()`和`relocate()`都类似于使用字符向量来选择或重新排列列\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df |> select(x, z)\n    \n    # same as\n    df[, c(\"x\", \"z\")]\n    ```\n    :::\n\n\n基础R还提供了一个函数`subset()`，该函数结合了`filter()`和`select()`[^base-r-2]的功能，名为。\n\n[^base-r-2]: 但它不会以不同的方式处理分组数据框，并且它不支持如`starts_with()`这样的选择辅助函数。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  filter(x > 1) |> \n  select(y, z)\n#> # A tibble: 2 × 2\n#>   y           z\n#>   <chr>   <dbl>\n#> 1 a     0.157  \n#> 2 b     0.00740\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# same as\ndf |> subset(x > 1, c(y, z))\n```\n:::\n\n\n这个函数是dplyr语法中许多部分的灵感来源。\n\n### 练习\n\n1.  创建函数，这些函数以向量为输入，并返回:\n\n    a.  偶数位置上的元素；\n    b.  除了最后一个值以外的所有元素；\n    c.  只有偶数 (且没有缺失值)。\n\n2.  为什么`x[-which(x > 0)]`不等同于`x[x <= 0]`？阅\n    读`which()`的文档并进行一些实验来找出原因。\n\n## 使用`$`和`[[`选择元素 {#sec-subset-one}\n\n`[`用于选择多个元素，它与`[[`和`$`搭配使用，后两者用于提取单个元素。在\n本节中，我们将向您展示如何使用`[[`和`$`从数据框中提取列，讨论`data.frames`和tibble之间的一些其他差异，并强调当与列表一起使用时，`[`和`[[`之间的一些重要差异。\n\n### 数据框\n\n`[[`和`$`可用于从数据框中提取列。`[`\n`[`可以通过位置或名称进行访问，而`$`专门用于通过名称进行访问：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb <- tibble(\n  x = 1:4,\n  y = c(10, 4, 1, 21)\n)\n\n# by position\ntb[[1]]\n#> [1] 1 2 3 4\n\n# by name\ntb[[\"x\"]]\n#> [1] 1 2 3 4\ntb$x\n#> [1] 1 2 3 4\n```\n:::\n\n\n它们还可以用于创建新列，与R 基础包中`mutate()`函数等价：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb$z <- tb$x + tb$y\ntb\n#> # A tibble: 4 × 3\n#>       x     y     z\n#>   <int> <dbl> <dbl>\n#> 1     1    10    11\n#> 2     2     4     6\n#> 3     3     1     4\n#> 4     4    21    25\n```\n:::\n\n\n除了`transform()`、`with()`和`within()`，还有其他几种 R 基础包中创建新列的方法。H\nadley 在<https://gist.github.com/hadley/1986a273e384fb2d4d752c18ed71bedf>上收集了一些示例。\n\n当进行快速汇总时，直接使用`$`符号是很方便的。例\n如，如果你只想找到最大钻石的尺寸或者`cut`的可能值，那么就没有必要使用`summarize()`函数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax(diamonds$carat)\n#> [1] 5.01\n\nlevels(diamonds$cut)\n#> [1] \"Fair\"      \"Good\"      \"Very Good\" \"Premium\"   \"Ideal\"\n```\n:::\n\n\n`dplyr`也提供了一个与`[[`或`$`类似的等效函数`pull()`，这在\\@sec-data-transform 没有提到。`p`\n`ull()`接收一个变量名或变量位置，并仅返回该列。这\n意味着我们可以使用管道操作符来重写上面的代码。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> pull(carat) |> max()\n#> [1] 5.01\n\ndiamonds |> pull(cut) |> levels()\n#> [1] \"Fair\"      \"Good\"      \"Very Good\" \"Premium\"   \"Ideal\"\n```\n:::\n\n\n### Tibbles\n\n当涉及到`$`时，tibble和`data.frame`之间有几个重要区别。数\n据框会匹配任何变量名的前缀（即所谓的部分匹配），并且如果某列不存在也不会报错：\n\nThere are a couple of important differences between tibbles and base `data.frame`s when it comes to `$`.\nData frames match the prefix of any variable names (so-called **partial matching**) and don't complain if a column doesn't exist:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x1 = 1)\ndf$x\n#> [1] 1\ndf$z\n#> NULL\n```\n:::\n\n\ntibble 更严格：它只精确匹配变量名，如果试图访问的列不存在，它会生成一个警告：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb <- tibble(x1 = 1)\n\ntb$x\n#> Warning: Unknown or uninitialised column: `x`.\n#> NULL\ntb$z\n#> Warning: Unknown or uninitialised column: `z`.\n#> NULL\n```\n:::\n\n\n出于这个原因，我们有时开玩笑说 tibble 很“懒惰”和“易怒”：它们做的少但抱怨的多。\n\n### 列表\n\n`[[`和`$`对于处理列表也非常重要，了解它们与`[`的区别很重要。让\n我们用一个名为`l`的列表举例说明这些区别：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl <- list(\n  a = 1:3, \n  b = \"a string\", \n  c = pi, \n  d = list(-1, -5)\n)\n```\n:::\n\n\n-   `[`用于提取子列表。无\n    论提取多少个元素，结果始终是一个列表。\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    str(l[1:2])\n    #> List of 2\n    #>  $ a: int [1:3] 1 2 3\n    #>  $ b: chr \"a string\"\n    \n    str(l[1])\n    #> List of 1\n    #>  $ a: int [1:3] 1 2 3\n    \n    str(l[4])\n    #> List of 1\n    #>  $ d:List of 2\n    #>   ..$ : num -1\n    #>   ..$ : num -5\n    ```\n    :::\n\n\n    与向量一样，你可以使用逻辑向量、整数向量或字符向量来进行子集选择。\n\n-   `[[`和`$`用于从列表中提取单个组件。它\n    们会从列表中移除一层层次结构。\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    str(l[[1]])\n    #>  int [1:3] 1 2 3\n    \n    str(l[[4]])\n    #> List of 2\n    #>  $ : num -1\n    #>  $ : num -5\n    \n    str(l$a)\n    #>  int [1:3] 1 2 3\n    ```\n    :::\n\n\n`[`和`[[`之间的区别对于列表来说特别重要，因为`[[`会深入到列表中提取单个元素，而`[`则会返回一个新的、更小的列表。为\n了帮助你记住这个区别，让我们看一下\\@fig-pepper 中展示的不寻常的胡椒瓶。如\n果这个胡椒瓶代表你的列表胡椒瓶，那么`pepper[1]`就是一个只包含一包胡椒的胡椒瓶。`p`\n`epper[2]`看起来会一样，但会包含第二包胡椒。`p`\n`epper[1:2]`则是一个包含两包胡椒的胡椒瓶。而\n`pepper[[1]]`则会提取出胡椒包本身。\n\n\n::: {.cell}\n::: {.cell-output-display}\n![(Left) A pepper shaker that Hadley once found in his hotel room.\n(Middle) `pepper[1]`.\n(Right) `pepper[[1]]`\n](diagrams/pepper.png){#fig-pepper fig-alt='Three photos. On the left is a photo of a glass pepper shaker. Instead of\nthe pepper shaker containing pepper, it contains a single packet of pepper.\nIn the middle is a photo of a single packet of pepper. On the right is a\nphoto of the contents of a packet of pepper.' width=100%}\n:::\n:::\n\n\n同样的原则也适用于数据框使用一维运算符`[`时：`df[\"x\"]`返回一个单列的数据框，而`df[[\"x\"]]`返回一个向量。\n\n### 练习\n\n1.  当你使用`[[`运算符和一个大于向量长度的正整数时，会发生什么？当\n    你使用不存在的名称进行子集选择时会发生什么？\n\n2.  `pepper[[1]][1]`会是什么？`p`\n    `epper[[1]][[1]]`又是什么？\n\n## apply家族\n\n在 @sec-iteration, 你学习了如`dplyr::across()`和映射家族（map family）函数这样的tidyverse迭代技术。在\n这一节中，你将学习它们的等效函数，即应用家族（apply family）函数。在\n这个前提下，apply和map是同义词，因为“将函数映射到向量的每个元素”的另一种说法就是“将函数应用到向量的每个元素”。在\n这里，我们将为你快速概述这个家族，以便你在实际使用中识别它们。\n\n这个家族中最重要的成员是`lapply()`，它与`purrr::map()`[^base-r-3]非常相似。\n事实上，因为我们没有使用`map()`的任何高级功能，所以你可以将\\@sec-iteration 中的每个`map()`调用替换为`lapply()`。\n\n[^base-r-3]: 它只是缺少一些便利的功能，比如进度条，以及在发生错误时报告哪个元素导致了问题。\n\n在基础R中没有与`across()`完全等效的函数，但你可以通过使用`lapply()`和`[`来接近这个效果。这\n种操作可行是因为在底层，数据框是列的列表，因此对数据框调用`lapply()`会将函数应用到每一列。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(a = 1, b = 2, c = \"a\", d = \"b\", e = 4)\n\n# First find numeric columns\nnum_cols <- sapply(df, is.numeric)\nnum_cols\n#>     a     b     c     d     e \n#>  TRUE  TRUE FALSE FALSE  TRUE\n\n# Then transform each column with lapply() then replace the original values\ndf[, num_cols] <- lapply(df[, num_cols, drop = FALSE], \\(x) x * 2)\ndf\n#> # A tibble: 1 × 5\n#>       a     b c     d         e\n#>   <dbl> <dbl> <chr> <chr> <dbl>\n#> 1     2     4 a     b         8\n```\n:::\n\n\n上面的代码使用了一个新函数`sapply()`。它\n与`lapply()`类似，但它总是试图简化结果，这就是其名称中`s`的由来，这里它产生了一个逻辑向量而不是列表。我\n们不建议在编程中使用它，因为简化可能会失败并给出意外的类型，但在交互式使用中通常没问题。`p`\n`urrr`包中有一个类似的函数叫做`map_vec()`，我们在\\@sec-iteration 中没有提到它。\n\n基础R提供了一个更严格的`sapply()`版本，叫做`vapply()`，即vector apply的缩写。它\n接受一个额外的参数来指定预期的类型，确保无论输入如何，简化总是以相同的方式进行。例\n如，我们可以将上面的`sapply()`调用替换为`vapply()`，其中我们指定我们期望`is.numeric()`返回一个长度为1的逻辑向量：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(df, is.numeric, logical(1))\n#>     a     b     c     d     e \n#>  TRUE  TRUE FALSE FALSE  TRUE\n```\n:::\n\n\n当`sapply()`和`vapply()`在函数内部使用时，它们之间的区别非常重要（因为这对函数对不寻常输入的鲁棒性有很大影响），但在数据分析中通常并不重要。\n\napply家族中的另一个重要成员是`tapply()`，它用于计算单个分组汇总：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  group_by(cut) |> \n  summarize(price = mean(price))\n#> # A tibble: 5 × 2\n#>   cut       price\n#>   <ord>     <dbl>\n#> 1 Fair      4359.\n#> 2 Good      3929.\n#> 3 Very Good 3982.\n#> 4 Premium   4584.\n#> 5 Ideal     3458.\n\ntapply(diamonds$price, diamonds$cut, mean)\n#>      Fair      Good Very Good   Premium     Ideal \n#>  4358.758  3928.864  3981.760  4584.258  3457.542\n```\n:::\n\n\n不幸的是，`tapply()`将其结果返回为一个命名向量，如果你想要将多个汇总和分组变量收集到一个数据框中，这需要进行一些处理（当然，不这样做只使用独立的向量进行操作也是可能的，但根据我们的经验，这只会延误工作）。如\n果你想知道如何使用`tapply()`或其他基础技巧来执行其他分组汇总，Hadley 在 [in a gist](https://gist.github.com/hadley/c430501804349d382ce90754936ab8ec)中收集了一些技巧。\n\n应用家族的最后一个成员是标题中的`apply()`，它用于矩阵和数组。特\n别要注意`apply(df, 2, something)`，这是使用`lapply(df, something)`的一种缓慢且可能危险的方式。这\n在数据科学中很少出现，因为我们通常使用数据框而不是矩阵。\n\n## `for` 循环\n\n`for`循环是迭代的基本模块。无\n论是`apply`家族还是`map`家族，在内部都是基于`for`循环来实现的。`f`\n`or`循环是强大且通用的工具，对于想要成为更有经验的R程序员来说，学习它们是非常重要的。一\n个`for`循环的基本结构如下所示：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (element in vector) {\n  # do something with element\n}\n```\n:::\n\n\n`for`循环最直接的用途是实现与`walk()`相同的效果：对列表中的每个元素调用某个带有副作用的函数。例\n如在\\@sec-save-database 中不使用`walk()`函数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaths |> walk(append_file)\n```\n:::\n\n\n我们可以使用 `for` 循环:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (path in paths) {\n  append_file(path)\n}\n```\n:::\n\n\n如果你想保存`for`循环的输出，事情会变得稍微复杂一些，比如像我们在\\@sec-iteration 所做的那样，读取一个目录中所有的Excel文件：\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaths <- dir(\"data/gapminder\", pattern = \"\\\\.xlsx$\", full.names = TRUE)\nfiles <- map(paths, readxl::read_excel)\n```\n:::\n\n\n你可以使用几种不同的技巧，但我们建议一开始就明确输出将是什么样的。在\n这种情况下，我们想要一个与路径列表长度相同的列表，我们可以使用`vector()`函数来创建它。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles <- vector(\"list\", length(paths))\n```\n:::\n\n\n然后，我们将不再直接迭代`paths`的元素，而是迭代它们的索引，使用`seq_along()`函数为每个`paths`的元素生成一个索引：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq_along(paths)\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12\n```\n:::\n\n\n使用索引很重要，因为它允许我们将输入中的每个位置与输出中的相应位置链接起来:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in seq_along(paths)) {\n  files[[i]] <- readxl::read_excel(paths[[i]])\n}\n```\n:::\n\n\n要将多个tibble列表合并成一个单一的tibble，你可以使用`do.call()`+`rbind()`函数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndo.call(rbind, files)\n#> # A tibble: 1,704 × 5\n#>   country     continent lifeExp      pop gdpPercap\n#>   <chr>       <chr>       <dbl>    <dbl>     <dbl>\n#> 1 Afghanistan Asia         28.8  8425333      779.\n#> 2 Albania     Europe       55.2  1282697     1601.\n#> 3 Algeria     Africa       43.1  9279525     2449.\n#> 4 Angola      Africa       30.0  4232095     3521.\n#> 5 Argentina   Americas     62.5 17876956     5911.\n#> 6 Australia   Oceania      69.1  8691212    10040.\n#> # ℹ 1,698 more rows\n```\n:::\n\n\n与其在遍历过程中创建一个列表并保存结果，一个更简单的方法是逐步构建数据框：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- NULL\nfor (path in paths) {\n  out <- rbind(out, readxl::read_excel(path))\n}\n```\n:::\n\n\n我们推荐避免这种模式，因为当向量很长时它可能会变得非常慢，这就是for循环很慢这种误解持续存在的来源。实\n际上for循环本身并不慢，但迭代地增长向量却很慢。\n\n## 绘图\n\n许多不使用tidyverse的R用户更喜欢使用ggplot2进行绘图，因为它有一些有用的特性，如合理的默认值、自动图例和现代外观。然\n而，基础R绘图函数仍然很有用，因为它们非常简洁，只需输入很少的代码就可以进行基本的探索性绘图。\n\n你在实际使用中会遇到两种主要的基础绘图类型：散点图和直方图，它们分别使用`plot()`和`hist()`函数生成。下\n面是一个来自`diamonds`数据集的快速示例：\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\n# Left\nhist(diamonds$carat)\n\n# Right\nplot(diamonds$carat, diamonds$price)\n```\n\n::: {.cell-output-display}\n![](base-R_files/figure-html/unnamed-chunk-38-1.png){fig-alt='On the left, histogram of carats of diamonds, ranging from 0 to 5 carats.\nThe distribution is unimodal and right-skewed. On the right, scatter\nplot of price vs. carat of diamonds, showing a positive relationship\nthat fans out as both price and carat increases. The scatter plot\nshows very few diamonds bigger than 3 carats compared to diamonds between\n0 to 3 carats.' width=384}\n:::\n\n::: {.cell-output-display}\n![](base-R_files/figure-html/unnamed-chunk-38-2.png){fig-alt='On the left, histogram of carats of diamonds, ranging from 0 to 5 carats.\nThe distribution is unimodal and right-skewed. On the right, scatter\nplot of price vs. carat of diamonds, showing a positive relationship\nthat fans out as both price and carat increases. The scatter plot\nshows very few diamonds bigger than 3 carats compared to diamonds between\n0 to 3 carats.' width=384}\n:::\n:::\n\n\n注意，基本绘图函数与向量一起工作，因此需要使用`$`或其他技巧将列从数据框架中提取出来。\n\n## 小结\n\n在本章中，我们向你展示了一些用于子集选择和迭代的基础R函数。与\n本书中其他地方讨论的方法相比，这些函数往往具有更多的“向量”风味而不是“数据框”风味，因为基础R函数倾向于接受单独的向量，而不是数据框和某些列规范。这\n通常使编程变得更容易，因此当你编写更多函数并开始编写自己的包时，它变得更加重要。\n\n本章标志着本书编程部分的结束。你\n在成为不仅是使用R的数据科学家，而且是能够用R编程的数据科学家的道路上迈出了坚实的一步。我\n们希望这些章节已经激发了对你编程的兴趣，并期待你在这本书之外学习更多知识。\n",
    "supporting": [
      "base-R_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}