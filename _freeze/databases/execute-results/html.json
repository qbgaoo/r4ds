{
  "hash": "71a28d7d6eb5f9bb32b84e4870d7c806",
  "result": {
    "engine": "knitr",
    "markdown": "# 数据库 {#sec-import-databases}\n\n\n::: {.cell}\n\n:::\n\n\n## 引言\n\n大量的数据存储在数据库中，因此知道如何访问这些数据至关重要。有\n时你可以请求他人为你下载数据库的一个快照到`.csv`文件中，但这样做很快就会变得麻烦：每次你需要做出更改时，你都需要与另一个人沟通。你\n希望能够在你需要时直接访问数据库来获取所需的数据。\n\n在本章中，你将首先学习DBI包的基础知识：如何使用它连接到数据库，然后使用SQL[^databases-1] 查询检索数据。\nSQL，即**s**tructured **q**uery **l**anguage (结构化查询语言) 的缩写，是数据库的通用语言，是所有数据科学家都需要学习的重要语言。\n不过，我们不会从SQL开始，而是教你使用dbplyr，它可以将你的dplyr代码转换为SQL。\n我们将使用这种方法来教你SQL的一些最重要的特性。\n到本章结束时你或许不会成为SQL大师，但你能够识别最重要的组件并理解它们的作用。\n\n[^databases-1]: SQL 读作 \"s\"-\"q\"-\"l\" 或者读作 \"sequel\"。\n\n### 必要条件\n\n在本章中，我们将介绍DBI和dbplyr。D\nBI是一个低级接口，用于连接到数据库并执行SQL语句；而dbplyr是一个高级接口，它将你的dplyr代码转换为SQL查询，然后使用DBI来执行这些查询。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\nlibrary(dbplyr)\nlibrary(tidyverse)\n```\n:::\n\n\n## 数据库基础\n\n在最简单的层面上，你可以将数据库视为数据框的集合，在数据库术语中称为表 (**tables**)。与\n数据框一样，数据库的表是由命名列组成的集合，列中的每个值都是相同的类型。数\n据框和数据库表之间存在三个主要差异：\n\n-   数据库表存储在磁盘上，可以任意大。而数据框存储在内存中，并且本质上存在限制（尽管这个限制对于许多问题来说仍然足够大）。\n-   数据库表几乎总是有索引。就像书的索引一样，数据库索引使得可以快速地找到感兴趣的行，而无需查看每一行。数据框和tibbles没有索引，但data.tables有，这也是它们如此快速的原因之一。\n-   大多数经典数据库都优化为快速收集数据，而不是分析现有数据。这些数据库被称为行式数据库，因为它们按行存储数据，而不是像R那样按列存储。最近，已经开发出了许多列式数据库，这些数据库使分析现有数据变得更快。\n\n数据库由数据库管理系统（DBMS）运行，DBMS有三种基本形式：\n\n-   客户端-服务器：DBMS在功能强大的中央服务器上运行，你可以从你的电脑（客户端）连接到它。它们非常适合在组织内与多人共享数据。流行的客户端-服务器DBMS包括PostgreSQL、MariaDB、SQL Server和Oracle等。\n-   云DBMS：如Snowflake、Amazon的RedShift和Google的BigQuery，类似于客户端-服务器DBMS，但它们在云端运行。这意味着它们可以轻松地处理非常大的数据集，并可以根据需要自动提供更多的计算资源。\n-   进程内DBMS：如SQLite或duckdb，完全在你的电脑上运行。当你是主要用户时，它们非常适合处理大型数据集。\n\n## 连接数据库\n\n要从R连接到数据库，需要使用一对软件包：\n\n-   经常使用的`DBI` (**d**ata**b**ase **i**nterface)包，因为它提供了一组通用函数，用于连接到数据库、上传数据、运行SQL查询等。\n-   一个针对你要连接的DBMS定制的包，这个包将通用的DBI命令转换为DBMS所需的特定命令。通常每个DBMS都有一个这样的包，例如`RPostgres`用于PostgreSQL，`RMariaDB`用于MySQL。\n\n如果找不到针对你的DBMS的特定包，你通常可以使用`odbc`包作为替代。`o`\n`dbc`使用许多DBMS都支持的ODBC协议。但\n是，`odbc`需要更多的设置，因为你还需要安装一个ODBC驱动程序，并告诉`odbc`包在哪里找到它。\n\n具体来说，你使用`DBI::dbConnect()`创建一个数据库连接。第\n一个参数选择DBMS[^databases-2]，然后第二个及后续参数描述如何连接到它 (即它在哪里以及你需要访问它的凭据)。\n以下代码展示了几个典型的例子：\n\n[^databases-2]: 通常，这是你从客户端包中唯一需要使用的函数，因此我们建议使用`::`来提取这个函数，而不是使用`library()`来加载完整的软件包。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon <- DBI::dbConnect(\n  RMariaDB::MariaDB(), \n  username = \"root\",\n  password = \"702177gqb\"\n)\ncon <- DBI::dbConnect(\n  RPostgres::Postgres(), \n  hostname = \"databases.mycompany.com\", \n  port = 1234\n)\n```\n:::\n\n\n连接的具体细节在不同的DBMS之间差异很大，所以我们无法在这里涵盖所有细节。这\n意味着你需要自己进行一些研究。通\n常，你可以询问你团队中的其他数据科学家，或者与你的DBA（数据库管理员）交谈。初\n始设置通常需要一些调试（也许还需要一些网络搜索）才能正确完成，但通常你只需要做一次这样的设置。\n\n### 在这本书中\n\n为了这本书设置客户端-服务器或云DBMS会是一个繁琐的过程，所以我们将使用完全驻留在R包`duckdb`中的进程内DBMS。由\n于`DBI`的魔力，使用`duckdb`与其他DBMS之间的唯一区别在于将如何连接到数据库。这\n使得它非常适合用于教学，因为你可以轻松地运行此代码，并且可以将所学到的知识轻松地应用到其他地方。\n\n连接到`duckdb`特别简单，因为默认设置会创建一个临时数据库，当你退出R时该数据库会被删除。这\n对于学习来说非常棒，因为它保证了你每次重启R时都会从一个干净的状态开始。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon <- DBI::dbConnect(duckdb::duckdb())\n```\n:::\n\n\nduckdb 是一个高性能数据库，专为数据科学家的需求而设计。我\n们在这里使用它是因为它上手非常简单，同时也能够以极高的速度处理数十亿字节的数据。如\n果你想在真实的数据分析项目中使用 duckdb，你还需要提供`dbdir`参数来创建一个持久的数据库，并告诉 duckdb 在哪里保存它。假\n设你正在使用一个项目 (如@sec-workflow-scripts-projects)，将其存储在当前项目的 `duckdb` 目录下是一个合理的选择：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon <- DBI::dbConnect(duckdb::duckdb(), dbdir = \"duckdb\")\n```\n:::\n\n\n### 加载数据 {#sec-load-data}\n\n既然这是一个新的数据库，我们首先需要添加一些数据。在\n这里，我们将使用`DBI::dbWriteTable()`函数从`ggplot2`包中添加`mpg`和`diamonds`数据集。`d`\n`bWriteTable()`函数的最简单用法需要三个参数：一个数据库连接、在数据库中要创建的表的名称以及一个数据框。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbWriteTable(con, \"mpg\", ggplot2::mpg)\ndbWriteTable(con, \"diamonds\", ggplot2::diamonds)\n```\n:::\n\n\n如果你在一个实际项目中使用 duckdb，我们强烈推荐你学习`duckdb_read_csv()`和`duckdb_register_arrow()`。这\n两个函数为你提供了强大且高效的方式，可以直接将数据快速加载到 duckdb中，而无需首先将数据加载到 R 中。在\n@sec-save-database 我们还将展示一种有用的技术，用于将多个文件加载到数据库中。\n\n### DBI基础\n\n你可以通过使用其他一些DBI函数来检查数据是否正确加载：`dbListTables()`函数列出了数据库中的所有表，而`dbReadTable()`函数则检索表的内容。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(con)\n#> [1] \"diamonds\" \"mpg\"\n\ncon |> \n  dbReadTable(\"diamonds\") |> \n  as_tibble()\n#> # A tibble: 53,940 × 10\n#>   carat cut       color clarity depth table price     x     y     z\n#>   <dbl> <fct>     <fct> <fct>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n#> 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#> 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#> 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#> 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#> 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#> 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#> # ℹ 53,934 more rows\n```\n:::\n\n\n`dbReadTable()`函数返回一个`data.frame`，所以我们使用`as_tibble()`函数将其转换为`tibble`，以便输出更美观。\n\n如果你已经熟悉 SQL，你可以使用`dbGetQuery()`函数来执行数据库查询并获取结果：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsql <- \"\n  SELECT carat, cut, clarity, color, price \n  FROM diamonds \n  WHERE price > 15000\n\"\nas_tibble(dbGetQuery(con, sql))\n#> # A tibble: 1,655 × 5\n#>   carat cut       clarity color price\n#>   <dbl> <fct>     <fct>   <fct> <int>\n#> 1  1.54 Premium   VS2     E     15002\n#> 2  1.19 Ideal     VVS1    F     15005\n#> 3  2.1  Premium   SI1     I     15007\n#> 4  1.69 Ideal     SI1     D     15011\n#> 5  1.5  Very Good VVS2    G     15013\n#> 6  1.73 Very Good VS1     G     15014\n#> # ℹ 1,649 more rows\n```\n:::\n\n\n如果你之前从未见过SQL，不用担心！很\n快你就会了解更多关于它的知识。如\n果仔细阅读，你可能会猜出它是从`diamonds`数据集中选择了五列，并且只选择了`price`大于15,000的所有行。\n\n## dbplyr基础\n\n既然我们已经连接到数据库并加载了一些数据，那么就可以开始学习dbplyr了。d\nbplyr是dplyr的一个后端 (**backend**)，这意味着你仍然编写dplyr代码，但后端会以不同的方式执行它。在\n这里，dbplyr将dplyr代码转换为SQL；其他后端包括[dtplyr](https://dtplyr.tidyverse.org)，它将代码转换为[data.table](https://r-datatable.com)，以及[multidplyr](https://multidplyr.tidyverse.org)，它会在多个核心上执行你的代码。\n\n要使用dbplyr，你首先必须使用`tbl()`函数来创建一个代表数据库表的对象：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds_db <- tbl(con, \"diamonds\")\ndiamonds_db\n#> # Source:   table<diamonds> [?? x 10]\n#> # Database: DuckDB v0.10.1 [root@Darwin 23.5.0:R 4.3.3/:memory:]\n#>   carat cut       color clarity depth table price     x     y     z\n#>   <dbl> <fct>     <fct> <fct>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n#> 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#> 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#> 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#> 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#> 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#> 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#> # ℹ more rows\n```\n:::\n\n\n::: callout-note\n与数据库交互有另外两种常见方式。首\n先，许多企业数据库都非常大，因此你需要某种层次结构来保持所有表的组织有序。在\n这种情况下，你可能需要提供一个模式（schema），或者一个目录（catalog）和一个模式（schema），以便选择你感兴趣的表：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds_db <- tbl(con, in_schema(\"sales\", \"diamonds\"))\ndiamonds_db <- tbl(con, in_catalog(\"north_america\", \"sales\", \"diamonds\"))\n```\n:::\n\n\n其他时候，你可能想以自己的SQL查询作为起点：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds_db <- tbl(con, sql(\"SELECT * FROM diamonds\"))\n```\n:::\n\n:::\n\n这个对象是有惰性的；当你在它上面使用dplyr函数时，dplyr不会执行任何操作，它只是记录你想要执行的操作序列，并且只在需要时才执行它们。例\n如，看下面的管道：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbig_diamonds_db <- diamonds_db |> \n  filter(price > 15000) |> \n  select(carat:clarity, price)\n\nbig_diamonds_db\n#> # Source:   SQL [?? x 5]\n#> # Database: DuckDB v0.10.1 [root@Darwin 23.5.0:R 4.3.3/:memory:]\n#>   carat cut       color clarity price\n#>   <dbl> <fct>     <fct> <fct>   <int>\n#> 1  1.54 Premium   E     VS2     15002\n#> 2  1.19 Ideal     F     VVS1    15005\n#> 3  2.1  Premium   I     SI1     15007\n#> 4  1.69 Ideal     D     SI1     15011\n#> 5  1.5  Very Good G     VVS2    15013\n#> 6  1.73 Very Good G     VS1     15014\n#> # ℹ more rows\n```\n:::\n\n\n你可以看出这个对象代表一个数据库查询，因为它在顶部输出DBMS的名称，虽然它告诉你列数，但它通常不知道行数。因\n为查找总行数通常需要执行完整的查询，这是我们试图避免的。\n\n你可以通过dplyr函数`show_query()`来查看生成的SQL代码。如\n果你了解dplyr，这是一个学习SQL的好方法！编\n写一些dplyr代码，让dbplyr将其转换为SQL，然后尝试理解这两种语言是如何对应的。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbig_diamonds_db |>\n  show_query()\n#> <SQL>\n#> SELECT carat, cut, color, clarity, price\n#> FROM diamonds\n#> WHERE (price > 15000.0)\n```\n:::\n\n\n要将所有数据返回到R中，调用`collect()`函数。在\n幕后，这个函数会生成SQL语句，调用`dbGetQuery()`来获取数据，然后将结果转换为一个tibble：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbig_diamonds <- big_diamonds_db |> \n  collect()\nbig_diamonds\n#> # A tibble: 1,655 × 5\n#>   carat cut       color clarity price\n#>   <dbl> <fct>     <fct> <fct>   <int>\n#> 1  1.54 Premium   E     VS2     15002\n#> 2  1.19 Ideal     F     VVS1    15005\n#> 3  2.1  Premium   I     SI1     15007\n#> 4  1.69 Ideal     D     SI1     15011\n#> 5  1.5  Very Good G     VVS2    15013\n#> 6  1.73 Very Good G     VS1     15014\n#> # ℹ 1,649 more rows\n```\n:::\n\n\n通常，你会使用dbplyr从数据库中选择你想要的数据，利用下面描述的转换来进行基本的筛选和聚合。然\n后，当你准备好使用R特有的函数来分析数据时，你会使用`collect()`函数将数据收集到内存中作为一个tibble，并继续用纯R代码进行工作。\n\n## SQL\n\n本章的其余部分将通过dbplyr的视角向你介绍一些SQL知识。虽\n然这是一种非传统的SQL入门方式，但我们希望它能让你快速掌握基础知识。幸\n运的是，如果你了解dplyr，你就已经站在了一个可以快速学习SQL的起点上，因为很多概念都是相同的。\n\n我们将使用nycflights13包中的两个老朋友 `flights`和`planes` 来探索dplyr和SQL之间的关系。这\n些数据集很容易导入到我们的学习数据库中，因为dbplyr提供了一个函数，可以将nycflights13中的表复制到我们的数据库中：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbplyr::copy_nycflights13(con)\n#> Creating table: airlines\n#> Creating table: airports\n#> Creating table: flights\n#> Creating table: planes\n#> Creating table: weather\nflights <- tbl(con, \"flights\")\nplanes <- tbl(con, \"planes\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n### SQL基础\n\nSQL的顶层组件被称为语句 (**statements**)。常\n见的语句包括用于定义新表的`CREATE`、用于添加数据的`INSERT`和用于检索数据的`SELECT`。我\n们将专注于`SELECT`语句，也称为查询 (**queries**)，因为作为数据科学家，你几乎只会使用它们。\n\n一个查询由子句组成。有\n五个重要的子句：`SELECT`、`FROM`、`WHERE`、`ORDER BY`和`GROUP BY`。每\n个查询都必须有`SELECT`[^databases-3]和`FROM`[^databases-4]子句，最简单的查询是`SELECT * FROM table`，它从指定的表中选择所有列\n。这就是dbplyr为一个未经修改的表生成的内容\n：\n\n[^databases-3]: 令人困惑的是，根据上下文，`SELECT`既可以是语句也可以是子句。为\n    了避免这种混淆，我们通常会使用`SELECT`查询而不是`SELECT`语句。\n\n[^databases-4]: 从技术上来说，只有`SELECT`是必需的，因为你可以编写像`SELECT 1+1`这样的查询来进行基本的计算。但\n    如果你想要处理数据（你总是这样做的！），你也需要一个`FROM`子句。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> show_query()\n#> <SQL>\n#> SELECT *\n#> FROM flights\nplanes |> show_query()\n#> <SQL>\n#> SELECT *\n#> FROM planes\n```\n:::\n\n\n`WHERE`和`ORDER BY`控制哪些行被包括在内以及它们的排序方式：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(dest == \"IAH\") |> \n  arrange(dep_delay) |>\n  show_query()\n#> <SQL>\n#> SELECT flights.*\n#> FROM flights\n#> WHERE (dest = 'IAH')\n#> ORDER BY dep_delay\n```\n:::\n\n\n`GROUP BY` 将查询转换为摘要汇总，导致发生聚合：converts the query to a summary, causing aggregation to happen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(dest) |> \n  summarize(dep_delay = mean(dep_delay, na.rm = TRUE)) |> \n  show_query()\n#> <SQL>\n#> SELECT dest, AVG(dep_delay) AS dep_delay\n#> FROM flights\n#> GROUP BY dest\n```\n:::\n\n\ndplyr的动词和SELECT子句之间有两个重要的区别：\n\n-   在SQL中，大小写不敏感：你可以写`select`、`SELECT`，甚至是`SeLeCt`。在本书中，我们将坚持使用常见的约定，将SQL关键字大写以区别于表名或变量名。\n-   在SQL中，顺序很重要：你必须始终按照`SELECT`、`FROM`、`WHERE`、`GROUP BY`、`ORDER BY`的顺序编写子句。令人困惑的是，这个顺序并不匹配子句实际评估的顺序，实际的顺序是首先`FROM`，然后是`WHERE`，`GROUP BY`，`SELECT`，最后是`ORDER BY`。\n\n以下部分将更详细地探讨每个子句。\n\n::: callout-note\n请注意，尽管SQL是一个标准，但它非常复杂，没有哪个数据库能够完全遵循它。尽\n管本书关注的主要组件在不同的DBMS之间非常相似，但仍存在许多细微的差异。幸\n运的是，dbplyr可以用来处理这个问题，并为不同的数据库生成不同的翻译。它\n并不完美，但正在不断改进，如果你遇到问题，可以在[GitHub](https://github.com/tidyverse/dbplyr/issues/)上提交一个问题来帮助我们做得更好。\n:::\n\n### SELECT\n\n`SELECT`子句是查询的支柱，执行与`select()`, `mutate()`, `rename()`, `relocate()` 以及你将在下一节学到的`summarize()`相同的工作。\n\n`select()`, `rename()` 和 `relocate()` 在SQL的`SELECT`中有非常直接的对应关系，因为它们只是影响列出现的位置（如果有的话）及其名称：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplanes |> \n  select(tailnum, type, manufacturer, model, year) |> \n  show_query()\n#> <SQL>\n#> SELECT tailnum, \"type\", manufacturer, model, \"year\"\n#> FROM planes\n\nplanes |> \n  select(tailnum, type, manufacturer, model, year) |> \n  rename(year_built = year) |> \n  show_query()\n#> <SQL>\n#> SELECT tailnum, \"type\", manufacturer, model, \"year\" AS year_built\n#> FROM planes\n\nplanes |> \n  select(tailnum, type, manufacturer, model, year) |> \n  relocate(manufacturer, model, .before = type) |> \n  show_query()\n#> <SQL>\n#> SELECT tailnum, manufacturer, model, \"type\", \"year\"\n#> FROM planes\n```\n:::\n\n\n这个例子还展示了SQL如何进行重命名。在\nSQL术语中重命名被称为别名（**aliasing**），并通过`AS`关键字来完成。请\n注意，与`mutate()`不同，旧名称在左侧，新名称在右侧。\n\n::: callout-note\n在上面的例子中，请注意“year”和“type”被双引号括起来了。这\n是因为这些是duckdb中的保留字 (**reserved words**)，所以dbplyr将它们用引号括起来以避免列/表名与SQL运算符之间的任何潜在混淆。\n\n当与其他数据库一起工作时，你可能会看到每个变量名都被引用了，因为只有少数几个客户端包（如duckdb）知道所有的保留字是什么，所以它们为了安全起见，将所有内容都加上引号。\n\n``` sql\nSELECT \"tailnum\", \"type\", \"manufacturer\", \"model\", \"year\"\nFROM \"planes\"\n```\n\n其他一些数据库系统使用反引号代替引号:\n\n``` sql\nSELECT `tailnum`, `type`, `manufacturer`, `model`, `year`\nFROM `planes`\n```\n:::\n\n`mutate()`的转换同样直接：每个变量都成为`SELECT`中的一个新表达式：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  mutate(\n    speed = distance / (air_time / 60)\n  ) |> \n  show_query()\n#> <SQL>\n#> SELECT flights.*, distance / (air_time / 60.0) AS speed\n#> FROM flights\n```\n:::\n\n\n我们将在 @sec-sql-expressions 讨论单个组件 (如`/`) 的转换。\n\n### FROM\n\n`FROM`子句定义数据源。这\n一段时间你会很无趣，因为我们只是在用单表。在\n学习连接函数之后，你将看到更复杂的示例。\n\n### GROUP BY\n\n`group_by()`被转换成 `GROUP BY`[^databases-5] 子句，而`summarize()`被转换成 `SELECT` 子句：\n\n[^databases-5]: 这并非巧合:dplyr函数名称的灵感来自SQL子句。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds_db |> \n  group_by(cut) |> \n  summarize(\n    n = n(),\n    avg_price = mean(price, na.rm = TRUE)\n  ) |> \n  show_query()\n#> <SQL>\n#> SELECT cut, COUNT(*) AS n, AVG(price) AS avg_price\n#> FROM diamonds\n#> GROUP BY cut\n```\n:::\n\n\n我们将回头在 @sec-sql-expressions 讨论 `n()`和`mean()`的转换是如何进行的。\n\n### WHERE\n\n`filter()` 转换成 `WHERE` 子句:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(dest == \"IAH\" | dest == \"HOU\") |> \n  show_query()\n#> <SQL>\n#> SELECT flights.*\n#> FROM flights\n#> WHERE (dest = 'IAH' OR dest = 'HOU')\n\nflights |> \n  filter(arr_delay > 0 & arr_delay < 20) |> \n  show_query()\n#> <SQL>\n#> SELECT flights.*\n#> FROM flights\n#> WHERE (arr_delay > 0.0 AND arr_delay < 20.0)\n```\n:::\n\n\n这里有几个重要的细节需要注意：\n\n-   `|` 变成了 `OR`， 而 `&` 变成了 `AND`.\n-   SQL 使用 `=` 进行比较，而不是 `==`。SQL 没有赋值操作，所以在这方面没有混淆的可能性。\n-   SQL 只使用单引号 `''` 来标识字符串，而不是双引号 `\"\"`。在 SQL 中，双引号 `\"\"` 用于标识变量，类似于 R 中的反引号 ``` `` ```。\n\n另一个有用的 SQL 操作符是 `IN`，它与 R 中的 `%in%` 非常接近。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(dest %in% c(\"IAH\", \"HOU\")) |> \n  show_query()\n#> <SQL>\n#> SELECT flights.*\n#> FROM flights\n#> WHERE (dest IN ('IAH', 'HOU'))\n```\n:::\n\n\nSQL 使用 `NULL` 而不是 `NA`。`N`\n`ULL` 的行为与 `NA` 类似。主\n要区别在于虽然它们在比较和算术运算中具有“传染性”，但在汇总时它们会被静默地删除。当\n你第一次遇到这种行为时，dbplyr 会提醒你注意这一点。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(dest) |> \n  summarize(delay = mean(arr_delay))\n#> Warning: Missing values are always removed in SQL aggregation functions.\n#> Use `na.rm = TRUE` to silence this warning\n#> This warning is displayed once every 8 hours.\n#> # Source:   SQL [?? x 2]\n#> # Database: DuckDB v0.10.1 [root@Darwin 23.5.0:R 4.3.3/:memory:]\n#>   dest  delay\n#>   <chr> <dbl>\n#> 1 IAH    4.24\n#> 2 MDW   12.4 \n#> 3 CLT    7.36\n#> 4 CAK   19.7 \n#> 5 HOU    7.18\n#> 6 PHX    2.10\n#> # ℹ more rows\n```\n:::\n\n\n如果你想了解更多关于 `NULL` 是如何工作的，你可能会喜欢 Markus Winand 的《[The Three-Valued Logic of SQL](https://modern-sql.com/concept/three-valued-logic)》。\n\n通常，你可以使用在 R 中用于处理 `NA` 的函数来处理 `NULL`：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(!is.na(dep_delay)) |> \n  show_query()\n#> <SQL>\n#> SELECT flights.*\n#> FROM flights\n#> WHERE (NOT((dep_delay IS NULL)))\n```\n:::\n\n\n这个 SQL 查询展示了 dbplyr 的一个缺点：虽然 SQL 是正确的，但它并不像你手动编写时那样简单。在\n这种情况下，你可以去掉括号，并使用一个更易读的特殊操作符：\n\n``` sql\nWHERE \"dep_delay\" IS NOT NULL\n```\n\n请注意，如果你对一个通过`summarize()`创建的变量进行`filter()`操作，dbplyr 会生成一个 `HAVING` 子句，而不是 `WHERE` 子句。这\n是 SQL 的一个特性：`WHERE` 子句在 `SELECT` 和 `GROUP BY` 之前评估，所以 SQL 需要另一个在之后评估的子句，这就是 `HAVING` 子句。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds_db |> \n  group_by(cut) |> \n  summarize(n = n()) |> \n  filter(n > 100) |> \n  show_query()\n#> <SQL>\n#> SELECT cut, COUNT(*) AS n\n#> FROM diamonds\n#> GROUP BY cut\n#> HAVING (COUNT(*) > 100.0)\n```\n:::\n\n\n### ORDER BY\n\n对行进行排序涉及从`arrange()`到`ORDER BY`子句的直接转换：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  arrange(year, month, day, desc(dep_delay)) |> \n  show_query()\n#> <SQL>\n#> SELECT flights.*\n#> FROM flights\n#> ORDER BY \"year\", \"month\", \"day\", dep_delay DESC\n```\n:::\n\n\n请注意`desc()`是如何被转换成`DESC`的：这是许多直接受到SQL启发的dplyr函数之一。\n\n### 子查询 (Subqueries)\n\n有时，无法将dplyr管道转换成单个`SELECT`语句，这时就需要使用子查询。子\n查询只是在`FROM`子句中用作数据源，而不是通常的表。\n\ndbplyr通常使用子查询来克服SQL的限制。例\n如，`SELECT`子句中的表达式不能引用刚刚创建的列。这\n意味着以下（愚蠢的）dplyr管道需要分两步进行：第一个（内部）查询计算`year1`，然后第二个（外部）查询可以计算`year2`。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  mutate(\n    year1 = year + 1,\n    year2 = year1 + 1\n  ) |> \n  show_query()\n#> <SQL>\n#> SELECT q01.*, year1 + 1.0 AS year2\n#> FROM (\n#>   SELECT flights.*, \"year\" + 1.0 AS year1\n#>   FROM flights\n#> ) q01\n```\n:::\n\n\n如果你试图对刚刚创建的变量进行`filter()`操作，你也会遇到这个问题。请\n记住，尽管`WHERE`在`SELECT`之后编写，但它是在`SELECT`之前评估的，所以在这个（愚蠢的）例子中我们需要一个子查询。\n\nYou'll also see this if you attempted to `filter()` a variable that you just created.\nRemember, even though `WHERE` is written after `SELECT`, it's evaluated before it, so we need a subquery in this (silly) example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  mutate(year1 = year + 1) |> \n  filter(year1 == 2014) |> \n  show_query()\n#> <SQL>\n#> SELECT q01.*\n#> FROM (\n#>   SELECT flights.*, \"year\" + 1.0 AS year1\n#>   FROM flights\n#> ) q01\n#> WHERE (year1 = 2014.0)\n```\n:::\n\n\n有时，dbplyr 会在不需要子查询的情况下创建子查询，因为它还不知道如何优化这种转换。随\n着时间的推移，dbplyr 的改进会使这种情况越来越少，但可能永远不会完全消失。\n\n### Joins\n\n如果你熟悉dplyr的连接（joins），那么SQL的连接是非常相似的。下\n面是一个简单的例子：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  left_join(planes |> rename(year_built = year), by = \"tailnum\") |> \n  show_query()\n#> <SQL>\n#> SELECT\n#>   flights.*,\n#>   planes.\"year\" AS year_built,\n#>   \"type\",\n#>   manufacturer,\n#>   model,\n#>   engines,\n#>   seats,\n#>   speed,\n#>   engine\n#> FROM flights\n#> LEFT JOIN planes\n#>   ON (flights.tailnum = planes.tailnum)\n```\n:::\n\n\n这里需要注意的主要是语法：SQL 连接使用 `FROM` 子句的子句来引入其他表，并使用 `ON` 来定义表之间的关系。\n\ndplyr 中这些函数的命名与 SQL 如此紧密相关，以至于你可以很容易地猜出 `inner_join()`、`right_join()` 和 `full_join()` 的等效 SQL 语句：\n\n``` sql\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nINNER JOIN planes ON (flights.tailnum = planes.tailnum)\n\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nRIGHT JOIN planes ON (flights.tailnum = planes.tailnum)\n\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nFULL JOIN planes ON (flights.tailnum = planes.tailnum)\n```\n\n当从数据库中处理数据时，你可能需要很多连接操作。这\n是因为数据库表通常以高度规范化的形式存储，其中每个“事实”都存储在单个位置，为了保持完整的数据集以供分析，你需要遍历由主键和外键连接的复杂表网络。如\n果你遇到这种情况，Tobias Schieferdecker、Kirill Müller 和 Darko Bergant 开发的 [dm](https://cynkra.github.io/dm/) 包将是一个救星。它\n可以使用 DBA 通常提供的约束自动确定表之间的连接，可视化这些连接以便你可以看到发生了什么，并生成你需要的连接来将一个表连接到另一个表。\n\n### 其他函数\n\ndbplyr 还翻译了其他函数，如`distinct()`、`slice_*()`、和`intersect()` 以及越来越多的 tidyr 函数，如`pivot_longer()`和`pivot_wider()`。查\n看当前可用的完整集合的最简单方法是访问 dbplyr 网站：[https://dbplyr.tidyverse.org/reference/](https://dbplyr.tidyverse.org/reference/%E3%80%82) 。\n\n### 练习\n\n1.  `distinct()` 被转换成什么？\n    那么`head()`呢？\n\n2.  解释下面每个SQL查询的作用，并尝试使用dbplyr重新创建它们。\n\n    ``` sql\n    SELECT * \n    FROM flights\n    WHERE dep_delay < arr_delay\n\n    SELECT *, distance / (air_time / 60) AS speed\n    FROM flights\n    ```\n\n## 函数转换 {#sec-sql-expressions}\n\n到目前为止，我们主要关注了 dplyr 函数如何被转换成查询的子句。现\n在我们将稍微深入一些，讨论与单个列一起工作的 R 函数的转换，例如，当你在`summarize()`中使用`mean(x)`时会发生什么？\n\n为了帮助我们了解正在发生的事情，我们将使用几个辅助函数来运行`summarize()`或`mutate()`并显示生成的 SQL。这\n将使探索一些变体以及汇总和转换如何不同变得更加容易。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize_query <- function(df, ...) {\n  df |> \n    summarize(...) |> \n    show_query()\n}\nmutate_query <- function(df, ...) {\n  df |> \n    mutate(..., .keep = \"none\") |> \n    show_query()\n}\n```\n:::\n\n\n让我们深入一些汇总！查\n看下面的代码，你会注意到一些汇总函数，如`mean()`，其转换相对简单，而其他一些函数，如`median()`则复杂得多。这\n种复杂性通常出现在统计学中常见但在数据库中不太常见的操作中。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(year, month, day) |>  \n  summarize_query(\n    mean = mean(arr_delay, na.rm = TRUE),\n    median = median(arr_delay, na.rm = TRUE)\n  )\n#> `summarise()` has grouped output by \"year\" and \"month\". You can override\n#> using the `.groups` argument.\n#> <SQL>\n#> SELECT\n#>   \"year\",\n#>   \"month\",\n#>   \"day\",\n#>   AVG(arr_delay) AS mean,\n#>   PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY arr_delay) AS median\n#> FROM flights\n#> GROUP BY \"year\", \"month\", \"day\"\n```\n:::\n\n\n当在`mutate()`内部使用汇总函数时，其转换会变得更加复杂，因为它们需要变成所谓的窗口 (**window**) 函数。在\nSQL 中，你可以通过在聚合函数后面添加`OVER`来将其转变为窗口函数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(year, month, day) |>  \n  mutate_query(\n    mean = mean(arr_delay, na.rm = TRUE),\n  )\n#> <SQL>\n#> SELECT\n#>   \"year\",\n#>   \"month\",\n#>   \"day\",\n#>   AVG(arr_delay) OVER (PARTITION BY \"year\", \"month\", \"day\") AS mean\n#> FROM flights\n```\n:::\n\n\n在 SQL 中，`GROUP BY`子句专门用于汇总，因此你可以看到分组已经从`PARTITION BY`参数移动到了`OVER`子句中。\n\n窗口函数包括所有向前或向后查看的函数，如`lead()`和`lag()`，它们分别查看“前一个”或“后一个”值：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(dest) |>  \n  arrange(time_hour) |> \n  mutate_query(\n    lead = lead(arr_delay),\n    lag = lag(arr_delay)\n  )\n#> <SQL>\n#> SELECT\n#>   dest,\n#>   LEAD(arr_delay, 1, NULL) OVER (PARTITION BY dest ORDER BY time_hour) AS lead,\n#>   LAG(arr_delay, 1, NULL) OVER (PARTITION BY dest ORDER BY time_hour) AS lag\n#> FROM flights\n#> ORDER BY time_hour\n```\n:::\n\n\n在这里，对数据进行`arrange()`排序是很重要的，因为 SQL 表没有固有的顺序。事\n实上，如果不使用`arrange()`，你可能会每次得到不同顺序的行！请\n注意，对于窗口函数排序信息是重复的：主查询的 `ORDER BY` 子句不会自动应用于窗口函数。\n\n另一个重要的 SQL 函数是 `CASE WHEN`。它\n被用作`if_else()`和`case_when()`的翻译，这两个 dplyr 函数直接受到它的启发。这\n里有几个简单的例子：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  mutate_query(\n    description = if_else(arr_delay > 0, \"delayed\", \"on-time\")\n  )\n#> <SQL>\n#> SELECT CASE WHEN (arr_delay > 0.0) THEN 'delayed' WHEN NOT (arr_delay > 0.0) THEN 'on-time' END AS description\n#> FROM flights\nflights |> \n  mutate_query(\n    description = \n      case_when(\n        arr_delay < -5 ~ \"early\", \n        arr_delay < 5 ~ \"on-time\",\n        arr_delay >= 5 ~ \"late\"\n      )\n  )\n#> <SQL>\n#> SELECT CASE\n#> WHEN (arr_delay < -5.0) THEN 'early'\n#> WHEN (arr_delay < 5.0) THEN 'on-time'\n#> WHEN (arr_delay >= 5.0) THEN 'late'\n#> END AS description\n#> FROM flights\n```\n:::\n\n\n`CASE WHEN` 也用于一些没有从 R 到 SQL 直接翻译的函数。`c`\n`ut()`函数就是一个很好的例子：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  mutate_query(\n    description =  cut(\n      arr_delay, \n      breaks = c(-Inf, -5, 5, Inf), \n      labels = c(\"early\", \"on-time\", \"late\")\n    )\n  )\n#> <SQL>\n#> SELECT CASE\n#> WHEN (arr_delay <= -5.0) THEN 'early'\n#> WHEN (arr_delay <= 5.0) THEN 'on-time'\n#> WHEN (arr_delay > 5.0) THEN 'late'\n#> END AS description\n#> FROM flights\n```\n:::\n\n\ndbplyr 还转换了常见的字符串和日期-时间处理函数，你可以在 `vignette(\"translation-function\", package = \"dbplyr\")` 了解到更多信息。d\nbplyr 的转换当然不是完美的，而且还有很多 R 函数尚未被转换，但 dbplyr 在涵盖你大部分时间都会使用的函数方面做得相当出色。\n\n## 小结\n\n在本章中，你学习了如何从数据库中访问数据。我\n们专注于 dbplyr，它是一个 dplyr 的“后端”，允许你编写你熟悉的 dplyr 代码并自动将其转换为 SQL。我\n们利用这种转换来教你一点 SQL；学习一些 SQL 是很重要的，因为 SQL 是最常用于处理数据的语言，了解一些 SQL 将使你更容易与其他不使用 R 的数据专业人士交流。如\n果你已经完成了本章并希望了解更多关于 SQL 的知识，我们有两个推荐：\n\n-   Renée M.P. Teate 的《[SQL for Data Scientists](https://sqlfordatascientists.com)》是一本专门为数据科学家设计的 SQL 入门书籍，包含了你在真实组织中可能遇到的高度互联数据的示例。\n\n-   Anthony DeBarros 的《[Practical SQL](https://www.practicalsql.com)》是从数据记者（专注于讲述引人入胜故事的数据科学家）的角度编写的，并详细介绍了如何将数据导入数据库以及运行自己的 DBMS。\n\n在下一章中，我们将学习使用另一个 dplyr 后端来处理大数据：arrow。A\nrrow 专为处理磁盘上的大文件而设计，是数据库的天然补充。\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}